<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>格的初探</title>
      <link href="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/"/>
      <url>/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="格的定义">格的定义</h2><p>任何一组<strong>线性无关</strong>的向量所生成的<strong>系数为整数</strong>的<strong>向量集合</strong>称为格。</p><p>即<br><span class="math display">\[L=\begin{Bmatrix} a_{1}\nu _{1}+a_{2}\nu  _{2}+...+a_{n}\nu_{n},&amp;a_{1},a_{2},...,a_{n}\in Z \end{Bmatrix}\]</span> 这一组线性无关的向量<span class="math inline">\(v_{1},v_{2},...,v_{n}\)</span>就是格<span class="math inline">\(L\)</span>的基。格<span class="math inline">\(L\)</span>的元素是<span class="math inline">\(v_{1},v_{2},...,v_{n}\)</span>的整系数线性组合。某种程度上，格可以理解为<strong>系数为整数的向量空间。</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/Harry0597/Imag@master/uPic/image-20221115221257017.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="格基变换">格基变换</h2><p>格的基是一组<strong>线性无关的向量</strong>，由这一组向量可以生成完整的格。也就是可以由它们线性组合构成所有的格点。基所包含的<strong>向量个数</strong>成为格的<strong>维度</strong>。通常，<strong>一个格可以有多组基</strong>，也就是说，不同的基可能生成同一个格。</p><figure><img src="https://cdn.jsdelivr.net/gh/Harry0597/Imag@master/uPic/image-20221130231915760.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>那么如何判断两组格基可以生成同一个格？</p><p>如果把格基用矩阵表示（列向量为每一个基），则对格基做以下操作，对应的格不变：</p><p>1.列向量交换：<span class="math inline">\(v_{i}\leftrightarrowv_{j}\)</span></p><p>2.向量取负：<span class="math inline">\(v_{i}\leftrightarrow-v_{i}\)</span></p><p>3.给一个向量加上k乘另一个向量：<span class="math inline">\(v_{i}\leftrightarrow v_{i}+k*v_{j}\)</span></p><p>更加有趣的是，上述操作均对应为<strong>给格基矩阵右乘一个幺模矩阵</strong>，幺模矩阵是一种特殊矩阵，其为<strong>整数矩阵</strong>，其行列式的值为<strong>正负1</strong>，且这种矩阵的乘法具有封闭性，幺模矩阵的乘积仍为幺模矩阵。</p><p><strong>定理：两个格基等价，当且仅当可以把两格基写成以下格式：</strong><span class="math display">\[B_{2}=B_{1}U\]</span> 其中，<span class="math inline">\(U\)</span>是一个幺模矩阵。</p><p>假定<span class="math inline">\(v_{1},v_{2},...,v_{n}\)</span>是格的一组基，<span class="math inline">\(w_{1},w_{2},...,w{n}\inL\)</span>，则必然存在整系数<span class="math inline">\(a_{ij}\)</span>使得 <span class="math display">\[\left\{\begin{matrix}w_{1} =a_{11}v_{1}+a_{12}v_{2}+...+a_{1n}v_{n}\\w_{2}=a_{21}v_{1}+a_{22}v_{2}+...+a_{2n}v_{n}\\...\\w_{n}=a_{n1}v_{1}+a_{n2}v_{2}+...+a_{nn}v_{n}\end{matrix}\right.\]</span>这样，格的问题，我们就可以<strong>转化为矩阵运算</strong>了。</p><h2 id="格的基本域">格的基本域</h2><h3 id="什么是基本域">什么是基本域</h3><p><img src="/github.io/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img1.png" alt="img1">!](格的初探/img1.png)</p><p>几何上，基本域就是<strong>这组基围出的区域</strong>，如上图中的阴影部分。</p><h3 id="基本域的性质">基本域的性质</h3><p>一个 lattice会有不同的基，也就会有不同的基本域，但<strong>每个基本域的体积(无论什么形状的)都一样</strong>。</p><h3 id="基本域的应用">基本域的应用</h3><p>另外，我们还可以将空间中的点映射到基本域上，判断<strong>点是否在格上</strong>。</p><p>基本域的表示方法：</p><p>​<br><span class="math display">\[P(B)=a_{1}v_{1}+a_{2}v_{2}+...+a_{n}v_{n},a_{i}\in [0,1)\]</span></p><p>现在假设空间中有一个点，表示为</p><p>​<br><span class="math display">\[x=a_{1}v_{1}+a_{2}v_{2}+...+a_{n}v_{n}\]</span> 那么当对这个点在基本域范围内做模运算时，只需把每个系数<span class="math inline">\(a_{i}\)</span>模1乘上基向量即可。</p><p>​<br><span class="math display">\[x\textbf{ }mod\textbf{ }P(B)=(a_{1}\textbf{ }mod\textbf{}1)*v_{1}+(a_{2}\textbf{ }mod\textbf{ }1)*v_{2}+...+(a_{n}\textbf{}mod\textbf{ }1)*v_{n}\]</span> 这样就把这个点映射到基本域上了。</p><h2 id="行列式协体积">行列式（协体积）</h2><p>格的行列式是<strong>基向量构成的多面体的体积</strong>（标量），也就是基本域的体积。前面说过格的每个基本域的体积是相等的，所以<strong>行列式是格的固有属性</strong>，同一个格选取的不同组基，行列式是相等的。</p><p>前面也讲过格基变换，两组基要生成同一个格，当且仅当两者可以乘一个幺模矩阵进行相互转化，即</p><p>​<br><span class="math display">\[|det(BU)|=|det(B)det(U)|=|det(B)|\]</span>需要注意的是，<strong>行列式可以用来衡量格密度的大小，若行列式越大，格密度越小</strong>。</p><p>再来看一下<strong>协体积的上限</strong>。 若构成 lattice的基向量长度固定，要想得到<strong>最大的协体积</strong>，必然各个基向量都要是<strong>正交</strong>的（类比，长度相同的四条线段要围成平行四边形，当且仅当是正方形是面积最大），于是我们就得到了协体积的上限:</p><p>​<br><span class="math display">\[设L是一个格，F是L的一个基本域，任取一组基向量V_{1},v_{2},..,v_{n}，\\那                             么|det(L)|=Vol(F)\leqslant||v_{1}||*||v_{2}||*...*||v_{n}||\]</span><strong>基向量的各个向量越趋近于正交，行列式越接近上限，当是正交时，上面不等式取到等号</strong>。</p><h2 id="格的困难问题">格的困难问题</h2><h3 id="svpthe-shortest-vector-problem">SVP(The shortest vectorproblem)</h3><p>最短向量问题:找到格中的最短向量，也就是在格中找到一个非零向量<span class="math inline">\(v\in L\)</span>使得<span class="math inline">\(||v||\)</span>最小。</p><h4 id="svp的上限">SVP的上限</h4><p>一个格的最短非零向量到底有多短呢？这其实是<strong>和格的维度以及行列式有关</strong>。</p><p>根据Hermite定理， 有</p><p>​<br><span class="math display">\[\lambda (\Lambda )\leqslant \sqrt{n}*\sqrt[n]{det(\Lambda )}\]</span> ​</p><p>其中，<span class="math inline">\(\Lambda\)</span>是格基矩阵，<span class="math inline">\(\lambda (\Lambda )\)</span>是格中最短向量，<span class="math inline">\(det()\)</span>是行列式</p><h3 id="cvpthe-closest-vector-problem">CVP(<strong>The Closest VectorProblem</strong>)</h3><p>最近向量问题：给定格外的一个点，找到格中离它最近或近似最近的格点。CVP一般要比SVP困难的多，<strong>SVP可以规约到CVP</strong>。</p><h2 id="lll算法格基规约">LLL算法(格基规约)</h2><p>在1982年，A.K.Lenstra，H.W.Lenstra,Jr 和 L.lovasz 提出一种解决 SVP问题的算法，通常称之为<span class="math inline">\(LLL\)</span>算法，它是一种<strong>格基规约算法</strong>。</p><p>在求解 SVI的问题时，最先想到的是对格基进行多种线性组合的尝试，其中最难的问题是如何<strong>基向量变小</strong>，<strong>使基向量最大程度的趋于正交化。</strong></p><figure><img src="https://img-blog.csdnimg.cn/b7d6dd48560f4c8d92a5c151fdb46f86.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZSg5ZeR77yB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>需要 Gram-Schmidt(施密特) 正交化知识的铺垫。</p><h3 id="gram-schmidt施密特-正交化">Gram-Schmidt(施密特) 正交化</h3><p><span class="math display">\[如果x_{1},x_{2},...,x_{n}是某向量空间中的基，那么可通过下列做法找到该向量空间中的n个两两正交的向量\\v_{1},v_{2},...,v_{n},称为施密特正交化。v_{1},v_{2},...,v_{n}就是该向量空间中的一组正交基。\]</span></p><p><img src="/github.io/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img2.png" alt="img2">!](格的初探/img2.png)</p><p>现在我们对探讨如何寻找二维空间的正交基。</p><p>下图是二维空间<span class="math inline">\(R^{n}\)</span>的一组基</p><figure><img src="https://img-blog.csdnimg.cn/b332a58a9842482b8e49b5a5a3e51129.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>只要将其中一个向量对另外一个向量进行投影，就可以得到<span class="math inline">\(R^{n}\)</span> 的一组正交基：</p><figure><img src="https://img-blog.csdnimg.cn/d9be3c2a5c0d47ddba0056308599fd00.gif" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>下面我们来进行代数推导，假设基为<span class="math inline">\(x_{1},x_{2}\)</span>，选择<span class="math inline">\(x_{1}\)</span>作为<span class="math inline">\(v_{1}\)</span>,作出<span class="math inline">\(x_{2}\)</span>在<span class="math inline">\(v_{1}\)</span>所在直线上的投影<span class="math inline">\(\vec{x_{2}}\)</span>,连接<span class="math inline">\(x_{2},\vec{x_{2}}\)</span>所得到垂线就是<span class="math inline">\(v_{2}\)</span></p><p><img src="https://img-blog.csdnimg.cn/95cf8161a4194ba9b85ea30111c5c167.png" alt="img"> <span class="math display">\[\left\{\begin{matrix}v_{1} =x_{2}\\v_{2}=x_{2}-\vec{x_{2}}\end{matrix}\right.\Rightarrow \left\{\begin{matrix}v_{1} =x_{2}\\v_{2}=v_{1}-\vec{kv_{1}}\end{matrix}\right.\]</span></p><p><span class="math display">\[由v_{1}v_{2}=0得v_{1}*(v_{1}-kv_{2})=0\Rightarrowk=\frac{v_{2}v_{1}}{v_{1}v_{1}}\]</span></p><p><span class="math display">\[\therefore该向量空间的一组正交基为 \left\{\begin{matrix}v_{1}=x_{1}\\v_{2}=v_{1}-\frac{v_{2}v_{1}}{v_{1}v_{1}}\end{matrix}\right.\]</span></p><p>这样就可以推广到<span class="math inline">\(m\)</span>维向量空间施密特正交化：</p><p><img src="/github.io/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img.png" alt="img">!](格的初探/img.png)</p><h3 id="格基规约的条件">格基规约的条件</h3><p><span class="math inline">\(LLL\)</span>格基规约需要满足以下两个条件： <span class="math display">\[{\forall}1\leq i\leqslant n,j&lt; i,|u_{i,j}|\leq \frac{1}{2}\]</span></p><p><span class="math display">\[{\forall}1\leq i&lt; n,\delta ||b_{i}||^{2}\leqslant||u_{i+1,i}b_{i}+b_{i+1}||^2\]</span></p><p><span class="math inline">\(LLL\)</span>算法最终输出的基称为<span class="math inline">\(LLL\)</span>约化基。</p><h3 id="格基约化的性质">格基约化的性质</h3><p>1、<span class="math inline">\(\delta=\frac{3}{4}\)</span>是该算法的一个特例，<span class="math inline">\(LLL\)</span>算法成立的前提是<span class="math inline">\(\frac{1}{4}&lt; \delta&lt; 1\)</span>.</p><p>2、根据格约化基的定义得， <span class="math display">\[\delta ||b_{i}||^{2}\leqslant||u_{i+1,i}b_{i}+b_{i+1}||^2=u_{i+1,i}^2||b_{i}||^2+||b_{i+1}||^2\]</span></p><p><span class="math display">\[\therefore ||b_{i+1}||^2\geq (\delta -u_{i+1,i}^2)||b_{i}||^2=(\delta-\frac{1}{4})||b_{i}||^2\]</span></p><p>所以<span class="math inline">\(b_{i+1}\)</span>不会比<span class="math inline">\(b_{i}\)</span>短太多。</p><h2 id="例题">例题</h2><p>例题来自 NSSCTF 平台。之前看了格密码理论和做题联系不起来，看了DexterJie 师傅的博客后受益匪浅。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p = getPrime(1024)</span><br><span class="line"></span><br><span class="line">f = getPrime(400)</span><br><span class="line">g = getPrime(512)</span><br><span class="line">r = getPrime(400)</span><br><span class="line"></span><br><span class="line">h = inverse(f, p) * g % p</span><br><span class="line"></span><br><span class="line">m = b&#x27;******&#x27;</span><br><span class="line">m = bytes_to_long(m)</span><br><span class="line"></span><br><span class="line">c = (r*h + m) % p</span><br><span class="line"></span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line">print(f&#x27;h = &#123;h&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p = 170990541130074930801165526479429022133700799973347532191727614846803741888876816210632483231997413973919037199883422312436314365293577997262903161076615619596783971730864586404602951191341733308807254112018161897113881363794353050758324742415299277578203838160939521046655099610387485947145087271531951477031</span><br><span class="line">h = 19027613518333504891337723135627869008620752060390603647368919831595397216728378486716291001290575802095059192000315493444659485043387076261350378464749849058547797538347059869865169867814094180939070464336693973680444770599657132264558273692580535803622882040948521678860110391309880528478220088107038861065</span><br><span class="line">c = 75639016590286995205676932417759002029770539425113355588948888258962338419567264292295302442895077764630601149285564849867773180066274580635377957966186472159256462169691456995594496690536094824570820527164224000505303071962872595619159691416247971024761571538057932032549611221598273371855762399417419551483</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>先根据题目进行一下公式推导，已知：</p>加密： <span class="math display">\[h=f^{-1}*g\textbf{ }mod \textbf{ }p\Rightarrowg=k*p+h*f\\c=(rh+m)\textbf{ }mod\textbf{ }p\Rightarrow(r*f^{-1}*g+m)\textbf{ }mod\textbf{ }p\]</span> 解密： <span class="math display">\[f*c=(r*g+m*f)\textbf{ }mod\textbf{ }p\\\Rightarrow m*f=(f*c-r*g)\textbf{}mod \textbf{ }p\\\Rightarrow m*f=((f*c)\textbf{ }mod\textbf{}p)mod\textbf{ }g\\\Rightarrow m=((f*c\textbf{ }mod\textbf{}p)*f^{-1})mod\textbf{ }g\]</span> 所以要求 <span class="math inline">\(m\)</span>,我们必须得先求出 <span class="math inline">\(f\)</span>。<span class="math inline">\(p,h,c\)</span>是已知的，我们根据$g=k<em>p+h</em>f$构造出格： $$<span class="math display">\[\begin{bmatrix}k,f\end{bmatrix}\begin{bmatrix}p,0\\h,1\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}g,f\end{bmatrix}\]</span><p>$$ 在这里，我们相当于用<span class="math inline">\(LLL\)</span>算法对<span class="math inline">\((p,0),(h,1)\)</span>这一组基进行格基约化，使这组基变成施密特正交化程度最大的一组基，这样我们就可以求解<span class="math inline">\(SVP\)</span>问题了。也就是说，向量<span class="math inline">\((g,f)\)</span>是最短向量。我们来证明一下：</p><p>我们知道最短向量的上限与格的维度和行列式有关： <span class="math display">\[\lambda (\Lambda )\leqslant \sqrt{n}*\sqrt[n]{det(\Lambda )}\]</span> 所以，对于格<span class="math inline">\(L\)</span><span class="math inline">\(\bigl(\begin{smallmatrix} p,0 \\ h,1\end{smallmatrix}\bigr)\)</span>,<span class="math inline">\(\lambda(L)\leqslant\sqrt{2p}\)</span></p><p>我们来计算一下，<span class="math inline">\(p\)</span> 是 <span class="math inline">\(1024 bit\)</span>,<span class="math inline">\(g\)</span>是 <span class="math inline">\(512bit\)</span>,<span class="math inline">\(f\)</span>是 <span class="math inline">\(400bit\)</span>, <span class="math display">\[||(g,f)||=\sqrt{1024+800}=\sqrt{1824})\leqslant\sqrt{2048}\]</span> 是满足的，所以说<span class="math inline">\((g,f)\)</span>是最短向量是正确的。</p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p = 170990541130074930801165526479429022133700799973347532191727614846803741888876816210632483231997413973919037199883422312436314365293577997262903161076615619596783971730864586404602951191341733308807254112018161897113881363794353050758324742415299277578203838160939521046655099610387485947145087271531951477031</span><br><span class="line">h = 19027613518333504891337723135627869008620752060390603647368919831595397216728378486716291001290575802095059192000315493444659485043387076261350378464749849058547797538347059869865169867814094180939070464336693973680444770599657132264558273692580535803622882040948521678860110391309880528478220088107038861065</span><br><span class="line">c = 75639016590286995205676932417759002029770539425113355588948888258962338419567264292295302442895077764630601149285564849867773180066274580635377957966186472159256462169691456995594496690536094824570820527164224000505303071962872595619159691416247971024761571538057932032549611221598273371855762399417419551483</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mat = [[h,1],[p,0]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">g,f = M.LLL()[0]</span><br><span class="line"></span><br><span class="line">m = (f * c %p* invert(f,g)) %g</span><br><span class="line">flag = long_to_bytes(int(m))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>最后附上参考文章：</p><p><a href="https://www.ruanx.net/lattice-2/">格密码笔记（二）(ruanx.net)</a></p><p><a href="https://www.zimablue.life/2022/05/04/Lattice-Lesson0/">Lattice-Lesson0| ZimaBlue's Blog</a></p><p>https://dexterjie.github.io/2023/07/28/%E5%88%9D%E8%AF%86%E6%A0%BC/#LLL%E7%AE%97%E6%B3%95</p>]]></content>
      
      
      <categories>
          
          <category> 格密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔一</title>
      <link href="/2023/08/13/%E9%9A%8F%E7%AC%94%E4%B8%80/"/>
      <url>/2023/08/13/%E9%9A%8F%E7%AC%94%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一同余式求模数">一、同余式求模数</h2><p>已知 a % flag = (a%p)，且 a 、(a%p)以及 flag 的格式已知，a是一个素数，求 flag.</p><p>令 t = (a%p),有 <span class="math display">\[a \equiv t \textbf{ }mod\textbf{ }flag\Rightarrow a= k*flag+t\]</span></p><p><span class="math display">\[\Rightarrow k*flag=a-t\]</span> 所以 k*flag 我们是知道的，问题是我们如何才能求出 flag 呢？</p><p>这里我们可以将 k*flag 分解成多个素因子的乘积，而flag必定是其中几个素因子的乘积。可以将分解出来的各个素因子进行排列组合，求出每一种可能的乘积，找出符合flag 格式的那一种可能就行。</p><h2 id="二rsa中已知-kphi">二、RSA中已知 k*phi</h2><p>已知 <span class="math display">\[n = p*q*r,hint = p*s*q - p*s -q*s+s,且r也已知\]</span></p><p>可以得到， <span class="math display">\[n_{1}=n/(p*q),hint=s*(p*q-p-q+1)=s*phi\]</span> 这个 phi 是 n1 的欧拉函数，就可以用 s*phi 代替 phi进行求解。</p><p>推导一下， <span class="math display">\[m\equiv c^{d}\textbf{ }mod \textbf{ }n\Rightarrow m\equiv(m^{e})^{d}\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[\because e*d\equiv 1\textbf{ }mod\textbf{ }k*phi\Rightarrowe*d=k_{1}*k*phi+1\]</span></p><p><span class="math display">\[\therefore m\equiv m^{k_{1}*k*phi+1}\textbf{ }mod\textbf{ }n\Rightarrowm\equiv m^{k_{1}*k*phi}*m\textbf{ }mod\textbf{ }n\]</span></p><p>又由费马小定理可知， <span class="math display">\[m^{\varphi (n)}\equiv 1\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[\therefore m\equiv 1*m\textbf{ }mod\textbf{ }n\]</span></p><p>综上，用 k*phi 代替 phi 进行求解是可行的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCG入门</title>
      <link href="/2023/08/10/LCG%E5%85%A5%E9%97%A8/"/>
      <url>/2023/08/10/LCG%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="lcg线性同余生成器">LCG(线性同余生成器)</h2><p>LCG属于PRNG(伪随机数生成器)和streamcipher(流密码)的一种，是一种产生伪随机数的方法。 <span class="math display">\[X_{n+1}=(a*X_{n}+b)\textbf{ }mod\textbf{ }m\]</span>其中，Xn代表第n个生成的随机数，X0被称为种子值。这里还定义了三个整数：a乘数、b增量、m模数，是产生器设定的常数。</p><h2 id="参数选择">参数选择</h2><p>LCG的性质与参数的选择密切相关，不同的参数可能导致不同的随机序列。一般按照如下要求选择参数：</p><p>1、m是随机序列的模数，必须一个大于0的正整数。一般是一个比较大的素数或者是2的幂，以便提供较长的周期长度。</p><p>2、a是乘数，必须是一个与m互素的正整数。</p><p>3、b是增量，也必须是一个与m互素的正整数。</p><h2 id="常用公式">常用公式</h2><h3 id="公式一由xn1反推xn">公式一：由Xn+1反推Xn</h3><p><span class="math display">\[X_{n}=((X_{n+1}-b)*a^{-1})\textbf{ }mod\textbf{ }m，这里a^{-1}是模逆元\]</span></p><h3 id="公式二求a">公式二：求a</h3><p><span class="math display">\[\left\{\begin{matrix}X_{n+1} &amp; = &amp;(a*X_{n}+b)  &amp;mod  &amp;m \\X_{n} &amp; = &amp;(a*X_{n-1})  &amp; mod &amp;m\end{matrix}\right.\Rightarrowa=((X_{n+1}-X_{n})*(X_{n}-X_{n-1})^{-1}\textup{ })mod\textbf{ }m\]</span></p><h3 id="公式三求b">公式三：求b</h3><p><span class="math display">\[b=(X_{n+1}-a*X_{n})\textbf{ }mod\textbf{ }m\]</span></p><h3 id="公式四求m">公式四：求m</h3><p><span class="math display">\[t_{n}=X_{n+1}-X_{n},t_{n}=(a*X_{n}+b)-(a*X_{n-1}+b)=a(X_{n}-X_{n-1})=a*t_{n-1}\textbf{} mod\textbf{ }m.\]</span></p><p><span class="math display">\[\thereforet_{n+1}t_{n-1}-t_{n}t_{n}=a*a*t_{n-1}*t_{n-1}-a*t_{n-1}*a*t_{n-1}=0\textup{}mod\textup{ }m\]</span></p><p><span class="math display">\[即T_{n}=t_{n+1}t_{n-1}-t_{n}t_{n}是m的倍数，故T_{n}和T_{n-1}的最大公因数即为m\]</span></p><h2 id="常见六种题型">常见六种题型</h2><p><strong><em>LCG_1:a、b、m都知道，此类题相当于由Xn+1反推Xn.</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;lcg.a&#125;&#x27;)</span><br><span class="line">print(f&#x27;b = &#123;lcg.b&#125;&#x27;)</span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 113439939100914101419354202285461590291215238896870692949311811932229780896397</span><br><span class="line">b = 72690056717043801599061138120661051737492950240498432137862769084012701248181</span><br><span class="line">m = 72097313349570386649549374079845053721904511050364850556329251464748004927777</span><br><span class="line">9772191239287471628073298955242262680551177666345371468122081567252276480156</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>有一个问题就是，我们需要反推多少项呢？我们并不知道，因为迭代的次数(getPrime(16))是一个随机数。但是这并不妨碍我们求解flag。因为flag的格式(b'NSSFCT{')我们已经知道，只需要不断反推，直至找到符合格式的flag为止。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">a = 113439939100914101419354202285461590291215238896870692949311811932229780896397</span><br><span class="line">b = 72690056717043801599061138120661051737492950240498432137862769084012701248181</span><br><span class="line">m = 72097313349570386649549374079845053721904511050364850556329251464748004927777</span><br><span class="line">c=9772191239287471628073298955242262680551177666345371468122081567252276480156</span><br><span class="line"></span><br><span class="line"># c=(a*c0+b)%m</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c - b) * a_1 % m</span><br><span class="line">    #print(c)</span><br><span class="line">    flag=libnum.n2s(int(c))</span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_2:不知道b,要先求出b,之后操作就和LCG_1没什么区别了</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;lcg.a&#125;&#x27;)</span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 83968440254358975953360088805517488739689448515913931281582194839594954862517</span><br><span class="line">m = 77161425490597512806099499399561161959645895427463118872087051902811605680317</span><br><span class="line">43959768681328408257423567932475057408934775157371406900460140947365416240650</span><br><span class="line">8052043336238864355872102889254781281466728072798160448260752595038552944808</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">from Crypto.Util.number import isPrime</span><br><span class="line"></span><br><span class="line">a = 83968440254358975953360088805517488739689448515913931281582194839594954862517</span><br><span class="line">m = 77161425490597512806099499399561161959645895427463118872087051902811605680317</span><br><span class="line">c1=43959768681328408257423567932475057408934775157371406900460140947365416240650</span><br><span class="line">c2=8052043336238864355872102889254781281466728072798160448260752595038552944808</span><br><span class="line"></span><br><span class="line">b=(c2-a*c1) % m</span><br><span class="line">#print(b)</span><br><span class="line">#print(gmpy2.gcd(b,m))</span><br><span class="line">a_1 = gmpy2.invert(a,m)</span><br><span class="line">c = c1</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c-b) * a_1 % m</span><br><span class="line">    flag = libnum.n2s(int(c))</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_3:a、b都不知道，先求出a,之后操作同LCG_2</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">m = 96343920769213509183566159649645883498232615147408833719260458991750774595569</span><br><span class="line">10252710164251491500439276567353270040858009893278574805365710282130751735178</span><br><span class="line">45921408119394697679791444870712342819994277665465694974769614615154688489325</span><br><span class="line">27580830484789044454303424960338587428190874764114011948712258959481449527087</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">m = 96343920769213509183566159649645883498232615147408833719260458991750774595569</span><br><span class="line">c1 = 10252710164251491500439276567353270040858009893278574805365710282130751735178</span><br><span class="line">c2 = 45921408119394697679791444870712342819994277665465694974769614615154688489325</span><br><span class="line">c3 = 27580830484789044454303424960338587428190874764114011948712258959481449527087</span><br><span class="line"></span><br><span class="line">a = (c3-c2) * gmpy2.invert(c2-c1,m) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line">a_1 = gmpy2.invert(a,m)</span><br><span class="line">b = (c2-a*c1) % m</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">c = c1</span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c-b) * a_1 % m</span><br><span class="line">    flag = libnum.n2s(int(c))</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_4：a、b、m都不知道，给出多组输出，让我们恢复初始种子。</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">47513456973995038401745402734715062697203139056061145149400619356555247755807</span><br><span class="line">57250853157569177664354712595458385047274531304709190064872568447414717938749</span><br><span class="line">30083421760501477670128918578491346192479634327952674530130693136467154794135</span><br><span class="line">38739029019071698539301566649413274114468266283936163804522278316663267625091</span><br><span class="line">42506270962409723585330663340839465445484970240895653869393419413017237427900</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>首先，我们要先求出m，才能LCG_3的操作。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c=[47513456973995038401745402734715062697203139056061145149400619356555247755807,</span><br><span class="line">   57250853157569177664354712595458385047274531304709190064872568447414717938749,</span><br><span class="line">   30083421760501477670128918578491346192479634327952674530130693136467154794135,</span><br><span class="line">   38739029019071698539301566649413274114468266283936163804522278316663267625091,</span><br><span class="line">   42506270962409723585330663340839465445484970240895653869393419413017237427900]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line"># print(isPrime(m))       False</span><br><span class="line"></span><br><span class="line">m//=2</span><br><span class="line"># print(isPrime(m))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>这里需要解释一下代码中为什么要进行 m//=2这样的操作？</em></strong></p><p><strong><em>我们虽然得到了m的倍数，通过求解 GCD 也确实能得到m。但是在数据不够多的情况下，我们可能得到的是 k</em>m(不信的话，你可以输出一下 isPrime(m) 发现 m 确实不是素数),这时就需要我们遍历一些小数，手动去除 k 。</strong>*</p><p><strong><em>LCG_5:本题给出信息和LCG_4一样需要我们恢复参数。</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = self.a * (self.seed - self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">57648351648792284446777383544515312078150027665462203747924668509833442797796</span><br><span class="line">90378879763416486117626477831653213918315023665514305359005153448529276829825</span><br><span class="line">21826576702665114807208181233864324586557058567478767825970403161758214940301</span><br><span class="line">47594460970742467761038407996122637655856234121180714918606854365482948918701</span><br><span class="line">11871076497267630136796123094001159466754095580273018347962555675375123133730</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>需要注意的是，这里所给的LCG递归式是</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.seed = self.a * (self.seed - self.b) % self.m</span><br></pre></td></tr></table></figure><p><strong><em>我们只需要把 -ab 看成一个整体，这样我们就可以转化为标准式ax+b 的形式。因为这里我们只需要恢复初始种子m，所以代码和LCG_4没什么区别。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c=[57648351648792284446777383544515312078150027665462203747924668509833442797796,</span><br><span class="line">   90378879763416486117626477831653213918315023665514305359005153448529276829825,</span><br><span class="line">   21826576702665114807208181233864324586557058567478767825970403161758214940301,</span><br><span class="line">   47594460970742467761038407996122637655856234121180714918606854365482948918701,</span><br><span class="line">   11871076497267630136796123094001159466754095580273018347962555675375123133730]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line">print(isPrime(m))   # False m的倍数</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">for i in range(1,100):</span><br><span class="line">    if isPrime(m//i):</span><br><span class="line">        print(i)   # i是4</span><br><span class="line">        m//=i</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_6:同样需要恢复参数</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(255), getPrime(255), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br></pre></td></tr></table></figure><p><strong><em>这里进行了两次加密，我们得到的并不是连续的输出，而是隔位输出，比如是X2,X4,X6,X8,X10</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">self.seed = (self.a * self.seed + self.b) % self.m</span><br></pre></td></tr></table></figure><p>首先要恢复模数 m， <span class="math display">\[\left\{\begin{matrix}X_{2} &amp;=  &amp;(a*X_{1}+b) &amp;mod  &amp;m \\X_{4}&amp; = &amp; (aX_{3}+b) &amp;mod  &amp;m\end{matrix}\right.\Rightarrow (X_{4}-X_{2})=a(X_{3}-X_{1})\textbf{}mod\textbf{ }m\]</span> 依然可以构造消去增量 b构造等比数列，所以我们依然可以用之前的方法求 m 。</p><p>接下来就是求 a， <span class="math display">\[(X_{4}-X_{2})=a(X_{3}-X_{1})\textbf{ }mod\textbf{}m=a((aX_{2}+b)-(aX_{0}+b))\textbf{ }mod\textbf{}m=a^{2}(X_{2}-X_{0})\textbf{ }mod\textbf{ }m\]</span> 那么，这个平方我们该如何处理呢？我们看Xenny师傅 怎么解决。</p><p><img src="/github.io/2023/08/10/LCG%E5%85%A5%E9%97%A8/P6.jpg"></p><p>这个方法我也还是一知半解(AMM算法也不是很明白)。这里，讲一下我的做法。前面已经说过，本题进行了两轮加密，所给输出是间隔的。<span class="math display">\[X_{n+1}=(aX_{n}+b)\textbf{ }mod\textbf{ }m=(a(aX_{n-1}+b)+b)\textbf{}mod\textbf{ }m\]</span> 可以把 a**2 看作 a,把 (a+1)b 看成b，这样就相当于重新构造了一个LCG。</p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c = [25445927935559969212648839062255651208014967526951331344342413906051118248013,</span><br><span class="line">81572970970116732975667604095930675262596098540738447440566868976253289440293,</span><br><span class="line">6956793925625110803779114150160476498676179542815207353218944386232051429289,</span><br><span class="line">88042506866508011592456777776490262927213783361334741921985316105965255450508,</span><br><span class="line">5652832125321707726481846809536180176877263519327268361130605456255558285092]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line"># print(isPrime(m))   # true</span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m             # 把(a+1)*b当成b就可以了</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>最后附上我参考的文章：</p>]]></content>
      
      
      <categories>
          
          <category> 流密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023DASCTF七月挑战赛复现</title>
      <link href="/2023/08/03/2023DASCTF%E4%B8%83%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/08/03/2023DASCTF%E4%B8%83%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="ezdhke">EzDHKE</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from hashlib import sha256</span><br><span class="line">from random import randbytes, getrandbits</span><br><span class="line">from flag import flag</span><br><span class="line">def diffie_hellman(g, p, flag):</span><br><span class="line">    alice = getrandbits(1024)</span><br><span class="line">    bob = getrandbits(1024)</span><br><span class="line">    alice_c = pow(g, alice, p)</span><br><span class="line">    bob_c = pow(g, bob, p)</span><br><span class="line">    print(alice_c , bob_c)</span><br><span class="line">    key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br><span class="line"></span><br><span class="line">    iv = b&quot;dasctfdasctfdasc&quot;</span><br><span class="line"></span><br><span class="line">    aes = AES.new(key, AES.MODE_CBC, iv)  </span><br><span class="line">    </span><br><span class="line">    enc = aes.encrypt(flag)</span><br><span class="line">    print(enc)</span><br><span class="line"></span><br><span class="line">def getp():</span><br><span class="line">    p = int(input(&quot;P = &quot;))</span><br><span class="line">    assert isPrime(p)</span><br><span class="line">    assert p.bit_length() &gt;= 1024 and p.bit_length() &lt;= 2048</span><br><span class="line">    g = 2</span><br><span class="line">    diffie_hellman(g, p, flag)</span><br><span class="line"></span><br><span class="line">getp()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br></pre></td></tr></table></figure><p>获取 Bob 发送的值( bob_c)，将其提高到 Alice 私钥的幂，然后取模p。</p><p>然后将生成的长整数转换为字节并使用 SHA-256进行哈希处理，哈希运算的结果作为字节字符串返回。</p><p>最终结果作为 Alice 和 Bob 的共享密钥。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iv = b&quot;dasctfdasctfdasc&quot;</span><br></pre></td></tr></table></figure><p>AES的CBC模式（分组密码链接模式）设置初始化向量(IV)。</p><p>IV 是一个随机数，用作密文的第一个块。这是必要的，因为 AES是分组密码，而分组密码需要初始化向量来启动加密过程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)  #创建一个新的 AES 对象</span><br></pre></td></tr></table></figure><p>密钥、IV 和明文必须都是类似字节的对象。密钥的长度必须为 16、24 或 32字节(128bit,192bit,256bit)， IV 的长度必须为 16 字节（因为 AES 在 16字节的块上运行），明文的长度必须是 16 字节的倍数。 如果明文不是 16字节的倍数，则必须对其进行填充以达到 16 的倍数的大小。</p><p><strong><em>flag被CBC(分组密码链接模式)进行加密，我们已知初始化向量(IV),目的是求key。</em></strong></p><p><strong><em>而key是被DH加密了的，要求key,还需求出alice。</em></strong></p><p><strong><em>get()函数要求我们传入一个1024bit-2048bit的素数p,我们不防传入一个光滑素数，能很快求解</em></strong> <span class="math display">\[Alice_c\equiv g^{alice}\textbf{ }mod\textbf{ }p\]</span> wp:</p><p>生成光滑素数p</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from random import choice</span><br><span class="line">from Crypto.Util.number import isPrime</span><br><span class="line">def myPrime(bits):</span><br><span class="line">    while True:</span><br><span class="line">        n = 2</span><br><span class="line">        while n.bit_length() &lt; bits:</span><br><span class="line">            n *= choice(primes)</span><br><span class="line">        if isPrime(n + 1):</span><br><span class="line">            return n + 1</span><br><span class="line">p = myPrime(1024)</span><br><span class="line">print(p)</span><br><span class="line">#189748605665158082111275872557704333522039726199999895031706315085902660337411854647983122666062556936534670800160523701824801162274106958140146326402455411620555437280926462736018015567166363230091558715628717720419196163767507352475201252315824517036725244214039625995753473481520129898146252693266565762094927</span><br></pre></td></tr></table></figure><p>求解alice</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 环境：sage</span><br><span class="line"># Baby-step Giant-step法</span><br><span class="line">def babystep_giantstep(g, y, p, q=None):</span><br><span class="line">    if q is None:</span><br><span class="line">        q = p - 1</span><br><span class="line">    m = int(q**0.5 + 0.5)</span><br><span class="line">    # Baby step</span><br><span class="line">    table = &#123;&#125;</span><br><span class="line">    gr = 1  # g^r</span><br><span class="line">    for r in range(m):</span><br><span class="line">        table[gr] = r</span><br><span class="line">        gr = (gr * g) % p</span><br><span class="line">    # Giant step</span><br><span class="line">    try:</span><br><span class="line">        gm = pow(g, -m, p)  # gm = g^&#123;-m&#125;</span><br><span class="line">    except:</span><br><span class="line">        return None</span><br><span class="line">    ygqm = y                # ygqm = y * g^&#123;-qm&#125;</span><br><span class="line">    for q in range(m):</span><br><span class="line">        if ygqm in table:</span><br><span class="line">            return q * m + table[ygqm]</span><br><span class="line">        ygqm = (ygqm * gm) % p</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"># Pohlig–Hellman法</span><br><span class="line">def pohlig_hellman_DLP(g, y, p):</span><br><span class="line">    crt_moduli = []</span><br><span class="line">    crt_remain = []</span><br><span class="line">    for q, _ in factor(p-1):</span><br><span class="line">        x = babystep_giantstep(pow(g,(p-1)//q,p), pow(y,(p-1)//q,p), p, q)</span><br><span class="line">        if (x is None) or (x &lt;= 1):</span><br><span class="line">            continue</span><br><span class="line">        crt_moduli.append(q)</span><br><span class="line">        crt_remain.append(x)</span><br><span class="line">    x = crt(crt_remain, crt_moduli)</span><br><span class="line">    return x</span><br><span class="line">    </span><br><span class="line">p = 189748605665158082111275872557704333522039726199999895031706315085902660337411854647983122666062556936534670800160523701824801162274106958140146326402455411620555437280926462736018015567166363230091558715628717720419196163767507352475201252315824517036725244214039625995753473481520129898146252693266565762094927</span><br><span class="line">g=2</span><br><span class="line">y=126335148728121839165214578712616714896068088431242768032099119311672927960066757778886759581732563397664623281291468786455806669506289945000832687256947547715890013891156717873951970575686566623998313033814629227260784874473674493141956695555624444324423123550043331270766000934442345084521173496612684244521817 </span><br><span class="line"></span><br><span class="line">x = pohlig_hellman_DLP(g, y, p)</span><br><span class="line">print(x)</span><br><span class="line">print(pow(g, x, p) == y)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;19725268140486219931273670184627509421886594371218668473170713602614775174554822553913723749247515418643589204928857895458812995617382397101146613792597234401181086237828962337082170640415285598027205377319087246590523359362089919920879645846905409986181936892939004568920963678760604527317649686645891069878</span><br><span class="line">True&#x27;&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后求key,解flag</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alice=19725268140486219931273670184627509421886594371218668473170713602614775174554822553913723749247515418643589204928857895458812995617382397101146613792597234401181086237828962337082170640415285598027205377319087246590523359362089919920879645846905409986181936892939004568920963678760604527317649686645891069878</span><br><span class="line">bob_c=82024715586746697978530132111368994011716076980502454618150572158919032873444387902613386183552926303651710370065737129756192440674145837908673206529875835887003844314561287987895409315122184287323905278866402929779666428512421254584747210553034542812693842282458559568445136236463734031158504503149333460169444</span><br><span class="line"></span><br><span class="line">enc=b&quot;Ky\x91\xf5\n\xe4\x03&#x27;\xa8\xf2c\xd6\x95m\xa7\x8bj\xfb\x03nU\x0e\x95\xd7(\xb9\xa4\xcf\xcbg\xd6gR\xe1m\xef7Q\x151h\x0c\xc6x\xb1\xfcZ^&quot;</span><br><span class="line"></span><br><span class="line">key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br><span class="line">iv = b&quot;dasctfdasctfdasc&quot;</span><br><span class="line"></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">flag = aes.decrypt(enc)</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line"># b&#x27;DASCTF&#123;1c65a8d9-ca95-4217-a98c-b119c6f313b1&#125;</span><br></pre></td></tr></table></figure><h2 id="ezrsa">ezRSA</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import secret, flag</span><br><span class="line">def encrypt(m):</span><br><span class="line">    return pow(m, e, n)</span><br><span class="line">assert flag == b&quot;dasctf&#123;&quot; + secret + b&quot;&#125;&quot;</span><br><span class="line">e = 11</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p * q</span><br><span class="line">P = getPrime(512)</span><br><span class="line">Q = getPrime(512)</span><br><span class="line">N = P * Q</span><br><span class="line">gift = P ^ (Q &gt;&gt; 16)</span><br><span class="line">print(N, gift, pow(n, e, N))</span><br><span class="line">print(encrypt(bytes_to_long(secret)),</span><br><span class="line">    encrypt(bytes_to_long(flag)))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line">a=1418376318449536765352288414795105463017701595274559335835409895217396556048810421351756309867602851654191c1=5855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009 </span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>已知P高16位，可以根据P=gift^Q恢复P,所以要先根据Q=N//P恢复Q。</p><p>wp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line"></span><br><span class="line">pp=bin(gift)[2:18]  # 截取p的高16位</span><br><span class="line">#print(pp)</span><br><span class="line"></span><br><span class="line">gift=bin(gift)[2:][16:]  # 截取gift的剩余位</span><br><span class="line">#print(gift)</span><br><span class="line">k = 512-16</span><br><span class="line"></span><br><span class="line"># 恢复p</span><br><span class="line">x=4</span><br><span class="line">for i in range(k//x):</span><br><span class="line">    PP = int(pp + &#x27;0&#x27;*k,2)  # 已知高位</span><br><span class="line">    #print(PP)</span><br><span class="line">    QQ=bin(N//PP)[2:][i*x:(i+1)*x] # 计算Q高位</span><br><span class="line">    #print(QQ)</span><br><span class="line">    gg = gift[i*x:(i+1)*x]</span><br><span class="line">    #print(gg)</span><br><span class="line">    pb = bin(int(QQ, 2) ^ int(gg, 2))[2:].zfill(x)</span><br><span class="line">    #print(pb)</span><br><span class="line">    pp+=pb</span><br><span class="line">    k-=x</span><br><span class="line">px=int(pp,2)</span><br><span class="line">if N//px:</span><br><span class="line">    p=N//px</span><br><span class="line">    print(p)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line"></span><br><span class="line">#pp=bin(gift)[2:][:16]  # 截取gift的前16位</span><br><span class="line">pp=bin(gift)[2:18]</span><br><span class="line"># print(bin(gift))</span><br><span class="line"># print(pp)</span><br><span class="line">b=512-16</span><br><span class="line"></span><br><span class="line">gift=bin(gift)[2:][16:] # 截取gift剩余的位数</span><br><span class="line">#print(gift)</span><br><span class="line"></span><br><span class="line">x=5</span><br><span class="line">for i in range((512-16)//x):</span><br><span class="line">    PP=int(pp+&#x27;0&#x27;*b,2)  #已知高位</span><br><span class="line">    #print(PP)</span><br><span class="line">    Qb=bin(N//PP)[2:][i*x:x*i+x]  #算出Q的高位,取5</span><br><span class="line">    #print(Qb)</span><br><span class="line">    gb=gift[i*x:i*x+x]</span><br><span class="line">    #print(gb)</span><br><span class="line">    pb=bin(int(gb,2)^int(Qb,2))[2:].zfill(x)</span><br><span class="line">    #print(pb)</span><br><span class="line">    pp+=pb</span><br><span class="line">    #print(pp)</span><br><span class="line">    b-=x</span><br><span class="line">for i in range(3): #还差1位</span><br><span class="line">    px = int(pp+bin(i)[2:],2)</span><br><span class="line">    if N//px:</span><br><span class="line">        p=N//px</span><br><span class="line">        print(p)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>这里解释一下，为什么一小段一小段的恢复。</em></strong></p><p><strong><em>因为我们是知道P的一部分高位，Q=N//P也只能求出Q的一部分高位。为了精准，我们可以把间隔选短一点儿。</em></strong></p><p><strong><em>上面脚本中我所选的间隔分别是4和5</em></strong></p><p>求解n</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">p = 9366986529377069783394625848920106951220134111548343265311677163992169555436421569730703291128771472885865288798344038000984911921843088200997725324682297</span><br><span class="line">q=N//p</span><br><span class="line"></span><br><span class="line">e=11</span><br><span class="line">phi=(p-1)*(q-1)</span><br><span class="line">d=invert(e,phi)</span><br><span class="line">c1=14183763184495367653522884147951054630177015952745593358354098952173965560488104213517563098676028516541915855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span><br><span class="line"></span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line"></span><br><span class="line">n=pow(c1,d,N)  # n可能比N大</span><br><span class="line"># print(n.bit_length()) 1020bit</span><br><span class="line">n = n + N</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><p><strong><em>因为n=pow(c1,d,N)求出来的n只有1020bit,而理论上n应该有1024bit,所以手动加上N.</em></strong></p><p>求解secret</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c2 = x ^ 11 </span><br><span class="line">c3 = (bytes_to_long(b&#x27;dasctf&#123;&#x27; + b&#x27;\00&#x27; * i + b&#x27;&#125;&#x27; ) * 256 ** (i + 1) + 256 * x) ^ 11</span><br><span class="line">(其中x = secret , i = len(secret))</span><br></pre></td></tr></table></figure><p><strong><em>典型的相关信息攻击</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 83410392685813224685786027640778560521035854332627839979281105731457044069408118952629284089869335506983096270269822559619624906180108256504440296527471536363057103101146262613593336072556587341466840510200003498265457285439149541137127199088938421905041387224795918868443175561632999479925818053898100117419</span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line">def GCD(a,b):      # 求解多项式的最大公因子</span><br><span class="line">    if b == 0:</span><br><span class="line">        return a.monic()</span><br><span class="line">    else:</span><br><span class="line">        return GCD(b,a % b)</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">for i in range(50):</span><br><span class="line">    f1 = x ^ 11 - c2</span><br><span class="line">    f2 = (bytes_to_long(b&#x27;dasctf&#123;&#x27; + b&#x27;\x00&#x27; * i + b&#x27;&#125;&#x27;) + 256 * x) ^ 11 - c3</span><br><span class="line">    if GCD(f1,f2)[0] != 1:</span><br><span class="line">        print(b&#x27;dasctf&#123;&#x27; + long_to_bytes(int(n - GCD(f1,f2)[0])) + b&#x27;&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># dasctf&#123;C0pper_Sm1th_Mak3s_T1ng5_Bet4er&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def GCD(a,b):      # 求解多项式的最大公因子</span><br><span class="line">    if b == 0:</span><br><span class="line">        return a.monic()</span><br><span class="line">    else:</span><br><span class="line">        return GCD(b,a % b)</span><br></pre></td></tr></table></figure><p><strong><em>使用辗转相除法求多项式的最大公因子</em></strong><strong><em>在代数中，一个多项式的首项系数通常被称为该多项式的引导系数（leadingcoefficient），而将多项式变成首项系数为1的形式被称为将多项式化为首一形式（monicform）</em></strong><strong><em>调用函数g1.monic()将g1转换为首一多项式（monicpolynomial），并返回该多项式。</em></strong><strong><em>使用g.monic()[0]，则会返回g(x)除以引导系数后得到的多项式的常数项</em></strong><strong><em>比如：g.monic() = x + 32412345</em></strong><strong><em>那么：g.monic()[0] = 32412345</em></strong></p><h2 id="ezalgebra">ezAlgebra</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import getPrime, bytes_to_long</span><br><span class="line"></span><br><span class="line">def YiJiuJiuQiNian(Wo, Xue, Hui, Le, Kai):</span><br><span class="line">    Qi = 1997</span><br><span class="line">    Che = Wo+Hui if Le==1 else Wo*Hui</span><br><span class="line">    while(Xue):</span><br><span class="line">        Qi += (pow(Che, Xue, Kai)) % Kai</span><br><span class="line">        Xue -= 1</span><br><span class="line">    return Qi</span><br><span class="line">l = 512</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(l)</span><br><span class="line">q = getPrime(l//2)</span><br><span class="line">r = getPrime(l//2)</span><br><span class="line">n = p * q * r</span><br><span class="line">t = getrandbits(32)</span><br><span class="line">c1 = YiJiuJiuQiNian(t, 4, p, 1, n)</span><br><span class="line">c2 = YiJiuJiuQiNian(m, 19, t, 0, q)</span><br><span class="line">c3 = YiJiuJiuQiNian(m, 19, t, 1, q)</span><br><span class="line">print(f&quot;n = &#123;n&#125;&quot;)</span><br><span class="line">print(f&quot;c1 = &#123;c1&#125;&quot;)</span><br><span class="line">print(f&quot;c2 = &#123;c2&#125;&quot;)</span><br><span class="line">print(f&quot;c3 = &#123;c3&#125;&quot;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 119156144845956004769507478085325079414190248780654060840257869477965140304727088685316579445017214576182010373548273474121727778923582544853293534996805340795355149795694121455249972628980952137874014208209750135683003125079012121116063371902985706907482988687895813788980275896804461285403779036508897592103</span><br><span class="line">c1 = 185012145382155564763088060801282407144264652101028110644849089283749320447842262397065972319766119386744305208284231153853897076876529326779092899879401876069911627013491974285327376378421323298147156687497709488102574369005495618201253946225697404932436143348932178069698091761601958275626264379615139864425</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>简单化简一下题目信息： <span class="math display">\[n = p*q*r\]</span></p><p><span class="math display">\[c1 -1997= che^{4}+che^{3}+che^{2}+che\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[c_{2}-1997=(t*m)^{19}+(t*m)^{18}+...+(t*m)^{2}+(t*m)\textbf{}mod\textbf{ }q\]</span></p><p><span class="math display">\[c_{3}-1997=(t+m)^{19}+(t+m)^{18}+...+(t+m)^{2}+(t+m)\textbf{}mod\textbf{ }q\]</span></p><p>根据模腐蚀性质， <span class="math display">\[c1-1997=t^{4}+t^{3}+t^{2}+t\textbf{ }mod\textbf{ }p\Rightarrowk*p=c_{1}-(t^{4}+t^{3}+t^{2}+t+1997)\]</span> 就相当于已知p高位，运用copper求解t</p><p>之后用gcd(k*p,n)求p</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import isPrime, long_to_bytes</span><br><span class="line">n = 119156144845956004769507478085325079414190248780654060840257869477965140304727088685316579445017214576182010373548273474121727778923582544853293534996805340795355149795694121455249972628980952137874014208209750135683003125079012121116063371902985706907482988687895813788980275896804461285403779036508897592103</span><br><span class="line">c1 = 185012145382155564763088060801282407144264652101028110644849089283749320447842262397065972319766119386744305208284231153853897076876529326779092899879401876069911627013491974285327376378421323298147156687497709488102574369005495618201253946225697404932436143348932178069698091761601958275626264379615139864425</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">#xue1=4 ,che1=t+p,kai=n</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x^4+x^3+x^2+x-c1+1997</span><br><span class="line">t = f.small_roots(X=2^32, beta=0.4)[0]</span><br><span class="line"># print(t)</span><br><span class="line"></span><br><span class="line">t=2915836867</span><br><span class="line">kp=t**4+t**3+t**2+t-c1+1997</span><br><span class="line">p = gmpy2.gcd(kp,n)</span><br><span class="line"># print(p)</span><br><span class="line"># print(p.bit_length())</span><br><span class="line">#print(isPrime(p))</span><br><span class="line">N=n//p</span><br></pre></td></tr></table></figure><p>两个模q下的19次同解多项式，利用groebner_basis求出q</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xue2=19 che=m*t kai=q</span><br><span class="line">Qi-1997=che^19+che^18 +....+che</span><br><span class="line"></span><br><span class="line">xue3=19 che=(m+t) kai=q</span><br><span class="line">Qi-1997=che^19+che^18+....+che</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">P.&lt;x,y&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f1=1997-c2</span><br><span class="line">f2=1997-c3</span><br><span class="line">for i in range(1,20):</span><br><span class="line">    f1+=(x*t)^i</span><br><span class="line">    f2+=(x+t)^i</span><br><span class="line">G=[f1,f2]</span><br><span class="line">B=Ideal(G).groebner_basis() #Gröbner 基是多项式环中理想的一种特殊生成集，用于许多运算，例如求解多项式方程组。</span><br><span class="line"># print(B)</span><br><span class="line"></span><br><span class="line">q=87038069032840052005520908272237788908169043580221040711149494083975743478969</span><br><span class="line">r = n//(p*q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q=87038069032840052005520908272237788908169043580221040711149494083975743478969</span><br><span class="line">x=56985796272753226120469211992443340429346162287195965942430959147227534853120</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">for i in range(2**25):</span><br><span class="line">    flag=long_to_bytes(x+i*q)</span><br><span class="line">    if b&#x27;dasctf&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
