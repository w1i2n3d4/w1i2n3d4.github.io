<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>哈希函数</title>
      <link href="/2023/09/21/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2023/09/21/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="定义">定义</h1><p><span class="math inline">\(Hash\)</span>,一般译作散列、哈希，就是能把<strong>任意长度的输入</strong>（又做预映射）通过<strong>散列算法</strong>，变换成<strong>固定长度的输出</strong>，这个输出就是散列值。</p><p>散列值通常是数字和字母的组合。</p><h1 id="性质">性质</h1><p>1、<strong>不可逆性</strong>。已知哈希函数<span class="math inline">\(F\)</span>和<span class="math inline">\(x\)</span>哈希值,无法逆向求出<span class="math inline">\(x\)</span>.</p><p>2、对于特定的哈希函数，只要<strong>输入不变</strong>，那么<strong>散列值</strong>也肯定是<strong>唯一不变</strong>的.</p><p>3、哈希函数产生的映射应当保持均匀，即<strong>不要使得映射结果堆积在小区间的某一区域</strong>.</p><p>4、敏感性。哪怕输入数据只改变<span class="math inline">\(1bit\)</span>,得到的哈希值也大不相同.</p><p>5、抗碰撞性。理想<span class="math inline">\(Hash\)</span>函数是<strong>无碰撞</strong>的，但实际很难做到这一点。有两种抗碰撞性：弱抗碰撞性、强抗碰撞性.</p><h1 id="典型的哈希函数">典型的哈希函数</h1><p>常见的<span class="math inline">\(Hash\)</span>算法有<span class="math inline">\(MD5\)</span>和<span class="math inline">\(SHA\)</span>系列，目前<span class="math inline">\(MD5\)</span>和<span class="math inline">\(SHA1\)</span>已被破解，一般推荐使用<span class="math inline">\(SHA2-256\)</span>算法.</p><h2 id="md5">MD5</h2><p>输入<strong>任意长度</strong>的信息，以<strong><span class="math inline">\(512bit\)</span>输入数据块</strong>为单位，输出为<span class="math inline">\(128bit\)</span>的信息（数字指纹）。</p><h3 id="实现过程">实现过程</h3><p>1、<strong>补位</strong>。使输入信息的长度变为<span class="math inline">\((N*512+448)bit\)</span>，补位内容为<span class="math inline">\(100...0\)</span></p><p>​ 那为什么不补为<span class="math inline">\(512bit\)</span>的整数倍呢？其实<strong>剩余<span class="math inline">\(64bit\)</span>是原始信息的长度</strong>。也就是说，<strong>补位最终结果是<span class="math inline">\(N*512bit\)</span>的</strong>.</p><p>​需要注意的是，<strong>补位操作必须进行</strong>，即使最初信息的长度已经满足<span class="math inline">\((N*512+448)bit\)</span>,但还是要加上<span class="math inline">\(512bit\)</span>,然后再补<span class="math inline">\(64bit\)</span>记录原始</p><p>​ 信息长度. 如下图：</p><p><img src="/2023/09/21/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/0.jpg"></p><p>2、<strong>分割</strong>。把结果分为n组，每一组长度为<span class="math inline">\(512bit\)</span>.</p><p>3、<strong>计算</strong>。</p><p>$$准备四个<strong>标准幻数</strong>，每一个数4个字节，总的16字节。其实四个幻数的值定义也很直接，就是<strong>32个16进制字面值依次排列</strong>。</p><p>分别是：</p><p><span class="math inline">\(A = 01234567\)</span> <span class="math inline">\(B = 89ABCDEF\)</span> <span class="math inline">\(C = FEDCBA98\)</span> <span class="math inline">\(D = 76543210\)</span></p><p>那么，这四个幻数是用来做什么的呢？</p><p>其实不难发现，<strong>四个幻数的长度和<span class="math inline">\(MD5\)</span>散列值的长度都是<span class="math inline">\(128bit\)</span>,四个幻数就是用来做循环初始计算值的</strong>。</p><p>最终<span class="math inline">\(MD5\)</span>散列值就是<strong>四个标准幻数经过多轮哈希运算的结果</strong>。</p><p>需要注意，在程序中，幻数是用<strong>小端字节</strong>表示的，即</p><p><span class="math inline">\(A = 0x67452301\)</span> <span class="math inline">\(B = 0xEFCDAB89\)</span> <span class="math inline">\(C = 0x98BACDFE\)</span> <span class="math inline">\(D = 0x10325476\)</span></p><p>准备工作完成，就可以开始计算了。</p><p>$$ 数据被分为n个<span class="math inline">\(512bit\)</span>，也就是n个64字节，再把每一个64字节分成16份，每份四个字节。</p><p><img src="/2023/09/21/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/7.jpg"></p><p>$$ <strong>定义四个函数</strong>，分别是 <span class="math display">\[FF(A,B,C,D,X,S,AC)\]</span></p><p><span class="math display">\[GG(A,B,C,D,X,S,AC)\]</span></p><p><span class="math display">\[HH(A,B,C,D,X,S,AC)\]</span></p><p><span class="math display">\[II(A,B,C,D,X,S,AC)\]</span></p><p>前四个参数分别对应四个标准幻数，第五个参数是每一小份的四个字节数据，第六个和第七个参数都是一些<strong>固定常数</strong>，执行一些逻辑与、或、非、异或运算，加法运算和移位运算。</p><p>$$将四个标准幻数换着顺序作为前四个参数输入，并将16份4字节数据依次作为第五个参数代入，经过这么一轮运算，四个标准幻数的值就变了。</p><p><img src="/2023/09/21/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/1.jpg"></p><p>$$将四个标准幻数与一开始的值相加，得到更新后的四个幻数结果。这样就处理完了一个64字节的数据。</p><p>$$四个更新后的标准幻数作为第二轮的四个标准幻数输入，并且载入第二个64字节数据中进行运算。</p><p>$$重复上述过程，直到n个64字节数据全部计算完成，最终得到的四个标准幻数用十六进制显示出来就是最终<span class="math inline">\(MD5\)</span>的散列值。</p><h2 id="sha1secure-hash-algorithm">SHA1(Secure Hash Algorithm)</h2><p>对于长度小于<span class="math inline">\(2^{64}bit\)</span>的消息，将输入流按照每块<span class="math inline">\(512b(64B)\)</span>进行分块，并产生<span class="math inline">\(160b(20B)\)</span>的信息摘要。</p><p><img src="/2023/09/21/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/2.jpg"></p><h3 id="实现过程-1">实现过程</h3><p>大致框图：</p><p><img src="/2023/09/21/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/3.png"></p><p>1、补位。（与<span class="math inline">\(MD5\)</span>补位是一样的）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一位：补1</span><br><span class="line">其余位：补0</span><br><span class="line">直至满足 L mod 512 = 448</span><br><span class="line"></span><br><span class="line">512 - 448 = 64</span><br><span class="line">剩余64bit是初始消息的长度</span><br></pre></td></tr></table></figure><p>eg：</p><p><img src="/2023/09/21/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/4.jpg"></p><p>2、将信息分为<span class="math inline">\(n\)</span>个<span class="math inline">\(512bit\)</span>。</p><p>3、每个<span class="math inline">\(512b\)</span>的运算。</p><p>$ $ 把<span class="math inline">\(512b\)</span>分为<span class="math inline">\(26\)</span>份<span class="math inline">\(32b\)</span>,将<span class="math inline">\(16\)</span>份<strong>扩充</strong>到<span class="math inline">\(80\)</span>份.</p><p><img src="/2023/09/21/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/5.jpg"></p><p>那么，如何扩充呢？ <span class="math display">\[W_{t}=\left\{\begin{matrix}M_{t}^{i}\textbf{ }\textbf{ }0\leqslant t\leqslant15\\ROTL^{1}(W_{t-3}\bigoplus W_{t-8}\bigoplus W_{t-14}\bigoplusW_{t-16})\textbf{ }\textbf{ }16\leqslant t\leqslant79\end{matrix}\right.\]</span> <span class="math inline">\(ROTL^{1}\)</span>表示左移一位.</p><p>eg: <span class="math display">\[W_{16}=(W_{13}\bigoplus W_{8}\bigoplus W_{2}\bigoplus W_{0})&lt;&lt;1\]</span> <span class="math inline">\(\bullet\)</span> 设置<span class="math inline">\(5\)</span>个初始量， <span class="math display">\[H_{0}^{(0)}=67452301\]</span></p><p><span class="math display">\[H_{1}^{(0)}=efcdab89\]</span></p><p><span class="math display">\[H_{2}^{(0)}=98badcfe\]</span></p><p><span class="math display">\[H_{3}^{(0)}=10325476\]</span></p><p><span class="math display">\[H_{4}^{(0)}=c3d2e1f0\]</span></p><p>$$ 将初始量的值分别赋给<span class="math inline">\(a,b,c,d,e\)</span><span class="math display">\[a=H_{0}^{(0)}\]</span></p><p><span class="math display">\[b=H_{1}^{(0)}\]</span></p><p><span class="math display">\[c= H_{2}^{(0)}\]</span></p><p><span class="math display">\[d = H_{3}^{(0)}\]</span></p><p><span class="math display">\[e = H_{4}^{(0)}\]</span></p><p><span class="math inline">\(\bullet\)</span> 进行<span class="math inline">\(80\)</span>轮运算.</p><p>​ <span class="math inline">\(for \textbf{ }t = 0 \textbf{ }to\textbf{} 79:\)</span> <span class="math display">\[\left \{  \right.\]</span> ​ <span class="math inline">\(T =ROTL^{5}(a)+f_{t}(b,c,d)+e+K_{t}+W_{t}\)</span></p><p>​ <span class="math inline">\(e=d\)</span></p><p>​ <span class="math inline">\(d=c\)</span></p><p>​ <span class="math inline">\(c=ROLT^{30}(b)\)</span></p><p>​ <span class="math inline">\(b = a\)</span></p><p>​ <span class="math inline">\(a=T\)</span> <span class="math display">\[\left.  \right \}\]</span> 其中， <span class="math display">\[K_{t}=\left\{\begin{matrix}5a827999\textbf{ }\textbf{ }0\leqslant t\leqslant19\\6ed9eba1\textbf{ }\textbf{ }20\leqslant t\leqslant39\\8f1bbcdc\textbf{ }\textbf{ }40\leqslant t\leqslant59\\ca62c1d6\textbf{ }\textbf{ }60\leqslant t\leqslant79\end{matrix}\right.\]</span></p><p><span class="math display">\[f_{t}(x,y,z)=\left\{\begin{matrix}Ch(x,y,z)=(x\wedge y)\bigoplus(x\wedge z),\textbf{ }\textbf{ }0\leqslantt\leqslant19\\Parity(x,y,z)=x\bigoplus y\bigoplus z,\textbf{ }\textbf{ }20\leqslantt\leqslant39\\Maj(x,y,z)=(x\wedge y)\bigoplus(x\wedge z)\bigoplus(y\wedge z),\textbf{}\textbf{ }40\leqslant t\leqslant59\\Parity(x,y,z)=x\bigoplus y\bigoplus z,\textbf{ }\textbf{ }60\leqslantt\leqslant79\end{matrix}\right.\]</span></p><p><span class="math inline">\(\bullet\)</span> 将<span class="math inline">\(80\)</span>轮运算之后得到的<span class="math inline">\(a,b,c,d,e\)</span>分别与初始量相加.</p><p><span class="math inline">\(\bullet\)</span>将上述结果作为第二个<span class="math inline">\(512b\)</span>的初始量进行循环计算。</p><p>$$ 重复上述过程，直到<span class="math inline">\(n\)</span>个<span class="math inline">\(512b\)</span>数据全部计算完成，最终得到的<span class="math inline">\(a,b,c,d,e\)</span>就是<span class="math inline">\(SHA1\)</span>的最终结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔三</title>
      <link href="/2023/09/15/%E9%9A%8F%E7%AC%94%E4%B8%89/"/>
      <url>/2023/09/15/%E9%9A%8F%E7%AC%94%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="task2">task2</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import FLAG</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(FLAG)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getpq(nbit):</span><br><span class="line">    p = getPrime(nbit)</span><br><span class="line">    q = getPrime(nbit)</span><br><span class="line">    if p &gt; q:</span><br><span class="line">        return p, q</span><br><span class="line">    else:</span><br><span class="line">        return q, p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p, q = getpq(512)</span><br><span class="line">P = (p - q) &amp; ((1 &lt;&lt; 130) - 1)</span><br><span class="line">n = p * q</span><br><span class="line"></span><br><span class="line">leak_p = p &gt;&gt; 256</span><br><span class="line"></span><br><span class="line">c = pow((1 + P * n), m, n ** 3)</span><br><span class="line"></span><br><span class="line">print(&#x27;n =&#x27;, n)</span><br><span class="line">print(&#x27;leak_p =&#x27;, leak_p)</span><br><span class="line">print(&quot;c =&quot;, c)</span><br><span class="line"></span><br><span class="line"># n = 135133139540786818977969958456509467902948924003478556140490841984247464940261764739984274397650928404945721248284577232814352745333641188749824519153271662051302477973525156608141358709265683759057060630360909926255299541198485901065352661702656282587105799982740927802530997159098015074633017964344230291287</span><br><span class="line"># leak_p = 115314121469787984258489158421056136177545051135641551928888818017665807264468</span><br><span class="line"># c = 1836794759996264077871820946090708779709415760553736759453665641907562256633157424959089180650539327925671892742819931875681606982615287882656254828326465758462357812873839261469783652663796071814218493268788421243190729887313099383264588659922912876424206670310928514588754069909128149471326084547056385690037197908766053620702238356084124023146075698878494434053246157524775269473152458661801907641122308756667762880284617915774590075511686821816948174618196839335059944389423693187930672934293905608970421003536691336581450927887931599275461176935079227494931457562345640133982771901848553204154760760399724074615092290799119053032875792219794072963200108352944441876206386518960615891547166767499506114294860833404421893612197040731184031783165365621722947731966143226777081983415797778111715332055871302609049501876860012070502369090417942239749695034267695710324328867728296996779</span><br></pre></td></tr></table></figure><p>先分析一下题目，已知<span class="math inline">\(p\)</span>高256位，而p.bit_length()==512,所以不能直接<span class="math inline">\(copper\)</span>.</p><p>先爆破8位，然后再<span class="math inline">\(copper\)</span>解<span class="math inline">\(p\)</span>.</p><p><span class="math inline">\(p\)</span>知道，那么<span class="math inline">\(P\)</span>也就知道了.</p><p>最后解<span class="math inline">\(m\)</span>以为是<span class="math inline">\(DSA\)</span>问题，但没有求解出来，转换思路，用<strong>二项式定理</strong>展开<span class="math inline">\((1+P*n)^{m}\textbf{ }mod\textbf{ }n^{3}\)</span><span class="math display">\[(1+P*n)^{m}\textbf{ }mod\textbf{}n^{3}=C_{m}^{0}*1+C_{m}^{1}*1^{m-1}*(P*n)+C_{m}^{2}*1^{m-2}*(P*n)^{2}+...+(P*n)^{m}\textbf{}mod\textbf{ }n^{3}\]</span></p><p><span class="math display">\[\Rightarrow1+m*P*n+\frac{m(m-1)}{2}*P^{2}*n^{2}=c\textbf{ }mod\textbf{}n^{3}\]</span></p><p><span class="math display">\[\Rightarrow m*P+\frac{m(m-1)}{2}*P^{2}*n=(c-1)//n\textbf{ }mod\textbf{}n^{2}\]</span></p><p><span class="math display">\[\Rightarrow m*P+\frac{m(m-1)}{2}*P^{2}*n-(c-1)//n=0\textbf{ }mod\textbf{}n^{2}\]</span></p><p>解方程求<span class="math inline">\(m\)</span>.</p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line">n = 135133139540786818977969958456509467902948924003478556140490841984247464940261764739984274397650928404945721248284577232814352745333641188749824519153271662051302477973525156608141358709265683759057060630360909926255299541198485901065352661702656282587105799982740927802530997159098015074633017964344230291287</span><br><span class="line">leaker_p = 115314121469787984258489158421056136177545051135641551928888818017665807264468</span><br><span class="line">c = 1836794759996264077871820946090708779709415760553736759453665641907562256633157424959089180650539327925671892742819931875681606982615287882656254828326465758462357812873839261469783652663796071814218493268788421243190729887313099383264588659922912876424206670310928514588754069909128149471326084547056385690037197908766053620702238356084124023146075698878494434053246157524775269473152458661801907641122308756667762880284617915774590075511686821816948174618196839335059944389423693187930672934293905608970421003536691336581450927887931599275461176935079227494931457562345640133982771901848553204154760760399724074615092290799119053032875792219794072963200108352944441876206386518960615891547166767499506114294860833404421893612197040731184031783165365621722947731966143226777081983415797778111715332055871302609049501876860012070502369090417942239749695034267695710324328867728296996779</span><br><span class="line"></span><br><span class="line">pbits = 512</span><br><span class="line">print(n.nbits())</span><br><span class="line">p_high = leaker_p</span><br><span class="line">print(p_high)</span><br><span class="line">for i in range(2**8):</span><br><span class="line">     p4 = p_high&lt;&lt;8    #这里需要先爆破8位，使得知道264位以后再恢复p</span><br><span class="line">     p4 = p4 + i</span><br><span class="line">     kbits = pbits - p4.nbits()</span><br><span class="line">     p4 = p4 &lt;&lt; kbits</span><br><span class="line">     R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">     f = x + p4</span><br><span class="line">     x1 = f.small_roots(X=2^kbits, beta=0.4, epsilon=0.01)</span><br><span class="line">     if x1:</span><br><span class="line">         p = p4 + int(x1[0])</span><br><span class="line">         if p.nbits() == 512:</span><br><span class="line">                print(p)</span><br><span class="line">                q = n // p</span><br><span class="line">                break</span><br><span class="line">print(&#x27;over&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q = n//p</span><br><span class="line">P = (p-q)&amp;((1&lt;&lt;130)-1)</span><br><span class="line">print(gmpy2.gcd(c-1,n)==n)</span><br><span class="line"></span><br><span class="line">c1 = (c-1)//n</span><br><span class="line">var(&#x27;m&#x27;)</span><br><span class="line">f1 = m*P+(m*(m-1)/2)*P^2*n == c1 </span><br><span class="line">x = solve(f1,m)</span><br><span class="line">print(x)</span><br><span class="line">m = 569500674440382718231575264852597803870681506457438686903594776739090860497616821068120838321533</span><br><span class="line">print(long_to_bytes(m))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="task1">task1</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import flag, e1, e2</span><br><span class="line"></span><br><span class="line"># 生成素数</span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = libnum.generate_prime(1024)</span><br><span class="line">ec1 = pow(bytes_to_long(str(e1).ljust(20, &quot;D&quot;).encode()), 3, p * q)</span><br><span class="line">ec2 = pow(bytes_to_long(str(e2).ljust(20, &quot;A&quot;).encode()), 5, p * q)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">n = p * q</span><br><span class="line">c1 = pow(m, e1, n)</span><br><span class="line">c2 = pow(m, e2, n)</span><br><span class="line"></span><br><span class="line">print(&quot;n1=&quot;, n)</span><br><span class="line">print(&quot;ec1=&quot;, ec1)</span><br><span class="line">print(&quot;c1=&quot;, c1)</span><br><span class="line">print(&quot;n2=&quot;, n)</span><br><span class="line">print(&quot;ec2=&quot;, ec2)</span><br><span class="line">print(&quot;c2=&quot;, c2)</span><br><span class="line"></span><br><span class="line"># n1= 27929259512873502442719286790227037320417984116570178470037376373267390909685621247157535458203218619293705428397911754453556082799420494496904478215709219317542924547049229150153308059698341011305505985823374280465467094476511869541135508518055946815227085548571701115773386101962695795789178321155174729047033298389886321980592410739667139376075568555729949442873964097042006391886635957242436522435588904492484342259494858627609438654632887244523845583473711604632109405043439047289868784236481926074763997559971182741918345193506253460323445846136663027639802131457594564405906763806426256107923417802076262573737</span><br><span class="line"># ec1= 24979839185643431898760549059477070141596292955202172081572583839065034831779499992829742773873064296311713734486020739853343887094398935731264</span><br><span class="line"># c1= 17695186679431856780362905635257355413310120106982055323913669124182832151093921194946365178919380690844190324897933591567360925332869903671651849060145290581360223200011298757871213149464298017718829480721410479504940393501845624196721013966839230696831321482946841011452400364600924503121451272593970649100410603943321149604376033957124800064565646929720179239631538966228020882733213221035707244692798307971636126058586394357032072695921642665492919186476321028415907982915011972040971875733852055633796811898421692604356476773910338982400925245494707729878821466569634334862311750349321720627252469986162120031838</span><br><span class="line"># n2= 27929259512873502442719286790227037320417984116570178470037376373267390909685621247157535458203218619293705428397911754453556082799420494496904478215709219317542924547049229150153308059698341011305505985823374280465467094476511869541135508518055946815227085548571701115773386101962695795789178321155174729047033298389886321980592410739667139376075568555729949442873964097042006391886635957242436522435588904492484342259494858627609438654632887244523845583473711604632109405043439047289868784236481926074763997559971182741918345193506253460323445846136663027639802131457594564405906763806426256107923417802076262573737</span><br><span class="line"># ec2= 2838620519239658396968146844964839207179863729944843241951228382052657801460586137213053314019699976475855578055607417923815486109050614096157077528657405905877896929808094661904905136761365045387901486261011216958309860644255996588189249</span><br><span class="line"># c2= 10770781309274554738409447671578241895686779262243081931452089039730277591151694112684863740412412713684216227740930573490322958500198235497947657939304932868457999239593145330718657422535271157683896034543125292529800047408131765376686654378173684648427311300423776510153307756388404568013401217965931456538849277670384454454507752525534110389604969437991055504757081225690155489265359117617764571537216746554060783131168749700810806387918510612057149583061938836035963175555630655718716139689761210220525955656039741684390906935720406757364893793459339618913268943282961044530062475057887777134887741597041684698119</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运用<strong>低加密指数攻击</strong>求解出<span class="math inline">\(e1,e2\)</span></p><p>然后<strong>共模攻击</strong>解<span class="math inline">\(m\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ec1 = pow(bytes_to_long(str(e1).ljust(20, &quot;D&quot;).encode()), 3, p * q)</span><br><span class="line">左对齐字符串，使其长度为 20，并用字符“D”填充</span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">n = 27929259512873502442719286790227037320417984116570178470037376373267390909685621247157535458203218619293705428397911754453556082799420494496904478215709219317542924547049229150153308059698341011305505985823374280465467094476511869541135508518055946815227085548571701115773386101962695795789178321155174729047033298389886321980592410739667139376075568555729949442873964097042006391886635957242436522435588904492484342259494858627609438654632887244523845583473711604632109405043439047289868784236481926074763997559971182741918345193506253460323445846136663027639802131457594564405906763806426256107923417802076262573737</span><br><span class="line">ec1= 24979839185643431898760549059477070141596292955202172081572583839065034831779499992829742773873064296311713734486020739853343887094398935731264</span><br><span class="line">ec2= 2838620519239658396968146844964839207179863729944843241951228382052657801460586137213053314019699976475855578055607417923815486109050614096157077528657405905877896929808094661904905136761365045387901486261011216958309860644255996588189249</span><br><span class="line">e_1 = 3</span><br><span class="line">e_2 = 5</span><br><span class="line"></span><br><span class="line">k = 0</span><br><span class="line">while 1:</span><br><span class="line">    s = gmpy2.iroot(ec1+k*n, e_1)</span><br><span class="line">    t = gmpy2.iroot(ec2+k*n, e_2)</span><br><span class="line">    if s[1] and t[1]:</span><br><span class="line">        print(libnum.n2s(int(s[0])))</span><br><span class="line">        print(libnum.n2s(int(t[0])))</span><br><span class="line">        break</span><br><span class="line">    k += 1</span><br><span class="line"></span><br><span class="line">e1 = 34967</span><br><span class="line">e2 = 65535</span><br><span class="line">print(gmpy2.gcd(e1,e2))</span><br><span class="line"></span><br><span class="line">c1= 17695186679431856780362905635257355413310120106982055323913669124182832151093921194946365178919380690844190324897933591567360925332869903671651849060145290581360223200011298757871213149464298017718829480721410479504940393501845624196721013966839230696831321482946841011452400364600924503121451272593970649100410603943321149604376033957124800064565646929720179239631538966228020882733213221035707244692798307971636126058586394357032072695921642665492919186476321028415907982915011972040971875733852055633796811898421692604356476773910338982400925245494707729878821466569634334862311750349321720627252469986162120031838</span><br><span class="line">c2= 10770781309274554738409447671578241895686779262243081931452089039730277591151694112684863740412412713684216227740930573490322958500198235497947657939304932868457999239593145330718657422535271157683896034543125292529800047408131765376686654378173684648427311300423776510153307756388404568013401217965931456538849277670384454454507752525534110389604969437991055504757081225690155489265359117617764571537216746554060783131168749700810806387918510612057149583061938836035963175555630655718716139689761210220525955656039741684390906935720406757364893793459339618913268943282961044530062475057887777134887741597041684698119</span><br><span class="line"></span><br><span class="line">s, a, b = gmpy2.gcdext(e1, e2)</span><br><span class="line">if s == 1:</span><br><span class="line">    m = ((pow(c1, a, n) * pow(c2, b, n)) % n)</span><br><span class="line">    flag = libnum.n2s(int(m))</span><br><span class="line">    print(flag)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相关信息攻击(Franklin-Reiter)</title>
      <link href="/2023/09/13/%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E6%94%BB%E5%87%BB-Franklin-Reiter/"/>
      <url>/2023/09/13/%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E6%94%BB%E5%87%BB-Franklin-Reiter/</url>
      
        <content type="html"><![CDATA[<p>在比赛中多次遇到<span class="math inline">\(Franklin-Reiter\)</span>,今天来系统学习一下。</p><h2 id="关于franklin-reiter">关于Franklin-Reiter</h2><h3 id="定理">定理</h3><p>假设有两条消息 <span class="math inline">\(m1\)</span>和 <span class="math inline">\(m2\)</span>，其中 <span class="math inline">\(m1!= m2\)</span>（均小于模数<span class="math inline">\(n\)</span>）。且彼此线性相关：<span class="math inline">\(m1=f(m2)(mod\textbf{}n)\)</span>，其中<span class="math inline">\(f=a*x+b,(b!=0)\)</span>。如果这两个消息通过使用相同公钥<span class="math inline">\((n，e)\)</span>进行<span class="math inline">\(RSA\)</span>加密，得到密文<span class="math inline">\(c1\)</span>和<span class="math inline">\(c2\)</span>。那么，给定<span class="math inline">\((n，e，c1，c2，f)\)</span>，攻击者就可以恢复消息<span class="math inline">\(m1\)</span>和<span class="math inline">\(m2\)</span>。</p><p>简单来说，相关信息攻击就是<strong>如果两个信息之间存在某种线性关系，并且在相同的<span class="math inline">\(n\)</span>和<span class="math inline">\(e\)</span>下进行<span class="math inline">\(RSA\)</span>加密，那么就有可能恢复出这两个消息</strong>.即<strong><span class="math inline">\(m\)</span>和<span class="math inline">\(a*m+b(b!=0)\)</span>两个明文在相同的<span class="math inline">\((n,e)\)</span>下进行<span class="math inline">\(RSA\)</span>加密，那么<span class="math inline">\(m\)</span>就可以破解</strong>.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果两条消息之间仅存在某种线性关系</span><br><span class="line"></span><br><span class="line">并且在相同的(n,e)下进行RSA加密</span><br><span class="line"></span><br><span class="line">那么就有可能同时恢复它们</span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">m2 = a * m1 + b,其中b!=0</span><br><span class="line"></span><br><span class="line">c1 = pow(m1,e,n)</span><br><span class="line"></span><br><span class="line">c2 = pow(m2,e,n)</span><br><span class="line"></span><br><span class="line">其中a,b,c1,c2,e,n都已知，那么m1,m2可被破解</span><br></pre></td></tr></table></figure><h3 id="证明">证明</h3><p><span class="math display">\[c1=m1^{e}\textbf{ }mod\textbf{ }n \Rightarrow\]</span></p><p><span class="math display">\[c1 = (f(m2)\textbf{ }mod\textbf{ }n)^{e}\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[于是，就有多项式\textbf{ }\textbf{ }\left\{\begin{matrix}g_{1}(x)=x^{e}-c1\\g_{2}(x)=f(x)^{e}-c2\end{matrix}\right.\]</span></p><p>显然，<span class="math inline">\(m2\)</span>是上述两个多项式的根，因此它们有一个公因子<span class="math inline">\(x*m2\)</span><span class="math inline">\((g_{1}(x)=0,g_{2}(x)=0)\)</span>，所以我们<span class="math inline">\(gcd(g_{1},g_{2})\)</span>就能得到<span class="math inline">\(m2\)</span>,根据线性关系就能得到<span class="math inline">\(m1\)</span>.<strong>注意<span class="math inline">\(e=3\)</span>时，最大公因子一定是线性的</strong>。</p><h2 id="例题">例题</h2><h3 id="sictfround2-签到题来咯">2023 SICTF#Round2-签到题来咯！</h3><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from secret import flag</span><br><span class="line">from  Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">e = getPrime(10)</span><br><span class="line">n = p*q</span><br><span class="line">c1 = pow(114*m+2333,e,n)</span><br><span class="line">c2 = pow(514*m+4555,e,n)</span><br><span class="line">print(f&#x27;n = &#123;n&#125;&#x27;)</span><br><span class="line">print(f&#x27;c1 = &#123;c1&#125;&#x27;)</span><br><span class="line">print(f&#x27;c2 = &#123;c2&#125;&#x27;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 18993579800590288733556762316465854395650778003397512624355925069287661487515652428099677335464809283955351330659278915073219733930542167360381688856732762552737791137784222098296804826261681852699742456526979985201331982720936091963830799430264680941164508709453794113576607749669278887105809727027129736803614327631979056934906547015919204770702496676692691248702461766117271815398943842909579917102217310779431999448597899109808086655029624478062317317442297276087073653945439820988375066353157221370129064423613949039895822016206336117081475698987326594199181180346821431242733826487765566154350269651592993856883</span><br><span class="line">c1 = 3089900890429368903963127778258893993015616003863275300568951378177309984878857933740319974151823410060583527905656182419531008417050246901514691111335764182779077027419410717272164998075313101695833565450587029584857433998627248705518025411896438130004108810308599666206694770859843696952378804678690327442746359836105117371144846629293505396610982407985241783168161504309420302314102538231774470927864959064261347913286659384383565379900391857812482728653358741387072374314243068833590379370244368317200796927931678203916569721211768082289529948017340699194622234734381555103898784827642197721866114583358940604520</span><br><span class="line">c2 = 6062491672599671503583327431533992487890060173533816222838721749216161789662841049274959778509684968479022417053571624473283543736981267659104310293237792925201009775193492423025040929132360886500863823523629213703533794348606076463773478200331006341206053010168741302440409050344170767489936681627020501853981450212305108039373119567034948781143698613084550376070802084805644270376620484786155554275798939105737707005991882264123315436368611647275530607811665999620394422672764116158492214128572456571553281799359243174598812137554860109807481900330449364878168308833006964726761878461761560543284533578701661413931</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>感官上能看出<span class="math inline">\(m1和m2\)</span>存在某种<strong>线性关系</strong>。所以是<strong>相关信息攻击(<span class="math inline">\(Franklin-Reiter\)</span>)</strong></p><p>需要注意的是，这里<span class="math inline">\(e\)</span>是<span class="math inline">\(10bit\)</span>素数中的一个，遍历一下<span class="math inline">\(10bit\)</span>素数就行</p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import binascii</span><br><span class="line">n = </span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def franklinReiter(n,e,c1,c2):</span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    g1 = (114*x+2333)^e - c1</span><br><span class="line">    g2 = (514*x+4555)^e - c2</span><br><span class="line"></span><br><span class="line">    def gcd(g1, g2):</span><br><span class="line">        while g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        return g1.monic()</span><br><span class="line">    return -gcd(g1, g2)[0]</span><br><span class="line"></span><br><span class="line">def get_all_10_bit_primes():    # 求10bit的所有素数</span><br><span class="line">    return [i for i in range(2**9, 2**10) if isPrime(i)]</span><br><span class="line"></span><br><span class="line">e_all = get_all_10_bit_primes()</span><br><span class="line">print(e_all)</span><br><span class="line"></span><br><span class="line">for e in e_all:</span><br><span class="line">    m=franklinReiter(n,e,c1,c2)</span><br><span class="line">    flag = long_to_bytes(int(m))</span><br><span class="line">    if b&#x27;SICTF&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">print(&quot;over&quot;)</span><br><span class="line"># SICTF&#123;hhh!!franklin_reiter_is_easy&#125;</span><br></pre></td></tr></table></figure><h3 id="题二">题二</h3><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from secret import flag</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(flag)</span><br><span class="line">N = getPrime(512)*getPrime(512)</span><br><span class="line">e = 17</span><br><span class="line"></span><br><span class="line">c1 = pow(m1, e, N)</span><br><span class="line"></span><br><span class="line">a = getRandomNBitInteger(512)</span><br><span class="line">b = getRandomNBitInteger(512)</span><br><span class="line">m2 = a * m1 + b</span><br><span class="line">c2 = pow(m2, e, N)</span><br><span class="line"></span><br><span class="line">print(N, a, b, c1, c2, sep=&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line"># 51296885372346449295388453471330409021784141081351581975478435681552082076338697136130122011636685327781785488670769096434920591920054441921039812310126089859349902066456998315283909435249794317277620588552441456327265553018986591779396701680997794937951231970194353001576159809798153970829987274504038146741</span><br><span class="line"># 13256631249970000274738888132534852767685499642889351632072622194777502848070957827974250425805779856662241409663031192870528911932663995606616763982320967</span><br><span class="line"># 12614470377409090738391280373352373943201882741276992121990944593827605866548572392808272414120477304486154096358852845785437999246453926812759725932442170</span><br><span class="line"># 18617698095122597355752178584860764221736156139844401400942959000560180868595058572264330257490645079792321778926462300410653970722619332098601515399526245808718518153518824404167374361098424325296872587362792839831578589407441739040578339310283844080111189381106274103089079702496168766831316853664552253142</span><br><span class="line"># 14091361528414093900688440242152327115109256507133728799758289918462970724109343410464537203689727409590796472177295835710571700501895484300979622506298961999001641059179449655629481072402234965831697915939034769804437452528921599125823412464950939837343822566667533463393026895985173157447434429906021792720</span><br></pre></td></tr></table></figure><p>已知<span class="math inline">\((a,b,e,n,c1,c2)\)</span>,典型的<span class="math inline">\(Franklin-Reiter\)</span>攻击.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">n = </span><br><span class="line">a = </span><br><span class="line">b =  </span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line">e = </span><br><span class="line">import binascii</span><br><span class="line">def franklinReiter(n,e,c1,c2,a,b):</span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    g1 = (x)^e - c1</span><br><span class="line">    g2 = (a*x+b)^e - c2</span><br><span class="line"></span><br><span class="line">    def gcd(g1, g2):</span><br><span class="line">        while g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        return g1.monic() # </span><br><span class="line">    return -gcd(g1, g2)[0]</span><br><span class="line"></span><br><span class="line">m=franklinReiter(n,e,c1,c2,a,b)</span><br><span class="line">print(lont_to_bytes(m))</span><br><span class="line"># flag&#123;a593591a-3749-cc52-0c27-e897fac2c967&#125;</span><br></pre></td></tr></table></figure><p>其中代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def gcd(g1, g2): </span><br><span class="line">        while g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        return g1.monic() # </span><br><span class="line">    return -gcd(g1, g2)[0]</span><br></pre></td></tr></table></figure><p><strong>使用辗转相除法求多项式的最大公因子</strong>在代数中，一个多项式的<strong>首项系数</strong>通常被称为该多项式的引导系数<span class="math inline">\((leadingcoefficient）\)</span>，而将多项式变成<strong>首项系数为1的形式</strong>被称为将多项式化为<strong>首一形式</strong><span class="math inline">\((monic form)\)</span> 调用函数<span class="math inline">\(g1.monic()\)</span>将<span class="math inline">\(g1\)</span>转换为首一多项式<span class="math inline">\((monic polynomial)\)</span>，并返回该多项式。使用<span class="math inline">\(g.monic()[0]\)</span>，则会返回<span class="math inline">\(g(x)\)</span>除以引导系数后得到的多项式的<strong>常数项</strong>比如：<span class="math inline">\(g.monic() = x + 32412345\)</span>那么：<span class="math inline">\(g.monic()[0] = 32412345\)</span></p><h3 id="题三">题三</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import getPrime,bytes_to_long,long_to_bytes</span><br><span class="line">from functools import reduce</span><br><span class="line">from secret import flag, x, y</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">n = p*q</span><br><span class="line">print(n)</span><br><span class="line"></span><br><span class="line">assert(reduce(lambda x,y:x&amp;y,[(i-5)*i+6==0 for i in x]))</span><br><span class="line">assert(reduce(lambda x,y:x&amp;y,[(j-15)*j+44==0 for j in y]))</span><br><span class="line"></span><br><span class="line">print(pow(reduce(lambda x,y:x*m+y,x),17,n))</span><br><span class="line">print(pow(reduce(lambda x,y:x*m+y,y),17,n))</span><br><span class="line"></span><br><span class="line"># n = 23772599983135215481563178266884362291876571759991288577057472733374903836591330410574958472090396886895304944176208711481780781286891334062794555288959410390926474473859289842654809538435377431088422352076225067494924657598298955407771484146155998883073439266427190212827600119365643065276814044272790573450938596830336430371987561905132579730619341196199420897034988685012777895002554746080384319298123154671447844799088258541911028041717897434816921424155687677867019535399434825468160227242441375503664915265223696139025407768146464383537556265875013085702422829200814612395116961538432886116917063119749068212699</span><br><span class="line"># c1 = 10900151504654409767059699202929100225155892269473271859207513720755903691031362539478242920144073599515746938827937863835169270383721094542639011665235593065932998091574636525973099426040452626893461449084383663453549354608769727777329036059746386523843912382289597182615339786437186169811342356085836838520978047561127661777189045888648773949147220411427306098338616422692914110656004863767719312410906124366000507952960331116878197129010412361636679449281808407214524741732730279777729251515759320442591663641984363061618865267606007355576230009922421807527598213455112981354590909603317525854070358390622096569841</span><br><span class="line"># c2 = 17298679220717326374674940612143058330715465693318467692839033642321129433471254547497087746971317567301086124779289015934582615377165560688447452762043163082394944604062014490446763247008217251611443338103074143809936437694543761369945095202092750900940979469994907399829695696313513303922266742415376818434932335640062684245008822643258497589196668426788916969378417960200705779461808292296450298558001909603602502604228973101048082095642290047196235959438278631661658312398313171590515776453711432353011579809351076532129444735206408591345372296372378396539831385036814349328459266432393612919118094115543053115450</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进行题目分析：</p><p>先看一下<span class="math inline">\(reduce()\)</span>,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assert(reduce(lambda x,y:x&amp;y,[(i-5)*i+6==0 for i in x]))</span><br><span class="line">assert(reduce(lambda x,y:x&amp;y,[(j-15)*j+44==0 for j in y]))</span><br></pre></td></tr></table></figure><p><span class="math inline">\(reduce\)</span>函数先从列表（或序列）中取出2个元素执行指定函数，并将输出结果与第3个元素传入函数，输出结果再与第4个元素传入函数，…，以此类推，直到列表每个元素都取完。</p><p>这里的作用就相当于<strong>解一元二次方程</strong></p><p>所以，<span class="math inline">\(x=[2,3],y=[4,11]\)</span></p><p>所以，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reduce(lambda x,y:x*m+y,x)</span><br><span class="line">reduce(lambda x,y:x*m+y,y)</span><br></pre></td></tr></table></figure><p>也就相当于，<span class="math inline">\(2*m+3,4*m+11\)</span>,典型的<span class="math inline">\(Franklin-Reiter\)</span></p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">n = </span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line">e = 17</span><br><span class="line">import binascii</span><br><span class="line">def franklinReiter(n,e,c1,c2):</span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    g1 = (2*x+3)^e - c1</span><br><span class="line">    g2 = (4*x+11)^e - c2</span><br><span class="line"></span><br><span class="line">    def gcd(g1, g2):</span><br><span class="line">        while g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        return g1.monic()</span><br><span class="line">    return -gcd(g1, g2)[0]</span><br><span class="line"></span><br><span class="line">m=franklinReiter(n,e,c1,c2)</span><br><span class="line">print(long_to_bytes(m))</span><br><span class="line"># flag&#123;r54__r3l473d_m355463_4774ck_4l50_c4ll3d_fr4nkl1n_r3173r_4774ck~&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="neepusec-ctf-2021-rsa">NEEPUSec CTF 2021 RSA</h3><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from sympy import nextprime</span><br><span class="line">import gmpy2</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">def encode (p1,p2,e):</span><br><span class="line">    not_hint = (p1 + 1) * (p2 + 1)</span><br><span class="line">    S = gmpy2.invert(e, not_hint)</span><br><span class="line">    not_p = S%(p1+1)</span><br><span class="line">    return not_p</span><br><span class="line"></span><br><span class="line">flag = b&#x27;Neepu&#123;********************&#125;&#x27;</span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p*q</span><br><span class="line">e = nextprime(random.randint(1,1000))</span><br><span class="line">d = gmpy2.invert(e, (p-1)*(q-1))</span><br><span class="line">c = pow(flag, e, n)</span><br><span class="line">print(c)</span><br><span class="line">print(n)</span><br><span class="line"></span><br><span class="line">m = encode(p, q, e)</span><br><span class="line">c1 = pow(m, 7, n)</span><br><span class="line">c2 = pow(m+e, 7, n)</span><br><span class="line">print(c1)</span><br><span class="line">print(c2)</span><br><span class="line"></span><br><span class="line">c = 78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671</span><br><span class="line">n = 91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543</span><br><span class="line">c1 = 10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892</span><br><span class="line">c2 = 46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>理清题目思路，本题要得到<span class="math inline">\(flag\)</span>重在求解<span class="math inline">\(p,q,e\)</span>.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> S = gmpy2.invert(e, not_hint)</span><br><span class="line">not_p = S%(p1+1)</span><br></pre></td></tr></table></figure><p>似乎类似于<span class="math inline">\(dp泄露\)</span>问题. <span class="math display">\[\left\{\begin{matrix}notp = S\textbf{ }mod\textbf{ }(p1+1)\\e*S=1\textbf{ }mod\textbf{ }nothint\end{matrix}\right.\Rightarrow\]</span></p><p><span class="math display">\[notp*e=S*e\textbf{ }mod\textbf{ }(p1+1)\]</span></p><p><span class="math display">\[所以,S*e=k*(p1+1)+notp*e=1\textbf{ }mod\textbf{ }(p1+1)(p2+1)\Rightarrow\]</span></p><p><span class="math display">\[notp*e=k1*(p1+1)*(p2+1)-k*(p1+1)+1\Rightarrow\]</span></p><p><span class="math display">\[notp*e=(p1+1)(k1*(p2+1)-k)+1\]</span></p><p><span class="math display">\[因为，notp&lt;(p1+1),所以0&lt;(k1*(p1+1)-k)&lt;e\]</span></p><p>这样，就能求出<span class="math inline">\(p1\)</span>.<span class="math inline">\(e\)</span>是未知的，所以我们需要先解出<span class="math inline">\(e\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = nextprime(random.randint(1,1000))</span><br></pre></td></tr></table></figure><p>爆破求解<span class="math inline">\(e\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">n = 91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543</span><br><span class="line">c1 = 10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892</span><br><span class="line">c2 = 46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119</span><br><span class="line">import binascii</span><br><span class="line">def franklinReiter(n,e,c1,c2):</span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    g1 = (x)^7 - c1</span><br><span class="line">    g2 = (x+e)^7 - c2</span><br><span class="line"></span><br><span class="line">    def gcd(g1, g2):</span><br><span class="line">        while g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        return g1.monic()</span><br><span class="line">    return -gcd(g1, g2)[0]</span><br><span class="line"></span><br><span class="line">for e in range(1,1500):</span><br><span class="line">    m = franklinReiter(n,e,c1,c2)</span><br><span class="line">    if pow(m,7,n) == c1:</span><br><span class="line">        print(&quot;e =&quot;,e)</span><br><span class="line">        print(&quot;m =&quot;,m)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 71</span><br><span class="line">m = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859</span><br></pre></td></tr></table></figure><p>求<span class="math inline">\(p,q\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line">n = 91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543</span><br><span class="line">c = 78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671</span><br><span class="line">dp = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859      </span><br><span class="line">e = 71</span><br><span class="line">for k in range(1,e):</span><br><span class="line">    if ((dp*e-1)%k) == 0:</span><br><span class="line">        if n%((dp*e-1)//k - 1) == 0:</span><br><span class="line">            p1 = (dp*e-1)//k - 1</span><br><span class="line">            p = p1</span><br><span class="line">            q = n//p</span><br><span class="line">d = gmpy2.invert(e,(p-1)*(q-1))</span><br><span class="line">m = pow(c,d,n)</span><br><span class="line">print(long_to_bytes(int(m)))</span><br><span class="line"># Neepu&#123;Have-a-g00d-day12138&#125;</span><br></pre></td></tr></table></figure><h3 id="half-gcd">Half-Gcd</h3><p>参考：<a href="https://github.com/rkm0959/rkm0959_implements/tree/main/Half_GCD">Half-Gcd</a></p><p>​ <a href="https://www.cnblogs.com/whx1003/p/16217087.html">多项式gcd的正确姿势：Half-Gcd算法</a></p><p>​ <a href="https://blog.maple3142.net/2021/11/07/bsides-ahmedabad-ctf-2021-writeups/#ecc-rsa-2">*ECC-RSA2</a></p><p>该算法<strong>计算两个多项式的 GCD的速度比标准欧几里得算法更快</strong></p><p>一般来说，<span class="math inline">\(Franlin-Reiter\)</span>攻击时的加密指数<span class="math inline">\(e\)</span>都是比较小的，但也会出现<strong><span class="math inline">\(e\)</span>比较大</strong>的情况，这时用<span class="math inline">\(Half-Gcd\)</span>能很快解出。</p><p>例题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p1, q1 = getPrime(512), getPrime(512)</span><br><span class="line">n1 = p1*q1</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">p2, q2 = getPrime(512), getPrime(512)</span><br><span class="line">n2 = p2*q2</span><br><span class="line"></span><br><span class="line">print(f&#x27;n1 = &#123;n1&#125;&#x27;)</span><br><span class="line">print(f&#x27;n2 = &#123;n2&#125;&#x27;)</span><br><span class="line">print(f&#x27;c1 = &#123;pow(m,e,n2)&#125;&#x27;)</span><br><span class="line">print(f&#x27;c2 = &#123;pow(n1-m,e,n2)&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># n1 = 52579135273678950581073020233998071974221658902576724000130040488018033110534210901239397446395736563148970863970460542205225993317478251099451639165369081820130823165642873594136020122857712288395352930384057524510346112486008850200845915783772351449146183974239444691330777565342525218070680067550270554767</span><br><span class="line"># n2 = 68210568831848267339414957973218186686176324296418282565773310695862151827108036984694027795077376921170907068110296451176263520249799154781062517066423984526868547296781709439425857993705489037768605485740968600877866332458671029054092942851472208033494968784822459369206497698469167909174346042658361616469</span><br><span class="line"># c1 = 42941712708129054668823891960764339394032538100909746015733801598044118605733969558717842106784388091495719003761324737091667431446354282990525549196642753967283958283202592037329821712755519455155110675327321252333824912095517427885925854391047828862338332559137577789387455868761466777370476884779752953853</span><br><span class="line"># c2 = 62704043252861638895370674827559804184650708692227789532879941590038911799857232898692335429773480889624046167792573885125945511356456073688435911975161053231589019934427151230924004944847291434167067905803180207183209888082275583120633408232749119300200555327883719466349164062163459300518993952046873724005</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def HGCD(a, b):</span><br><span class="line">    if 2 * b.degree() &lt;= a.degree() or a.degree() == 1:</span><br><span class="line">        return 1, 0, 0, 1</span><br><span class="line">    m = a.degree() // 2</span><br><span class="line">    a_top, a_bot = a.quo_rem(x^m)</span><br><span class="line">    b_top, b_bot = b.quo_rem(x^m)</span><br><span class="line">    R00, R01, R10, R11 = HGCD(a_top, b_top)</span><br><span class="line">    c = R00 * a + R01 * b</span><br><span class="line">    d = R10 * a + R11 * b</span><br><span class="line">    q, e = c.quo_rem(d)</span><br><span class="line">    d_top, d_bot = d.quo_rem(x^(m // 2))</span><br><span class="line">    e_top, e_bot = e.quo_rem(x^(m // 2))</span><br><span class="line">    S00, S01, S10, S11 = HGCD(d_top, e_top)</span><br><span class="line">    RET00 = S01 * R00 + (S00 - q * S01) * R10</span><br><span class="line">    RET01 = S01 * R01 + (S00 - q * S01) * R11</span><br><span class="line">    RET10 = S11 * R00 + (S10 - q * S11) * R10</span><br><span class="line">    RET11 = S11 * R01 + (S10 - q * S11) * R11</span><br><span class="line">    return RET00, RET01, RET10, RET11</span><br><span class="line">    </span><br><span class="line">def GCD(a, b):</span><br><span class="line">    print(a.degree(), b.degree())</span><br><span class="line">    q, r = a.quo_rem(b)</span><br><span class="line">    if r == 0:</span><br><span class="line">        return b</span><br><span class="line">    R00, R01, R10, R11 = HGCD(a, b)</span><br><span class="line">    c = R00 * a + R01 * b</span><br><span class="line">    d = R10 * a + R11 * b</span><br><span class="line">    if d == 0:</span><br><span class="line">        return c.monic()</span><br><span class="line">    q, r = c.quo_rem(d)</span><br><span class="line">    if r == 0:</span><br><span class="line">        return d</span><br><span class="line">    return GCD(d, r)</span><br><span class="line"></span><br><span class="line">P.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">sys.setrecursionlimit(500000)</span><br><span class="line"></span><br><span class="line">n = 68210568831848267339414957973218186686176324296418282565773310695862151827108036984694027795077376921170907068110296451176263520249799154781062517066423984526868547296781709439425857993705489037768605485740968600877866332458671029054092942851472208033494968784822459369206497698469167909174346042658361616469</span><br><span class="line">n1 = 52579135273678950581073020233998071974221658902576724000130040488018033110534210901239397446395736563148970863970460542205225993317478251099451639165369081820130823165642873594136020122857712288395352930384057524510346112486008850200845915783772351449146183974239444691330777565342525218070680067550270554767</span><br><span class="line">e = 65537</span><br><span class="line">c1 = 42941712708129054668823891960764339394032538100909746015733801598044118605733969558717842106784388091495719003761324737091667431446354282990525549196642753967283958283202592037329821712755519455155110675327321252333824912095517427885925854391047828862338332559137577789387455868761466777370476884779752953853</span><br><span class="line">c2 = 62704043252861638895370674827559804184650708692227789532879941590038911799857232898692335429773480889624046167792573885125945511356456073688435911975161053231589019934427151230924004944847291434167067905803180207183209888082275583120633408232749119300200555327883719466349164062163459300518993952046873724005</span><br><span class="line">f = (x)^e - c1</span><br><span class="line">g = (n1 - x)^e - c2</span><br><span class="line"></span><br><span class="line">km = GCD(f,g)</span><br><span class="line">m = -km.monic()[0]</span><br><span class="line">print(m)</span><br><span class="line">print(long_to_bytes(int(m)))</span><br></pre></td></tr></table></figure><p>这里，<span class="math inline">\(GCD(f,g)\)</span>得到的是<span class="math inline">\(ax-bm\)</span>,需要用<span class="math inline">\(monic()\)</span>对这个式子进行<strong>首一化</strong>（前面讲过）</p><p>最后附后参考文章：</p><p><a href="https://blog.csdn.net/XiongSiqi_blog/article/details/130978226">Franklin-Reiter相关消息攻击</a></p>]]></content>
      
      
      <categories>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性关系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023 SICTF#Round 2 WP</title>
      <link href="/2023/09/11/2023-SICTF-Round-2-WP/"/>
      <url>/2023/09/11/2023-SICTF-Round-2-WP/</url>
      
        <content type="html"><![CDATA[<h2 id="radio">Radio</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from flag import flag</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">n1 = p * q</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">n2 = p * q</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">n3 = p * q</span><br><span class="line">e = 17</span><br><span class="line">c1 = pow(m,e,n1)</span><br><span class="line">c2 = pow(m,e,n2)</span><br><span class="line">c3 = pow(m,e,n3)</span><br><span class="line">print(&quot;n1 =&quot;,n1)</span><br><span class="line">print(&quot;n2 =&quot;,n2)</span><br><span class="line">print(&quot;n3 =&quot;,n3)</span><br><span class="line">print(&quot;c1 =&quot;,c1)</span><br><span class="line">print(&quot;c2 =&quot;,c2)</span><br><span class="line">print(&quot;c3 =&quot;,c3)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n1 = 14628911682936716611458501697007036859460044243525290515096052103585430459755335375005202100114469571371360084664887335211277585652711111523095037589648375630146039444071400098427638768750755153219974194380355807078158427824557754939604018020265955042573660474772006646525311705184431094905718137297923127124517126579859336516891364853724635334011666814712424599592662398013241607855160919361308195967978220182785816761656927836373944699635667244275310680450562446433724968942835275279255823144471582249379035668825437133182865600026935116686574740844588839352146024513673500770611055698030333734066230166111140083923 </span><br><span class="line">n2 = 16756694748293603983474688536179571665757862433174984877308316444468003022266277794769268134195205510197588585566270416339902269736376811449830775290335951504698137924773942880807921752691668522662285163130340474205633998154849689387759453003838730282756734975490180702422176361373516245372635401939755527017589503572550811648345570775428936487145892225736625411540461653083957762795820510109891180906709827194217045059033312564525916136573856999724346161896146703174418039344166251503310869772735585554127509732135494936119159784702673291794381095696332128950979288440758815310482211285712819274848744478643590996499 </span><br><span class="line">n3 = 12023158079717019193506148537498877243668782424904061914991928068483879707115315968983829360560644394409575645736275352836086080024994045582242629571839276759393418303915955798990522990081795218822313146157773272844272865701134880180795342597049645358985187689813369428579614193015028249821853347208001645148169449968882591709833452960545988520048722323580338213590245476892223967673180144525106292453573842357322398199104132677638909964034937501684668442732786408572501007756270725934445316827054687741612177409932320532825182104820899546084015733164816993674100635828218335112393003462442685677115798304835391938681 </span><br><span class="line">c1 = 786426913645332991929803636719878643130489430090701482974255190570111407517277263761161970232982615374753982050075781017755721714929721429185828101898786972242994012456972241276851428750970754773002966788642795040933520662931514953660571657013642671173456750800960592586345219252277575624120271330470724245201080094330964145796872211627254805407394764183615099525852600855622089361965086460279057625205099471122036599934609091062009161119885692567925924978687256063116915630947838112126347748759078024890458539541208153526564434483654508834147071166870006117573542198238493913144419569943131642262575848786399020602    </span><br><span class="line">c2 = 14269311999815379511888097227418748728398011595172649708273598243317106830139061994801598925448165045032084910971094414749744701731066555194159863759072739031915833091715422787808666326235589236328864675164322734119047182014621724868200908222400504845559290620275973427127376594365043386362821355037781568524903149101953873768462097165128186788759111090267131443645126715520994688945363059795513931799317608292977574376954729552861360597103229877031117089231816770880909815561950691603994439997197261395452797893557057320175747162837857668062550646101714062365530246698404923128445182100334335447738834779014705114350  </span><br><span class="line">c3 = 3204718091370324153305164801961074660508922478706979436653573192321723216725523523538914956544950802616295043619768261075799875855502834749045520466140056621489305006966280527055668378303630674311102581232313032585389907028715671091914904062961720585667564982641321454541632782484415075257140508738041786400512095949826279576159569786734978545737717138115729502475357594151593143140355121154223614868465202149338507796306863351134218879326031985027900678671697876083351974546516576983143592764763925335805465720148057651958521255276602933604064541840892578409973858867533575728482926007556060584654853884046046420855 </span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><span class="math inline">\(e=17\)</span>比较小，在相同<span class="math inline">\(e\)</span>的情况下对同一信息使用不同的模数<span class="math inline">\(n\)</span>进行<span class="math inline">\(RSA\)</span>加密，所以是低加密指数广播攻击。(核心是<span class="math inline">\(CRT\)</span></strong>)</p><p>实现低加密指数广播攻击需要满足以下三个条件：</p><p>（1）加密指数e非常小。（2）同一份明文使用不同的模数n，相同的加密指数e进行多次加密。（3）攻击者可以得到每一份加密后的密文和对应的模数n、加密指数e。</p><p>解题思路</p><p>运用中国剩余定理。</p><p>设正整数<span class="math inline">\(n _{1} , n _{2} , n_{3},.......,n _{k}\)</span>两两互素,对任意整数<span class="math inline">\(c_{1},c_{2},c_{3},.......,c_{n}\)</span>,一次同余方程组<span class="math display">\[\left\{\begin{matrix} x &amp; \equiv &amp; c_{1} &amp; mod &amp; n_{1}\\x&amp; \equiv &amp; c_{2} &amp; mod &amp;n_{2} \\ x&amp; \equiv &amp;c_{3} &amp; mod &amp;n_{3} \\ ...&amp; &amp; &amp; &amp; \\ x&amp;\equiv&amp;c_{n} &amp; mod &amp;n_{k} \end{matrix}\right.\]</span></p><p>在模N意义下存在唯一解，该解可表示为: <span class="math display">\[x\equivN_{1}*d_{1}*c_{1}+N_{2}*d_{2}*c_{2}+N_{3}*d_{3}*c_{3}+...N_{n}*d_{n}*c_{n}\mathbf{}mod\mathbf{ }N\]</span> 其中,<span class="math inline">\(n=n_{1}*n_{2}*n_{3}*...*n_{k}\)</span>,</p><p>​ <span class="math inline">\(N_{i}=N/n_{i}\)</span>,</p><p>​ <span class="math inline">\(d_{i}\equiv N_{i}^{-1}\textbf{}mod\textbf{ }n_{i}\)</span></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from functools import reduce</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line"># 中国剩余定理</span><br><span class="line">def CRT(cipher, n):</span><br><span class="line">    N = reduce(lambda x, y: x * y, (i for i in n))</span><br><span class="line">    result = 0</span><br><span class="line">    data = zip(cipher, n)</span><br><span class="line">    for ci, ni in data:</span><br><span class="line">        Ni = N // ni</span><br><span class="line">        di = gmpy2.invert(Ni, ni)</span><br><span class="line">        result += ci * Ni * di</span><br><span class="line">    return result % N, N</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = 17</span><br><span class="line">c = [</span><br><span class="line">    786426913645332991929803636719878643130489430090701482974255190570111407517277263761161970232982615374753982050075781017755721714929721429185828101898786972242994012456972241276851428750970754773002966788642795040933520662931514953660571657013642671173456750800960592586345219252277575624120271330470724245201080094330964145796872211627254805407394764183615099525852600855622089361965086460279057625205099471122036599934609091062009161119885692567925924978687256063116915630947838112126347748759078024890458539541208153526564434483654508834147071166870006117573542198238493913144419569943131642262575848786399020602,</span><br><span class="line">    14269311999815379511888097227418748728398011595172649708273598243317106830139061994801598925448165045032084910971094414749744701731066555194159863759072739031915833091715422787808666326235589236328864675164322734119047182014621724868200908222400504845559290620275973427127376594365043386362821355037781568524903149101953873768462097165128186788759111090267131443645126715520994688945363059795513931799317608292977574376954729552861360597103229877031117089231816770880909815561950691603994439997197261395452797893557057320175747162837857668062550646101714062365530246698404923128445182100334335447738834779014705114350,</span><br><span class="line">    3204718091370324153305164801961074660508922478706979436653573192321723216725523523538914956544950802616295043619768261075799875855502834749045520466140056621489305006966280527055668378303630674311102581232313032585389907028715671091914904062961720585667564982641321454541632782484415075257140508738041786400512095949826279576159569786734978545737717138115729502475357594151593143140355121154223614868465202149338507796306863351134218879326031985027900678671697876083351974546516576983143592764763925335805465720148057651958521255276602933604064541840892578409973858867533575728482926007556060584654853884046046420855</span><br><span class="line">]</span><br><span class="line">n = [</span><br><span class="line">    14628911682936716611458501697007036859460044243525290515096052103585430459755335375005202100114469571371360084664887335211277585652711111523095037589648375630146039444071400098427638768750755153219974194380355807078158427824557754939604018020265955042573660474772006646525311705184431094905718137297923127124517126579859336516891364853724635334011666814712424599592662398013241607855160919361308195967978220182785816761656927836373944699635667244275310680450562446433724968942835275279255823144471582249379035668825437133182865600026935116686574740844588839352146024513673500770611055698030333734066230166111140083923,</span><br><span class="line">    16756694748293603983474688536179571665757862433174984877308316444468003022266277794769268134195205510197588585566270416339902269736376811449830775290335951504698137924773942880807921752691668522662285163130340474205633998154849689387759453003838730282756734975490180702422176361373516245372635401939755527017589503572550811648345570775428936487145892225736625411540461653083957762795820510109891180906709827194217045059033312564525916136573856999724346161896146703174418039344166251503310869772735585554127509732135494936119159784702673291794381095696332128950979288440758815310482211285712819274848744478643590996499,</span><br><span class="line">    12023158079717019193506148537498877243668782424904061914991928068483879707115315968983829360560644394409575645736275352836086080024994045582242629571839276759393418303915955798990522990081795218822313146157773272844272865701134880180795342597049645358985187689813369428579614193015028249821853347208001645148169449968882591709833452960545988520048722323580338213590245476892223967673180144525106292453573842357322398199104132677638909964034937501684668442732786408572501007756270725934445316827054687741612177409932320532825182104820899546084015733164816993674100635828218335112393003462442685677115798304835391938681</span><br><span class="line">    ]</span><br><span class="line">x, N = CRT(c, n)</span><br><span class="line"></span><br><span class="line">m = gmpy2.iroot(gmpy2.mpz(x), e)[0]</span><br><span class="line">print(m)</span><br><span class="line">print(long_to_bytes(m))</span><br><span class="line"># SICTF&#123;fdc0afb5-1c81-46b9-a28a-241f5f64419d&#125;</span><br></pre></td></tr></table></figure><h2 id="mingtianpao">MingTianPao</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import binascii</span><br><span class="line">from Crypto.Util.strxor import strxor</span><br><span class="line">from secret import flag, message</span><br><span class="line"># message is a Classic English Story</span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    tmp = (message[i*30:(i+1)*30].encode())</span><br><span class="line">    print(binascii.hexlify(strxor(tmp,flag)).decode())</span><br><span class="line"></span><br><span class="line"># 1f2037202a1e6d06353b61263d050a0538493b3018544e14171d2b1c4218</span><br><span class="line"># 3769373b66142f31297f291126410e042b01162d59103a0c005221075013</span><br><span class="line"># 37242c202e1e3f743c36371130410c1e2b491a31574406014505291a550e</span><br><span class="line"># 7f6922742e1a213270372e01264105193004532b1f554e120c1e2a145618</span><br><span class="line"># 7d69143c23156d18392b35183141310e3b49213613590003453a291a555d</span><br><span class="line"># 36273731341e297424372454230e0c0f2c49127f005f020245112718545d</span><br><span class="line"># 26396320295b2531227161273c04430f360d533118444e0f0b1d31554615</span><br><span class="line"># 323d6335660c24373b3a2554350f0a063e05533712101905165e66145f19</span><br><span class="line"># 733e222766152220703e27063508074b300f53371e5d40444735291a555d</span><br><span class="line"># 37283a7432146d2d3f2a6d541808171f330c530d12544e360c162f1b565d</span><br></pre></td></tr></table></figure><p>这是一个典型的<span class="math inline">\(MTP(Many-Time-Pad)\)</span>问题。<strong>构造一个一定长度的密钥<span class="math inline">\(key\)</span>,让明文异或<span class="math inline">\(key\)</span>.解密是只需要让密文异或上<span class="math inline">\(key\)</span>就可以得到明文。这样在信息传输过程中就只需要传输一次密钥就可以，这样的加密方式就是<span class="math inline">\(Many-Time-Pad (MTP)\)</span></strong>.</p><p>在这个加密过程中，值得一提的是<strong>小写字母<span class="math inline">\(xor\)</span>空格得到对应的大写字母，大写字母<span class="math inline">\(xor\)</span>空格得到对应的小写字母，字母<span class="math inline">\(xor\)</span>字母<span class="math inline">\(!=\)</span> 字母</strong>.</p><p>参考：<a href="https://www.ruanx.net/many-time-pad/">Many-Time-Pad</a></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Crypto.Util.strxor as xo</span><br><span class="line">import libnum, codecs, numpy as np</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def isChr(x):</span><br><span class="line">    if ord(&#x27;a&#x27;) &lt;= x and x &lt;= ord(&#x27;z&#x27;): return True</span><br><span class="line">    if ord(&#x27;A&#x27;) &lt;= x and x &lt;= ord(&#x27;Z&#x27;): return True</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def infer(index, pos):</span><br><span class="line">    if msg[index, pos] != 0:</span><br><span class="line">        return</span><br><span class="line">    msg[index, pos] = ord(&#x27; &#x27;)</span><br><span class="line">    for x in range(len(c)):</span><br><span class="line">        if x != index:</span><br><span class="line">            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">def know(index, pos, ch):</span><br><span class="line">    msg[index, pos] = ord(ch)</span><br><span class="line">    for x in range(len(c)):</span><br><span class="line">        if x != index:</span><br><span class="line">            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(ch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dat = []</span><br><span class="line"></span><br><span class="line">def getSpace():</span><br><span class="line">    for index, x in enumerate(c):</span><br><span class="line">        res = [xo.strxor(x, y) for y in c if x!=y]</span><br><span class="line">        f = lambda pos: len(list(filter(isChr, [s[pos] for s in res])))</span><br><span class="line">        cnt = [f(pos) for pos in range(len(x))]</span><br><span class="line">        for pos in range(len(x)):</span><br><span class="line">            dat.append((f(pos), index, pos))</span><br><span class="line"></span><br><span class="line">c1 = [</span><br><span class="line">0x1f2037202a1e6d06353b61263d050a0538493b3018544e14171d2b1c4218,</span><br><span class="line">0x3769373b66142f31297f291126410e042b01162d59103a0c005221075013,</span><br><span class="line">0x37242c202e1e3f743c36371130410c1e2b491a31574406014505291a550e,</span><br><span class="line">0x7f6922742e1a213270372e01264105193004532b1f554e120c1e2a145618,</span><br><span class="line">0x7d69143c23156d18392b35183141310e3b49213613590003453a291a555d,</span><br><span class="line">0x36273731341e297424372454230e0c0f2c49127f005f020245112718545d,</span><br><span class="line">0x26396320295b2531227161273c04430f360d533118444e0f0b1d31554615,</span><br><span class="line">0x323d6335660c24373b3a2554350f0a063e05533712101905165e66145f19,</span><br><span class="line">0x733e222766152220703e27063508074b300f53371e5d40444735291a555d,</span><br><span class="line">0x37283a7432146d2d3f2a6d541808171f330c530d12544e360c162f1b565d</span><br><span class="line">]</span><br><span class="line">c = []</span><br><span class="line">for i in c1:</span><br><span class="line">    c.append(long_to_bytes(i))</span><br><span class="line"></span><br><span class="line"># c = [codecs.decode(x.strip().encode(), &#x27;hex&#x27;) for x in open(&#x27;Problem.txt&#x27;, &#x27;r&#x27;).readlines()]</span><br><span class="line">msg = np.zeros([len(c), len(c[0])], dtype=int)</span><br><span class="line"></span><br><span class="line">getSpace()</span><br><span class="line"></span><br><span class="line">dat = sorted(dat)[::-1]</span><br><span class="line">for w, index, pos in dat:</span><br><span class="line">    infer(index, pos)</span><br><span class="line"></span><br><span class="line">know(0,24,&#x27;r&#x27;)</span><br><span class="line">know(1,10,&#x27;h&#x27;)</span><br><span class="line">know(1,12,&#x27;r&#x27;)</span><br><span class="line">know(2,28,&#x27;d&#x27;)</span><br><span class="line">know(3,16,&#x27;o&#x27;)</span><br><span class="line"></span><br><span class="line">print(&#x27;\n&#x27;.join([&#x27;&#x27;.join([chr(c) for c in x]) for x in msg]))</span><br><span class="line"></span><br><span class="line">key = xo.strxor(c[0], &#x27;&#x27;.join([chr(c) for c in msg[0]]).encode())</span><br><span class="line">print(key)</span><br><span class="line"># SICTF&#123;MTP_AtTack_is_w0nderFu1&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">know(0,24,&#x27;r&#x27;)</span><br><span class="line">know(1,10,&#x27;h&#x27;)</span><br><span class="line">know(1,12,&#x27;r&#x27;)</span><br><span class="line">know(2,28,&#x27;d&#x27;)</span><br><span class="line">know(3,16,&#x27;o&#x27;)</span><br></pre></td></tr></table></figure><p>这里解释一下这一段代码，因为<strong>直接跑脚本恢复的明文中有一些单词并没有恢复完整，所以需要配合<span class="math inline">\(know()\)</span>将一些字母替换成正确的字母</strong>。要特别注意下标，很容易弄错。</p><p>另外，在做这一题之前，我做过一题类似的(当时不知道是<span class="math inline">\(MTP\)</span>),是用<span class="math inline">\(lingfeng\)</span>师傅的脚本做出来的。本次赛中尝试过那个脚本，无果。后来知道是这次<strong>数据太少，随机性太差</strong>。对本题稍加改动，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag = open(&#x27;flag.txt&#x27;,&#x27;rb&#x27;).read()</span><br><span class="line">assert flag.startswith(b&#x27;SICTF&#123;&#x27;) and flag.endswith(b&#x27;&#125;&#x27;)</span><br><span class="line">article = open(&#x27;article.txt&#x27;,&#x27;rb&#x27;).read()</span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">strxor = lambda x,y: bytes([a^b for a,b in zip(x,y)])</span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line">for i in range(100):</span><br><span class="line">    range_start = random.randint(0, len(article) - len(flag))</span><br><span class="line">    mask = article[range_start:range_start + len(flag)]</span><br><span class="line">    result.append(strxor(flag, mask))</span><br><span class="line"></span><br><span class="line">with open(&quot;result.log&quot;,&quot;w&quot;) as fs:</span><br><span class="line">    fs.writelines([str(i)+&quot;\n&quot; for i in result])</span><br></pre></td></tr></table></figure><p><span class="math inline">\(result.loog\)</span>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&quot;=-c5f\x10(1&gt;1$\x07&#x27;A\x0c\r\x7f\x08\x03/\x05U\r\r\x04\x06/\x1a_]&quot;</span><br><span class="line">b&#x27;6**52\x1em&lt;5&gt;3\x1d:\x06OK0\x07\x1f&amp;WD\x06\x01E\x10*\x1c_\x19&#x27;</span><br><span class="line">b&#x27;s&gt;&amp;t.\x1a;1p*/\x00=\rC\x1c:I\x1f0\x04UN\r\x11^f\x1aW]&#x27;</span><br><span class="line">b&#x27;&lt;/c24\x1e(t=:/T#\t\x0cK7\x08\x05:WQN\x07\r\x1d/\x16TQ&#x27;</span><br><span class="line">b&quot;&gt;,c&#x27;2\t( 37$\x07t\x03\x06\r0\x1b\x16\x7f\x02CN\r\x0bR2\x1dT]&quot;</span><br><span class="line">b&#x27;7(:\&#x27;f\x089&amp;5+&quot;\x1ct\x0e\x16\x1f\x7f\x00\x1d\x7f\x16^N\x01\x0b\x16*\x10B\x0e&#x27;</span><br><span class="line">b&quot;;,c0&#x27;\x02&gt;t#+3\x11 \x02\x0bK0\x1c\x07\x7f\x1e^N\x05\x0bR#\x1bU\x11&quot;</span><br><span class="line">b&quot;6-c52[9&lt;5\x7f-\x15&#x27;\x15C\x066\x07\x06+\x12\x10\x0c\x1dE\x01)\x18T]&quot;</span><br><span class="line">b&#x27;s(-0f\x16&quot;:$72T5\x0f\x07K&amp;\x0c\x12-\x04\x10\x1a\x0bE\x11)\x18TS&#x27;</span><br><span class="line">b&quot;6i6&#x27;f\x12#t$7$T7\x0e\r\x18+\x08\x1d+W@\x0f\n\n\x00&#x27;\x18P]&quot;</span><br><span class="line">b&#x27;=i&quot;:&quot;[:=$7a\x18=\x15\x17\x07:I\x12/\x07B\x0b\x07\x0c\x132\x1c^\x13&#x27;</span><br><span class="line">b&#x27;s!&quot;0f\x14#8)\x7f T8\x08\x0e\x02+\x0c\x17\x7f\x16^\nD\x16\x02#\x16X\x1b&#x27;</span><br><span class="line">b&#x27;5i\xa1\xd4\xda&gt;, |\x7f%\x06=\x0f\x08G\x7f\x08\x1d;WR\x0bD\x08\x174\x07H\x9f&#x27;</span><br><span class="line">b&quot;2&#x27;&#x27;t.\x1e,&amp;91&amp;T=\x0fC\n;\x1c\x1f+W\\\x07\x02\x00\\f7D\t&quot;</span><br><span class="line">b&quot;s(/#&#x27;\x02&gt;t&#x27;:a\x031\x13\x06K6\x07\x07:\x05U\x1d\x10\x00\x16f\x1c_]&quot;</span><br><span class="line">b&quot;s&amp;%t0\x1a!!5,a\x1d&#x27;A\x00\x03&gt;\x07\x14:\x13\x1eN,\x00R$\x10R\x12&quot;</span><br><span class="line">b&#x27;$&amp;68&quot;[/1p&gt;a\x168\x04\x10\x186\x07\x14\x7f\x1eVN\x01\x04\x11.UY\x08&#x27;</span><br><span class="line">b&#x27; =&quot;zf(&quot;t\&#x27;:a\x13;A\x02\t0\x1c\x07\x7f\x18E\x1cD\x15\x172\x01H]&#x27;</span><br><span class="line">b&#x27;s/&amp;#f\x1f,-#\x7f \x00t\x12\x0c\x06:I\x076\x1aUN\x00\x10\x00/\x1bV]&#x27;</span><br><span class="line">b&#x27; i,2f\x1a=$&quot;:&quot;\x1d5\x15\n\x041I\x047\x1eS\x06D\x04\x00#U^\x1b&#x27;</span><br><span class="line">b&#x27;s-1=(\x10at11%T6\x04C\x06:\x1b\x01&amp;\x95\xb0\xf3JE03\x01\x11\x10&#x27;</span><br><span class="line">b&#x27; iq`f\x13&quot;!&quot;,oT\x16\x14\x17K&gt;\x05\x04&gt;\x0eCN\x13\x00R1\x10C\x18&#x27;</span><br><span class="line">b&quot;&#x27; 51f\x14+t$7$T9\x04\x02\x056\x07\x14\x7f\x18VN\x08\x0c\x14#UP\x13&quot;</span><br><span class="line">b&#x27;\x07!&amp;t&quot;\x1a4\&#x27;p,5\x061\x15\x00\x03\x7f\x06\x06+WY\x00D\x04\x1cf\x10_\x19&#x27;</span><br><span class="line">b&#x27;&#125;i\x0b1f\x19(7?2$\x07t\x0c\x0c\x19:I\x12/\x07B\x0b\x07\x0c\x132\x1cG\x18&#x27;</span><br><span class="line">b&quot;6**52\x12;1p0&#x27;T&#x27;\x08\x04\x03+RS,\x1e\\\x0b\n\x06\x17f\x02^\x08&quot;</span><br><span class="line">b&#x27;&lt;:&amp;t1\x13&quot;t8&gt;7\x11t\r\x0c\x18+I\x006\x10X\x1aD\x04\x1c&quot;UY\x18&#x27;</span><br><span class="line">b&#x27;6:0xf\r$3?-a\x15:\x05C\n\x7f\x02\x16:\x19^\x0b\x17\x16R)\x13\x11\x1c&#x27;</span><br><span class="line">b&#x27;; 0t#\x1a?8)\x7f \x10!\r\x17K3\x00\x15:Y\x10*\x05\x17\x19(\x10B\x0e&#x27;</span><br><span class="line">b&#x27;5i%&amp;#\x1em951a\x03&lt;\x0eC\x03&gt;\x1f\x16\x7f\x16\x10\r\x0c\n\x1b%\x10\x1d]&#x27;</span><br><span class="line">b&#x27;$,514Wm 14$T8\x08\x05\x0e\x7f\x0f\x1c-WW\x1c\x05\x0b\x06#\x11\x1f]&#x27;</span><br><span class="line">b&#x27;7,&quot; .U\x8f\xf4]U\x08\x1at\x12\x17\x04-\x00\x16,WD\x06\x01E\x16)\x1a\\\x18&#x27;</span><br><span class="line">b&#x27;6-mt\x11\x1em?&gt;06T \t\x02\x1f\x7f\x06\x1d:WT\x0f\x1dE\x05#U\\\x08&#x27;</span><br><span class="line">b&quot;!:&amp;xf\x14+t6-$\x11t\x0c\x06\x05\x7f\x1e\x1b0WX\x0f\x12\x00R&#x27;UR\x15&quot;</span><br><span class="line">b&quot;&amp;&#x27;&amp;xf\x198 p&gt;-\x19;\x12\x17K&gt;\x05\x04&gt;\x0eCN\x0c\x0c\x01f\x06T\x13&quot;</span><br><span class="line">b&#x27;2i(1#\x15#1#,a\x1b2A\x02\x1b/\x1b\x16&lt;\x1eQ\x1a\r\n\x1cf\x02Y\x14&#x27;</span><br><span class="line">b&#x27;%,c8/\r(0|\x7f(\x1at\x15\x0b\x0e\x7f\x1a\x1b&gt;\x13_\x19D\n\x14f\x11T\x1c&#x27;</span><br><span class="line">b&#x27;;(7t2\x13&quot;\&#x27;5\x7f6\x1c;A\x0f\x02)\x0c_\x7f\x18BN\x0c\x04\x04#U]\x14&#x27;</span><br><span class="line">b&#x27;293&amp;#\x18$5$67\x11t\x0e\x05K+\x01\x16\x7f\x1aU\x0f\n\x0c\x1c!U^\x1b&#x27;</span><br><span class="line">b&#x27;7&amp;m\x96\xe6vG\x19?,5T;\x07C\x1e,ES7\x18G\x0b\x12\x00\x00jUE\x1c&#x27;</span><br><span class="line">b&quot;!ec &#x27;\x10(t&lt;6&#x27;\x11t\x07\x0c\x19\x7f\x0e\x01&gt;\x19D\x0b\x00KR\x11\x10\x11\x16&quot;</span><br><span class="line">b&quot;&#x27;:c$#\t 5&gt;:/\x00t\x12\x13\x02-\x00\x07*\x16\\N\x12\x04\x1e3\x10BS&quot;</span><br><span class="line">b&#x27;&lt;;c&lt;/\x08m81,5T&lt;\x0e\x16\x19,GS\x16WC\x1e\x01\x04\x19jU^\x1b&#x27;</span><br><span class="line">b&#x27;2\&#x27;$1&quot;Um\x1c5\x7f#\x117\x0e\x0e\x0e,I\x1e0\x05UN\x05\x15\x024\x10R\x14&#x27;</span><br><span class="line">b&quot;s&#x27;, #\x1fm 8&gt;5T \t\x0c\x18:I\x047\x18\x10\x02\r\x13\x17jU^\x0f&quot;</span><br><span class="line">b&quot;&#x27;!c8/\x0f985\x7f \x04$\x13\x06\x086\x08\x076\x18^@D,\x06f\x1cB]&quot;</span><br><span class="line">b&#x27;2=+t$\t$:7\x7f T9\x04\x0f\x070\x1eS,\x00U\x0b\x10\x0b\x175\x06\x11\t&#x27;</span><br><span class="line">b&quot;&lt;$c9&#x27;\x10(t$7$T2\x14\x0f\x07:\x1a\x07\x7f\x02C\x0bD\n\x14f\x01Y\x18&quot;</span><br><span class="line">b&#x27; !&quot;0)\x0cm;6\x7f%\x115\x15\x0bK=\x1b\x1a1\x10\x10\x0fD\x08\x17*\x19^\n&#x27;</span><br><span class="line">b&#x27;6i,8&quot;[&gt; ?-8T;\x07C\x050\x1dS=\x12Y\x00\x03E\x154\x14E\x18&#x27;</span><br><span class="line">b&#x27;:=&amp;0f\x1a#0p,1\x117\x08\x05\x02:\rS+\x1e]\x0bD\x11\x1df\x19X\x0b&#x27;</span><br><span class="line">b&#x27; i4;3\x17)t=&gt;*\x11t\t\n\x06\x7f\x04\x1c-\x12\x10\x0f\x14\x15\x00#\x16X\x1c&#x27;</span><br><span class="line">b&#x27;6gc\x03#[&gt;&lt;?*-\x10t\r\n\x1d:I\x16&gt;\x14XN\x00\x04\x0bf\x02X\t&#x27;</span><br><span class="line">b&quot;:&#x27;7-f\x14+t921\x11:\x05\n\x058I\x17:\x16D\x06J\xa7\xd2K\x7fx\x13&quot;</span><br><span class="line">b&#x27;7i&quot;0)\x0b9t$7$T\x11\x11\n\x08*\x1b\x16&gt;\x19\x10\x03\x0b\x11\x06)U^\x1b&#x27;</span><br><span class="line">b&#x27;!:mt\x0f[&gt;$5&gt;*Xt\x0e\x05K&lt;\x06\x06-\x04UBD\n\x14f\x13C\x18&#x27;</span><br><span class="line">b&#x27; =,&amp;/\x1e&gt;t91a\x03&lt;\x08\x00\x03\x7f\x1d\x1b:WX\x0b\x16\nR.\x14U]&#x27;</span><br><span class="line">b&#x27;&#125;i\x10!%\x13m5&gt;\x7f \x00 \x08\x17\x1e;\x0cS(\x18E\x02\x00E\x17+\x05Y\x1c&#x27;</span><br><span class="line">b&#x27;&#125;\x8b\xe3YL2m&lt;1)$T;\x07\x17\x0e1I\x077\x18E\t\x0c\x11R/\x01\x11\n&#x27;</span><br><span class="line">b&#x27;?&gt;&quot;-5[:1p($\x061A\n\x05+\x0c\x01:\x04D\x0b\x00E\x1b(UU\x14&#x27;</span><br><span class="line">b&quot;6;75/\x159-p0&#x27;T=\x0c\x13\x0e1\r\x1a1\x10\x10\n\x01\x04\x06.[\xf3\xdd&quot;</span><br><span class="line">b&#x27;6:c=5[.&lt;11&amp;\x110OC#:I\x11:\x14_\x03\x01\x16R+\x1aC\x18&#x27;</span><br><span class="line">b&#x27;&lt;&lt;0t)\x1dm&lt;5&gt;-\x00&lt;A\x16\x05+\x00\x1f\x7f\x00UN\x05\x17\x17f\x1c]\x11&#x27;</span><br><span class="line">b&quot; &amp; =&#x27;\x0f$;&gt;,a\x07&lt;\x0e\x16\x07;I\x04:WS\x1c\x0b\x12\x16f\x1c_\t&quot;</span><br><span class="line">b&quot;s\x00c&lt;&#x27;\r(t$7.\x013\t\x17K6\x1dS(\x18E\x02\x00E\x10#UP\x13&quot;</span><br><span class="line">b&#x27;\x7fi!!2[,8=02\x00t\x00\x0f\x1c&gt;\x10\x00\x7f\x1fY\x1dD\x16\x17(\x06T]&#x27;</span><br><span class="line">b&#x27;s:+;4\x0fm5#\x7fs@t\t\x0c\x1e-\x1a]\x7f5E\x1aD\x04\x1e1\x14H\x0e&#x27;</span><br><span class="line">b&#x27;;,&quot;&amp;/\x15*xp0/\x18-A\x17\x03:I\x113\x1e^\nD\x17\x17\&#x27;\x19X\x07&#x27;</span><br><span class="line">b&#x27;s?&quot;83\x1e&gt;zp\x165T&lt;\x00\x10K0\x0f\x07:\x19\x10\x0c\x01\x00\x1cf\x1b^\t&#x27;</span><br><span class="line">b&#x27;s=+1f\x13(&amp;?\x7f)\x150A\x0c\x053\x10S&gt;W\\\x07\t\x0c\x06#\x11\x11\x1c&#x27;</span><br><span class="line">b&#x27;;i,!2[$:p&gt;/T1\x0f\x07\x07:\x1a\x00\x7f\x01Y\x1d\x10\x04\\f&amp;^]&#x27;</span><br><span class="line">b&#x27;2=c .\x1em81,5T9\x08\r\x1e+\x0cS=\x0e\x10\x1d\x0b\x08\x17f\x06E\x0f&#x27;</span><br><span class="line">b&quot;7i.;(\x0f%&#x27;p&gt;/\x10t\x18\x06\n-\x1aS+\x18\x10\r\x0b\x08\x17hUe\x15&quot;</span><br><span class="line">b&#x27;=-c&lt;/\x08m81,5T0\x00\x1a\x18\x7f\x06\x01\x7f\x1fY\x1dD\t\x135\x01\x11\x15&#x27;</span><br><span class="line">b&#x27;\&#x27;!&amp;-f\x1f&quot;z\x92\xffL~\x19\x0e\x10\x1f\x7f\x06\x15\x7f\x02CBD\r\x1d1\x10G\x18&#x27;</span><br><span class="line">b&#x27;6?&amp;&amp;?\x0f%=&gt;8a\x00&lt;\x04\x1aK;\x06]\x9d\xd7=d)\n\x012U^\x1b&#x27;</span><br><span class="line">b&#x27;6i&quot;&amp;#[9&lt;?,$Xt\x0e\x05K&lt;\x06\x06-\x04UBD\x12\x1a)UF\x12&#x27;</span><br><span class="line">b&#x27;s\x00c5+[,2&quot;&gt;(\x10xA\x00\x03&gt;\x1b\x12&lt;\x03U\x1c\r\x1f\x175UE\x15&#x27;</span><br><span class="line">b&#x27;s=&quot;?#[!=6:a\x12;\x13C\x0c-\x08\x1d+\x12T@D2\x17f\x1e_\x12&#x27;</span><br><span class="line">b&quot;&#125;i\n f\x13,&#x27;p0&#x27;\x001\x0fC\t:\x0c\x1d\x7f\x19_\x1a\x01\x01R2\x1dP\t&quot;</span><br><span class="line">b&#x27;s!,!4\x08m5#\x7f,\x1b&amp;\x15\x02\x07\x7f\x0b\x166\x19W\x1dHE\x05.\x14E]&#x27;</span><br><span class="line">b&#x27;!&amp;(1f\x14+t603\x00!\x0f\x06G\x7f\x0b\x06+WQ\x02\t\n\x012UP\x11&#x27;</span><br><span class="line">b&quot;=i4&lt;/\x18%t$7$T&lt;\x04\x11\x04\x7f\x01\x12;W_\x00\x08\x1cR&#x27;U]\x14&quot;</span><br><span class="line">b&quot;6i&#x27;5?[:1p24\x07 A\x07\x02:ES=\x02DN\x11\x16\x07&#x27;\x19]\x04&quot;</span><br><span class="line">b&#x27;7i.5-\x1em&lt;92a\x19;\x13\x06K&gt;\x19\x03-\x12S\x07\x05\x11\x1b0\x10\x11\x12&#x27;</span><br><span class="line">b&#x27;#;&amp;7/\x1a91p7$\x15&amp;\x08\r\x0csI\x1c1\x1bIN\x10\r\x17f\x17]\x14&#x27;</span><br><span class="line">b&#x27;? %1f\x1a#0p65\x07t\x11\x06\x192\x08\x1d:\x19DN\x17\x15\x1b4\x1cE\x08&#x27;</span><br><span class="line">b&#x27;\x1ai+50\x1em;6+$\x1at\x15\x0b\x04*\x0e\x1b+WY\x1aD\x12\x1d3\x19U]&#x27;</span><br><span class="line">b&#x27;s&gt;,!*\x1fm914$T&lt;\x08\x0eK2\x06\x01:WQ\x1e\x14\x17\x17%\x1cP\t&#x27;</span><br><span class="line">b&quot;0;*9/\x15,8#\x7f6\x1c;\x12\x06K,\x19\x1b:\x05UN\x0b\x03R&#x27;\x16E\x14&quot;</span><br><span class="line">b&#x27;?0c5&quot;\x0e! p3(\x121OC/&gt;\x1b\x181\x12C\x1dD\x12\x1d3\x19U]&#x27;</span><br><span class="line">b&#x27;&gt;,1&amp;?\x99\xcd\xc9~\x7f\x03\x01 A\x0e\x04,\x1dS/\x12_\x1e\x08\x00R1\x1aD\x11&#x27;</span><br><span class="line">b&quot;s:+;3\x17)t&#x27;:a\x17&amp;\x0e\x14\x0f\x7f\x00\x1d+\x18\x10\x1a\x0c\n\x01#U]\x1c&quot;</span><br><span class="line">b&quot;200t&#x27;\x0fm&#x27;?2$T \x08\x0e\x0e\x7f\r\x06-\x1e^\tD\r\x1b5UT\x1c&quot;</span><br><span class="line">b&#x27;s&amp;%t5\x12*&lt;$da\x07=\r\x06\x05&lt;\x0cS(\x18E\x02\x00E\x06#\x14R\x15&#x27;</span><br><span class="line">b&#x27;\x00&lt; &lt;f\x089;&quot;6$\x07t\x12\x06\x1f\x7f\x1c\x00\x7f\x03X\x07\n\x0e\x1b(\x12\x1d]&#x27;</span><br><span class="line">b&quot;&#x27; .15[,&#x27;p,)\x1b&amp;\x15C\n,IAkWX\x01\x11\x17\x01hUs\x08&quot;</span><br><span class="line">b&quot;2*682\x12(&#x27;~\x7f\x15\x1c1\x08\x11K:\x10\x16,WQ\x00\x00E\x17&#x27;\x07B]&quot;</span><br><span class="line">b&#x27;2$&amp;t)\x17)t#+.\x06-A\x0c\r\x7f\x07\x1c+WR\x0b\r\x0b\x15f\x12C\x1c&#x27;</span><br><span class="line">b&quot;2;ot5\x14 1$6,\x11&#x27;A\x02\x18\x7f\x1a\x1b0\x05DN\x05\x16RtA\x11\x15&quot;</span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line">from tqdm import *</span><br><span class="line"></span><br><span class="line">with open(&quot;result.log&quot;,&quot;r&quot;) as f:</span><br><span class="line">    f=f.readlines()</span><br><span class="line"># print(f)</span><br><span class="line"></span><br><span class="line">strxor = lambda x,y: bytes([a^b for a,b in zip(x,y)])</span><br><span class="line"></span><br><span class="line">result=[eval(i)for i in f]    # 评估</span><br><span class="line"># print(result)</span><br><span class="line">c=[]</span><br><span class="line">for i in result:</span><br><span class="line">    c.append(strxor(b&#x27;SICTF&#123;&#x27;,i[:6]))</span><br><span class="line"></span><br><span class="line"># 爆破</span><br><span class="line">re=[]</span><br><span class="line">for x in tqdm(c):</span><br><span class="line">    for i in result:</span><br><span class="line">        for j in range(0,len(i)-6):</span><br><span class="line">            tmp=strxor(i[j:j+6],x)</span><br><span class="line">            if len(str(tmp)) == 9:</span><br><span class="line">                re.append(tmp.decode())</span><br><span class="line"># print(re)</span><br><span class="line"></span><br><span class="line"># flag拼接</span><br><span class="line">flag=&#x27;SICTF&#123;&#x27;</span><br><span class="line">for _ in trange(30-7):</span><br><span class="line">    col=[]</span><br><span class="line">    for i in re:</span><br><span class="line">        # print(i[:5])</span><br><span class="line">        if flag[-5:] == i[:5]:</span><br><span class="line">            col.append(i[-1])</span><br><span class="line">    K = Counter(col)</span><br><span class="line">    # print(K)</span><br><span class="line">    flag = flag + K.most_common()[0][0]</span><br><span class="line">    # print(flag)</span><br><span class="line">print(flag+&#x27;&#125;&#x27;)</span><br></pre></td></tr></table></figure><h2 id="easy_coppersmith">Easy_CopperSmith</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from flag import flag</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p * q</span><br><span class="line">e = 65537</span><br><span class="line">leak = p &gt;&gt; 230</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line">print(n)</span><br><span class="line">print(leak)</span><br><span class="line">print(c)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">114007680041157617250208809154392208683967639953423906669116998085115503737001019559692895227927818755160444076128820965038044269092587109196557720941716578025622244634385547194563001079609897387390680250570961313174656874665690193604984942452581886657386063927035039087208310041149977622001887997061312418381</span><br><span class="line">6833525680083767201563383553257365403889275861180069149272377788671845720921410137177</span><br><span class="line">87627846271126693177889082381507430884663777705438987267317070845965070209704910716182088690758208915234427170455157948022843849997441546596567189456637997191173043345521331111329110083529853409188141263211030032553825858341099759209550785745319223409181813931086979471131074015406202979668575990074985441810</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>很明显是<span class="math inline">\(P\)</span>高位攻击。但注意的是，当满足以下条件时才能<span class="math inline">\(copper\)</span>, <span class="math display">\[k=\frac{p未知比特位}{p总比特位}\leq0.44\]</span> 当不满足这个条件且<span class="math inline">\(k\)</span>与0.44很接近时，<strong>把<span class="math inline">\(f.small_roots(X,beta,epsilon)\)</span>中的<span class="math inline">\(epsilon\)</span>参数改为0.01，即最小的时候，最有可能恢复<span class="math inline">\(p\)</span></strong></p><p>在本题中， <span class="math display">\[k=\frac{230}{512}=0.4492\]</span> 所以需要设置<span class="math inline">\(epsilon\)</span>参数.</p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#sage</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line">n = 114007680041157617250208809154392208683967639953423906669116998085115503737001019559692895227927818755160444076128820965038044269092587109196557720941716578025622244634385547194563001079609897387390680250570961313174656874665690193604984942452581886657386063927035039087208310041149977622001887997061312418381</span><br><span class="line">hint = 6833525680083767201563383553257365403889275861180069149272377788671845720921410137177</span><br><span class="line">c = 87627846271126693177889082381507430884663777705438987267317070845965070209704910716182088690758208915234427170455157948022843849997441546596567189456637997191173043345521331111329110083529853409188141263211030032553825858341099759209550785745319223409181813931086979471131074015406202979668575990074985441810</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">p_high = (hint&lt;&lt;230)</span><br><span class="line"># print(p_high)</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = p_high + x</span><br><span class="line">x = f.small_roots(X=2^230, beta=0.4,epsilon=0.01)[0]</span><br><span class="line">p = p_high+int(x)</span><br><span class="line">q = n//p</span><br><span class="line">print(f&quot;p = &#123;p&#125;&quot;)</span><br><span class="line">print(f&quot;q = &#123;q&#125;&quot;)</span><br><span class="line">d = gmpy2.invert(e,(p-1)*(q-1))</span><br><span class="line">m = gmpy2.powmod(c,d,n)</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h2 id="签到题来咯">签到题来咯！</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from secret import flag</span><br><span class="line">from  Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">e = getPrime(10)</span><br><span class="line">n = p*q</span><br><span class="line">c1 = pow(114*m+2333,e,n)</span><br><span class="line">c2 = pow(514*m+4555,e,n)</span><br><span class="line">print(f&#x27;n = &#123;n&#125;&#x27;)</span><br><span class="line">print(f&#x27;c1 = &#123;c1&#125;&#x27;)</span><br><span class="line">print(f&#x27;c2 = &#123;c2&#125;&#x27;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 18993579800590288733556762316465854395650778003397512624355925069287661487515652428099677335464809283955351330659278915073219733930542167360381688856732762552737791137784222098296804826261681852699742456526979985201331982720936091963830799430264680941164508709453794113576607749669278887105809727027129736803614327631979056934906547015919204770702496676692691248702461766117271815398943842909579917102217310779431999448597899109808086655029624478062317317442297276087073653945439820988375066353157221370129064423613949039895822016206336117081475698987326594199181180346821431242733826487765566154350269651592993856883</span><br><span class="line">c1 = 3089900890429368903963127778258893993015616003863275300568951378177309984878857933740319974151823410060583527905656182419531008417050246901514691111335764182779077027419410717272164998075313101695833565450587029584857433998627248705518025411896438130004108810308599666206694770859843696952378804678690327442746359836105117371144846629293505396610982407985241783168161504309420302314102538231774470927864959064261347913286659384383565379900391857812482728653358741387072374314243068833590379370244368317200796927931678203916569721211768082289529948017340699194622234734381555103898784827642197721866114583358940604520</span><br><span class="line">c2 = 6062491672599671503583327431533992487890060173533816222838721749216161789662841049274959778509684968479022417053571624473283543736981267659104310293237792925201009775193492423025040929132360886500863823523629213703533794348606076463773478200331006341206053010168741302440409050344170767489936681627020501853981450212305108039373119567034948781143698613084550376070802084805644270376620484786155554275798939105737707005991882264123315436368611647275530607811665999620394422672764116158492214128572456571553281799359243174598812137554860109807481900330449364878168308833006964726761878461761560543284533578701661413931</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>感官上能看出<span class="math inline">\(m1和m2\)</span>存在某种<strong>线性关系</strong>。所以是<strong>相关信息攻击(<span class="math inline">\(Franklin-Reiter\)</span>)</strong></p><p>简单来说，相关信息攻击就是<strong>如果两个信息之间存在某种线性关系，并且在相同的<span class="math inline">\(n\)</span>和<span class="math inline">\(e\)</span>下进行<span class="math inline">\(RSA\)</span>加密，那么就有可能恢复出这两个消息</strong>.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果两条消息之间仅存在某种线性关系</span><br><span class="line"></span><br><span class="line">并且在相同的(N,e)下进行RSA加密</span><br><span class="line"></span><br><span class="line">那么就有可能同时恢复它们</span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">m2 = a * m1 + b,其中b!=0</span><br><span class="line"></span><br><span class="line">c1 = pow(m1,e,n)</span><br><span class="line"></span><br><span class="line">c2 = pow(m2,e,n)</span><br><span class="line"></span><br><span class="line">其中a,b,c1,c2,e,n都已知，那么m1,m2可被破解</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/XiongSiqi_blog/article/details/130978226">Franklin-Reiter相关消息攻击</a></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import binascii</span><br><span class="line">n = 18993579800590288733556762316465854395650778003397512624355925069287661487515652428099677335464809283955351330659278915073219733930542167360381688856732762552737791137784222098296804826261681852699742456526979985201331982720936091963830799430264680941164508709453794113576607749669278887105809727027129736803614327631979056934906547015919204770702496676692691248702461766117271815398943842909579917102217310779431999448597899109808086655029624478062317317442297276087073653945439820988375066353157221370129064423613949039895822016206336117081475698987326594199181180346821431242733826487765566154350269651592993856883</span><br><span class="line">c1 = 3089900890429368903963127778258893993015616003863275300568951378177309984878857933740319974151823410060583527905656182419531008417050246901514691111335764182779077027419410717272164998075313101695833565450587029584857433998627248705518025411896438130004108810308599666206694770859843696952378804678690327442746359836105117371144846629293505396610982407985241783168161504309420302314102538231774470927864959064261347913286659384383565379900391857812482728653358741387072374314243068833590379370244368317200796927931678203916569721211768082289529948017340699194622234734381555103898784827642197721866114583358940604520</span><br><span class="line">c2 = 6062491672599671503583327431533992487890060173533816222838721749216161789662841049274959778509684968479022417053571624473283543736981267659104310293237792925201009775193492423025040929132360886500863823523629213703533794348606076463773478200331006341206053010168741302440409050344170767489936681627020501853981450212305108039373119567034948781143698613084550376070802084805644270376620484786155554275798939105737707005991882264123315436368611647275530607811665999620394422672764116158492214128572456571553281799359243174598812137554860109807481900330449364878168308833006964726761878461761560543284533578701661413931</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def franklinReiter(n,e,c1,c2):</span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    g1 = (114*x+2333)^e - c1</span><br><span class="line">    g2 = (514*x+4555)^e - c2</span><br><span class="line"></span><br><span class="line">    def gcd(g1, g2):</span><br><span class="line">        while g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        return g1.monic()</span><br><span class="line">    return -gcd(g1, g2)[0]</span><br><span class="line"></span><br><span class="line">def get_all_10_bit_primes():</span><br><span class="line">    return [i for i in range(2**9, 2**10) if isPrime(i)]</span><br><span class="line"></span><br><span class="line">e_all = get_all_10_bit_primes()</span><br><span class="line">print(e_all)</span><br><span class="line">for e in e_all:</span><br><span class="line">    m=franklinReiter(n,e,c1,c2)</span><br><span class="line">    flag = long_to_bytes(int(m))</span><br><span class="line">    if b&#x27;SICTF&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">print(&quot;over&quot;)</span><br><span class="line"># SICTF&#123;hhh!!franklin_reiter_is_easy&#125;</span><br></pre></td></tr></table></figure><h2 id="small_e">small_e</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import uuid</span><br><span class="line">flag=&quot;SICTF&#123;&quot;+str(uuid.uuid4())+&quot;&#125;&quot;</span><br><span class="line">m=libnum.s2n(flag)</span><br><span class="line">p=getPrime(1024)</span><br><span class="line">q=getPrime(1024)</span><br><span class="line">n=p*q</span><br><span class="line">e=3</span><br><span class="line">c=pow(m,e,n)</span><br><span class="line">m1=((m&gt;&gt;60)&lt;&lt;60)</span><br><span class="line">print(&quot;n=&quot;,n)</span><br><span class="line">print(&quot;e=&quot;,e)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br><span class="line">print(&quot;((m&gt;&gt;60)&lt;&lt;60)=&quot;,m1)</span><br><span class="line">print(flag)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n= 23407088262641313744603678186127228163189328033499381357614318160776774708961658114505773173784501557046914457908828086210961235530240151825359345210845219656000760996670856300710703016947799649686427460688236465568188205550456293373157997725204643414082796492333552579250010906010553831060540937802882205118399938918764313169385349293602085310111289583058965780887097301702677087443291977479125263301000328313103296364864396361278863921717374909215078711198899810620522933994481419395021233240234478331179727351050575360886334237633420906629984625441302945112631166021776379103081857393866576659121443879590011160797</span><br><span class="line">e= 3</span><br><span class="line">c= 1584727211980974717747362694412040878682966138197627512650829607105625096823456063149392973232737929737200028676411430124019573130595696272668927725536797627059576270068695792221537212669276826952363636924278717182163166234322320044764324434683614360641636360301452618063418349310497430566465329766916213742181</span><br><span class="line">((m&gt;&gt;60)&lt;&lt;60)= 11658736990073967239197168945911788935424691658202162501032766529463315401599017877851823976178979438592</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(e=3\)</span>很明显是<strong>低加密指数攻击</strong>，直接上脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">n= 23407088262641313744603678186127228163189328033499381357614318160776774708961658114505773173784501557046914457908828086210961235530240151825359345210845219656000760996670856300710703016947799649686427460688236465568188205550456293373157997725204643414082796492333552579250010906010553831060540937802882205118399938918764313169385349293602085310111289583058965780887097301702677087443291977479125263301000328313103296364864396361278863921717374909215078711198899810620522933994481419395021233240234478331179727351050575360886334237633420906629984625441302945112631166021776379103081857393866576659121443879590011160797</span><br><span class="line">e= 3</span><br><span class="line">c= 1584727211980974717747362694412040878682966138197627512650829607105625096823456063149392973232737929737200028676411430124019573130595696272668927725536797627059576270068695792221537212669276826952363636924278717182163166234322320044764324434683614360641636360301452618063418349310497430566465329766916213742181</span><br><span class="line">k = 0</span><br><span class="line">while 1:</span><br><span class="line">    s = gmpy2.iroot(c+k*n, e)</span><br><span class="line">    if s[1]:</span><br><span class="line">        print(libnum.n2s(int(s[0])))</span><br><span class="line">        break</span><br><span class="line">    k += 1</span><br><span class="line"># SICTF&#123;2ca8e589-4a31-4909-80f0-9ecfc8f8cb37&#125;</span><br></pre></td></tr></table></figure><h2 id="easy_math">easy_math</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from secret import flag</span><br><span class="line">from  Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p * q</span><br><span class="line">e = 65537</span><br><span class="line">hint1 = getPrime(13)*p+getPrime(256)*q</span><br><span class="line">hint2 = getPrime(13)*p+getPrime(256)*q</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line">print(f&#x27;n = &#123;n&#125;&#x27;)</span><br><span class="line">print(f&#x27;hint1 = &#123;hint1&#125;&#x27;)</span><br><span class="line">print(f&#x27;hint2 = &#123;hint2&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 68123067052840097285002963401518347625939222208495512245264898037784706226045178539672509359795737570458454279990340789711761542570505016930986418403583534761200927746744298082254959321108829717070206277856970403191060311901559017372393931121345743640657503994132925993800497309703877076541759570410784984067</span><br><span class="line">hint1 = 564294243979930441832363430202216879765636227726919016842676871868826273613344463155168512928428069316237289920953421495330355385445649203238665802121198919543532254290185502622234014832349396422316629991217252686524462096711723580</span><br><span class="line">hint2 = 484307144682854466149980416084532076579378210225500554261260145338511061452958092407101769145891750844383042274498826787696953308289632616886162073232218214504005935332891893378072083589751354946391146889055039887781077066257013110</span><br><span class="line">c = 57751903193610662622957432730720223801836323458721550133101805763463060486486266309568004721657732742899781400754207249733137375171400440423755473421971160000575072519031824740691618617905549725344323721903857290320737224300672847773455169809689188843070599176261204013341324705808617411345132933937680951713</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>思路：看了题目后，第一反应就是爆破。因为<span class="math inline">\(a_{1},a_{2}\)</span>都是<span class="math inline">\(13bit\)</span>（很小），<span class="math inline">\(b_{1},b_{2}\)</span>都是<span class="math inline">\(256bit\)</span>(很大)，所以这里选择消去<span class="math inline">\(p\)</span>,爆<span class="math inline">\(a_{1},a_{2}\)</span>. <span class="math display">\[\left\{\begin{matrix}hint1 = a_{1}*p+b_{1}*q\\hint2 = a_{2}*p+b_{2}*q\end{matrix}\right.\]</span></p><p><span class="math display">\[\Rightarrow a_{2}*hint2-a_{1}*hint2 = (a_{2}*b_{1}-a_{1}*b_{2})*q = k*q\]</span></p><p>参考：<a href="https://github.com/DownUnderCTF/Challenges_2023_Public/blob/main/crypto/apbq-rsa-i/solve/solv.py">apbq-rsa-i</a></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import itertools</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from tqdm import tqdm</span><br><span class="line">from math import gcd</span><br><span class="line"></span><br><span class="line"># n, c, hints</span><br><span class="line">n = 68123067052840097285002963401518347625939222208495512245264898037784706226045178539672509359795737570458454279990340789711761542570505016930986418403583534761200927746744298082254959321108829717070206277856970403191060311901559017372393931121345743640657503994132925993800497309703877076541759570410784984067</span><br><span class="line">hint1 = 564294243979930441832363430202216879765636227726919016842676871868826273613344463155168512928428069316237289920953421495330355385445649203238665802121198919543532254290185502622234014832349396422316629991217252686524462096711723580</span><br><span class="line">hint2 = 484307144682854466149980416084532076579378210225500554261260145338511061452958092407101769145891750844383042274498826787696953308289632616886162073232218214504005935332891893378072083589751354946391146889055039887781077066257013110</span><br><span class="line">c = 57751903193610662622957432730720223801836323458721550133101805763463060486486266309568004721657732742899781400754207249733137375171400440423755473421971160000575072519031824740691618617905549725344323721903857290320737224300672847773455169809689188843070599176261204013341324705808617411345132933937680951713</span><br><span class="line"></span><br><span class="line">hints = [hint1,hint2]</span><br><span class="line">A = []</span><br><span class="line">for i in range(2**12,2**13):  # 找出13bit的所有素数</span><br><span class="line">    if isPrime(i):</span><br><span class="line">        A.append(i)</span><br><span class="line"></span><br><span class="line"># 爆破</span><br><span class="line">for a1, a2 in tqdm(list(itertools.product(A, repeat=2))):</span><br><span class="line">    kq = gcd(a1 * hints[0] - a2 * hints[1], n)</span><br><span class="line">    if 1 &lt; kq &lt; n:</span><br><span class="line">        print(&#x27;find!&#x27;, kq, a1, a2)</span><br><span class="line">        break</span><br><span class="line">for i in range(2,100):   # 去除因子,求出q</span><br><span class="line">    if kq % i == 0:</span><br><span class="line">        kq //= i</span><br><span class="line">q = kq</span><br><span class="line">p = n // kq</span><br><span class="line">d = pow(0x10001, -1, (p - 1) * (q - 1))</span><br><span class="line">m = pow(c, d, n)</span><br><span class="line">flag = long_to_bytes(m).decode()</span><br><span class="line">print(flag)</span><br><span class="line"># SICTF&#123;452aebb6-9c16-441a-ac42-fc608bf6063f&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云开发</title>
      <link href="/2023/09/08/%E4%BA%91%E5%BC%80%E5%8F%91/"/>
      <url>/2023/09/08/%E4%BA%91%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="认识小程序云开发">认识小程序云开发</h2><h3 id="什么是云开发">什么是云开发</h3><p>云开发（<span class="math inline">\(CloudBase\)</span>）是<strong>云端一体化的后端云服务</strong>，<strong>采用 <span class="math inline">\(serverless\)</span>架构</strong>，免去了移动应用构建中繁琐的服务器搭建和运维。同时云开发提供的静态托管、命令行工具$（CLI）、FlutterSDK <span class="math inline">\(等能力降低了应用开发的门槛。使用云开发可以构建完整的小程序/小游戏、\)</span>H5、Web、移动App$ 等应用。</p><p>我们来理解一下官方定义中的最重要的两个概念：</p><p>云端一体化的后端云服务：说白了就是云开发为开发者提供<strong>完整原生云后端服务支持</strong>，也就是我们开发已经在全部部署好的后端环境中进行，只需要由前端程序员专注于业务逻辑的编写，弱化了后端和运维的概念。</p><p>一站式$ Serverless <span class="math inline">\(服务：\)</span>serverless$即<strong>无服务</strong>，意思就是开发者无需购买数据库、存储等基础设施服务，无需搭建服务器即可使用，云开发已为上述服务提供了完整的云端支持，能轻松实现快速上线与迭代。</p><p><img src="/2023/09/08/%E4%BA%91%E5%BC%80%E5%8F%91/image-20230908173758249-1694165917658-1-1694165921781-3.png"></p><h2 id="云开发的开通">云开发的开通</h2><p>点击开发者工具中的<strong>云开发</strong>，开通云开发。</p><p><img src="/2023/09/08/%E4%BA%91%E5%BC%80%E5%8F%91/image-20230908180036794-1694167245612-5.png"></p><p><img src="/2023/09/08/%E4%BA%91%E5%BC%80%E5%8F%91/image-20230908180130951-1694167299721-7.png"></p><p>创建环境（云服务器）</p><p><img src="/2023/09/08/%E4%BA%91%E5%BC%80%E5%8F%91/image-20230908180438522-1694167486679-9.png"></p><h2 id="云开发的功能">云开发的功能</h2><p>云开发有<strong>云函数、数据库、文件存储、数据分析</strong>四个功能。</p><p>数据分析：可以查看小程序资源调用情况，及时查看小程序运行情况、用户访问情况。</p><p>数据库：云开发使用的云数据库。</p><p>文件存储：存储图片、视频、音频等文件。</p><h2 id="云开发环境的初始化准备">云开发环境的初始化准备</h2><p>在<span class="math inline">\(project.config.json\)</span>中定义云函数的目录</p><p><img src="/2023/09/08/%E4%BA%91%E5%BC%80%E5%8F%91/image-20230909161026654-1694247035028-1.png"></p><p>不要忘了<strong>逗号</strong></p><p>点击<span class="math inline">\(+\)</span>,创建一个和云函数目录同名的目录</p><p><img src="/2023/09/08/%E4%BA%91%E5%BC%80%E5%8F%91/image-20230909161414496-1694247262079-3.png"></p><p>云开发环境初始化</p><p>在<span class="math inline">\(app.js\)</span>文件中，添加如下代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 云开发环境初始化</span><br><span class="line">wx.cloud.init(&#123;</span><br><span class="line">env:&quot;云开发环境id&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/2023/09/08/%E4%BA%91%E5%BC%80%E5%8F%91/image-20230909162838511-1694248126197-5.png"></p>]]></content>
      
      
      <categories>
          
          <category> 云开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023 NSSCTF-收录题</title>
      <link href="/2023/09/04/2023-NSSCTF-%E6%94%B6%E5%BD%95%E9%A2%98/"/>
      <url>/2023/09/04/2023-NSSCTF-%E6%94%B6%E5%BD%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="latticelcg">LatticeLCG</h3><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******************************&#125;&#x27;</span><br><span class="line"></span><br><span class="line">a = getPrime(512)</span><br><span class="line">seed = getPrime(512)</span><br><span class="line">b = bytes_to_long(flag)</span><br><span class="line">n = getPrime(1024)</span><br><span class="line"></span><br><span class="line">e1 = 2333</span><br><span class="line">e2 = 23333</span><br><span class="line">c1 = pow(a,e1,n)</span><br><span class="line">c2 = pow(a,e2,n)</span><br><span class="line"></span><br><span class="line">output = []</span><br><span class="line">for i in range(10):</span><br><span class="line">    seed = (a*seed+b)%n</span><br><span class="line">    output.append(seed)</span><br><span class="line"></span><br><span class="line">print(&quot;c1 = &quot;,c1)</span><br><span class="line">print(&quot;c2 = &quot;,c2)</span><br><span class="line">print(&quot;output1 = &quot;,output[0])</span><br><span class="line">print(&quot;output2 = &quot;,output[1])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = [getPrime(128) for _ in range(20)]</span><br><span class="line">out = []</span><br><span class="line">m = getPrime(64)</span><br><span class="line"></span><br><span class="line">for i in e:</span><br><span class="line">    out.append(pow(m,i,n))</span><br><span class="line"></span><br><span class="line">print(&quot;e=&quot;,e)</span><br><span class="line">print(&quot;out=&quot;,out)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">c1 =  132894829064255831243210470637067717685821770359549730768366345840525257033166172926149293454192143005551270166547902269036843756318967855047301751521125394803373953151753927497701242767032542708689455184991906629946511295108898559666019232955132938245031352553261823905498810285940911315433144300083027795647</span><br><span class="line">c2 =  24086830909813702968855830967174364278115647345064163689290457852025690324300607354444884288995399344650789235347773145941872226843099538451759854505842021844881825309790171852845467221751852440178862638893185965125776165397575087879479327323737686652198357863042305078811580074617322063509435591981140533310</span><br><span class="line">output1 =  54997286032365904331111467760366122947903752273328087460831713533712307510311367648330090376100815622160705007873798883153287827481112070182047111994066594911019010222064952859306742931009422376955635523160546531204043294436812066746785938062292942759004837173423765427628610568097898331237064396308950601636</span><br><span class="line">output2 =  115015764780168428067411132384122324817310808727138440691727747976276050930701648349452842302609389394467134068064132550313721128807222231505312226682756817617177620169804112319332815872107656884931985435898097063491690413460967856530075292289784649593915313885813931026280791070577034075346669028068003251024</span><br><span class="line">e= [297332330847212015073434001239859795661, 247136911662054641479463124065475615181, 269964458627145370722389742095701827701, 270745917671094194052444327351021588037, 254010082507930275771798119457499420531, 219178601856077385518322602059961601013, 226562702503988968288128483964146379529, 236756812424464516919183114495913408541, 330800121752029915693039296018980956519, 244800084005240595691424199440981715431, 171753849214889522920105847094773384191, 175843874533972361422410968920873382741, 326554577162848075059517044795930784993, 181842368629269753698222635712342485771, 221634122983362091660188171985742369561, 314244561819808202322467576330355199409, 286703236198397527318161582654787197007, 298101543059628501506668748374542117409, 304158884506393754601331945634109778837, 227577031261920314010408499530794497453]</span><br><span class="line">out= [100163998802948218573427220530909801629443946118807841130458771881611961921044413091457977957530737347507311468578174294420439883266450142918647561103714976340598499984679873518770686239019753272419975426555435266764099822607336645955391865380657632176223122712125661464370522088500110746571354290680063421912, 123528268396018633078964378145622645321836134964966941909300627704018826667414656614011250938241127521627117348901416042868382174504514240509791471909819407751786633761392047187057200130450960708049681366686147337178110669163142189940397343388837018627392202704211693014162963133958078984558400205296509955066, 50364974727218716170137342348825758682286710377257708196467656986986475658591351848251278364177715325447140300281348027787487944839878770556527568407280736570303345044999352851718908253510696083227344179177110348363623815158409862985684687329665113210373028159714648637297476014803935686233984711925346269925, 9159042298258514259206302054907530984498816597282237786310355131965025367180505822032135021520906576471052417629425493533222088036674196397387325202128095476044308794426593565419139845832998557280786358482011226957053125314152322427131984411160984485669030286331376124575677908877399942011661647598763754231, 83466948172962290899792524342204996697711370224947233607865306692546824512672969402433314856742908546253967225963904395036102408684746619744412073888614033881366518452878344698289278946024167788789718690655953517892282374396760436658422838909903123439370164929347147855359470889455753772857233516742991766128, 72028057477369331020972407277180913909557985390590548305094935208898254733240351763155769013959589016793318772858662702447133499307826143247356049051993727167694036585280387890126287679890730586145740176250715386149857291210207281073772478229355625725300592003798974298248102432508449566953296818450441875311, 63397152736399466888877444377156185012692670493456346196278062009641363047685720620967313379507212944658351683022480839941265221126018392433078546696140135677499181555082643172378488800458657825640013090182171355299282023794908520172571785687147143015581400891531296496177973817400317905868361800342940667657, 45427004823510815929685208038284324980662968275105063862891077759131069014314933978878667052450145039482242546093735499108826130367476890384431317243013990394189191560941678120985717370542332803012619694821129395559214706968432476548145608291516176910849698455496733056096163035964057523545705356926187216133, 85046100612081858546755294340770681541320509587396377967875404950325314121709046137842413744740490231945105758075761946555179595664901813127463402854440384657046429776033129391138370272524736543471909307910018577738207910417672603889922445435939876023878220177983424547612635006926243055642166274730894301704, 5833380233103086014860892228744764647016585478949686583145531659689295506666493518453642500086277427538189091865461553097914845680665917702500908205558454036911757659426809969367680394533585635383007758339917554453268182491874683638880986360065633842854622244953985055815937671635222264056071882344388307409, 83587615309194701727032548415548847571046191382552371312058083137102227325098839286526833147951063338204327145093831238962818333112251936853329663907079943414231588222256242520221314528944937229985997926851198158564313703719031124442094987245466116488897263358510493905440842917634723859176839440753120904481, 108651960334634726889543063749359050688114025706494125848785084643330096858725917513596985853593252388835207675036982640195609499739937405655156895161071906340785173459426867946058638393154997931747445494284445204735492709747637173698383609764016673932827648159152658645291248613736662020472251048171789274368, 118612010487916657134965416492319303083994743753602531817008130269546146141506819718265549648441671373744766173780682168587021797626910931105508317440664521595783406848956221465897709761805869130021172013000282497881581247777388315282629463546261696169893882772397797722134711444928443061384985458691749569847, 106808406616890955924408992591724627593882118490933791849624747503316110669154243209826761617940864170830792705070618439466645580274835929100331418955890808763286193770831205511071440703609240364726061677822134370309018443508205980554831705850988319397384130044484586798585896460152167042282847992593429629533, 88091869606421350393441194783722851111189272445506506936925797213395319937783082680078622732926273935980894566775394134783157488360516905477700601820480975112122167589887641130656305741351643175495552454293030309247254533571254198691204714097846510872592569447050033289483493274672346210063885124570695832880, 94400859500860667431780782962782396345261822402898708716634581228428633704975879685572548692997007974004673676539496590659276952154740096463133011458100387006276325192223993452314873089466451613079029429327880672384210802191677586975844471189127835578979108767548290181668434770385199468588493042256788539610, 76177813724283720012398394789596589415486093955132688784865364048503447246391866424200071522136707581280434193680972230914105236504028522288780213089260160776489804587209115330412067560802680789338779056583047491942817016437672075192528508677997165703606520158178725128251694801612417667440677124932361973397, 17188209523466762369281362386525396145127294763502094183797065621821932913685690176344514910405677170931795652509426794846131051983826422536084073462084935517166603832542862106287058675490933197600813710203114108790043880150305327523679949543592622443904084453387396870899883324751789625806819506542619123964, 120007173989070249117019147454557020213723707722383599019972471016186584968096445904023372671513462965078400715365736756710078805039115601609874780421117795585342458478316236202328120583456334489780231976628584606042971207759763658961365139429661536955996519512283283500790612975034779837647053750631763512799, 18797057418663411295612229938999282286746920748194349166509084258061650142260043277698907538088835210620841171754186980908772147495732980563542600139935202965632319542217264685208215907551992891370166006725534397313373079841419662622936316343820775075897977228084528246337988431658221881343556854053475137330]</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>题目已经提示考的是<span class="math inline">\(Lattice\)</span>和<span class="math inline">\(LCG\)</span>了，打开题目附件一看。这个题似乎和昨天蓝帽杯是类似的。可惜还是没有拿到血。</p><p>先求模数<span class="math inline">\(n\)</span>.题目给了20组 <span class="math inline">\(out[i] = m^{e_{i}}\textbf{ }mod\textbf{}n\)</span>,考虑存在一个线性组合<span class="math inline">\(a_{1}e_{1}+a_{2}e_{2}+...+a_{n}e_{n}=0\)</span>,</p><p>于是便有<span class="math inline">\(\prod_{i=1}^{n}out_{i}^{a_{i}}=m^{\sum_{i=1}^{n}a_{i}e_{i}}=m^{0}=1\textbf{}mod\textbf{ }n\)</span></p><p>如果有这样的<span class="math inline">\(a_{1},a_{2},...,a_{n}\)</span>,我们就可以通过<span class="math inline">\(gcd\)</span>求出<span class="math inline">\(n\)</span>,</p><p>构造格， <span class="math display">\[\begin{pmatrix}1 &amp;0  &amp;...  &amp;0 &amp; Kc_{1}\\0 &amp;1  &amp;... &amp;0 &amp; Kc_{2}\\...&amp; ... &amp; ... &amp;... &amp;...\\0&amp;0  &amp;... &amp;1 &amp;Kc_{n}\end{pmatrix}\]</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">es= [297332330847212015073434001239859795661, 247136911662054641479463124065475615181, 269964458627145370722389742095701827701, 270745917671094194052444327351021588037, 254010082507930275771798119457499420531, 219178601856077385518322602059961601013, 226562702503988968288128483964146379529, 236756812424464516919183114495913408541, 330800121752029915693039296018980956519, 244800084005240595691424199440981715431, 171753849214889522920105847094773384191, 175843874533972361422410968920873382741, 326554577162848075059517044795930784993, 181842368629269753698222635712342485771, 221634122983362091660188171985742369561, 314244561819808202322467576330355199409, 286703236198397527318161582654787197007, 298101543059628501506668748374542117409, 304158884506393754601331945634109778837, 227577031261920314010408499530794497453]</span><br><span class="line">cs= [100163998802948218573427220530909801629443946118807841130458771881611961921044413091457977957530737347507311468578174294420439883266450142918647561103714976340598499984679873518770686239019753272419975426555435266764099822607336645955391865380657632176223122712125661464370522088500110746571354290680063421912, 123528268396018633078964378145622645321836134964966941909300627704018826667414656614011250938241127521627117348901416042868382174504514240509791471909819407751786633761392047187057200130450960708049681366686147337178110669163142189940397343388837018627392202704211693014162963133958078984558400205296509955066, 50364974727218716170137342348825758682286710377257708196467656986986475658591351848251278364177715325447140300281348027787487944839878770556527568407280736570303345044999352851718908253510696083227344179177110348363623815158409862985684687329665113210373028159714648637297476014803935686233984711925346269925, 9159042298258514259206302054907530984498816597282237786310355131965025367180505822032135021520906576471052417629425493533222088036674196397387325202128095476044308794426593565419139845832998557280786358482011226957053125314152322427131984411160984485669030286331376124575677908877399942011661647598763754231, 83466948172962290899792524342204996697711370224947233607865306692546824512672969402433314856742908546253967225963904395036102408684746619744412073888614033881366518452878344698289278946024167788789718690655953517892282374396760436658422838909903123439370164929347147855359470889455753772857233516742991766128, 72028057477369331020972407277180913909557985390590548305094935208898254733240351763155769013959589016793318772858662702447133499307826143247356049051993727167694036585280387890126287679890730586145740176250715386149857291210207281073772478229355625725300592003798974298248102432508449566953296818450441875311, 63397152736399466888877444377156185012692670493456346196278062009641363047685720620967313379507212944658351683022480839941265221126018392433078546696140135677499181555082643172378488800458657825640013090182171355299282023794908520172571785687147143015581400891531296496177973817400317905868361800342940667657, 45427004823510815929685208038284324980662968275105063862891077759131069014314933978878667052450145039482242546093735499108826130367476890384431317243013990394189191560941678120985717370542332803012619694821129395559214706968432476548145608291516176910849698455496733056096163035964057523545705356926187216133, 85046100612081858546755294340770681541320509587396377967875404950325314121709046137842413744740490231945105758075761946555179595664901813127463402854440384657046429776033129391138370272524736543471909307910018577738207910417672603889922445435939876023878220177983424547612635006926243055642166274730894301704, 5833380233103086014860892228744764647016585478949686583145531659689295506666493518453642500086277427538189091865461553097914845680665917702500908205558454036911757659426809969367680394533585635383007758339917554453268182491874683638880986360065633842854622244953985055815937671635222264056071882344388307409, 83587615309194701727032548415548847571046191382552371312058083137102227325098839286526833147951063338204327145093831238962818333112251936853329663907079943414231588222256242520221314528944937229985997926851198158564313703719031124442094987245466116488897263358510493905440842917634723859176839440753120904481, 108651960334634726889543063749359050688114025706494125848785084643330096858725917513596985853593252388835207675036982640195609499739937405655156895161071906340785173459426867946058638393154997931747445494284445204735492709747637173698383609764016673932827648159152658645291248613736662020472251048171789274368, 118612010487916657134965416492319303083994743753602531817008130269546146141506819718265549648441671373744766173780682168587021797626910931105508317440664521595783406848956221465897709761805869130021172013000282497881581247777388315282629463546261696169893882772397797722134711444928443061384985458691749569847, 106808406616890955924408992591724627593882118490933791849624747503316110669154243209826761617940864170830792705070618439466645580274835929100331418955890808763286193770831205511071440703609240364726061677822134370309018443508205980554831705850988319397384130044484586798585896460152167042282847992593429629533, 88091869606421350393441194783722851111189272445506506936925797213395319937783082680078622732926273935980894566775394134783157488360516905477700601820480975112122167589887641130656305741351643175495552454293030309247254533571254198691204714097846510872592569447050033289483493274672346210063885124570695832880, 94400859500860667431780782962782396345261822402898708716634581228428633704975879685572548692997007974004673676539496590659276952154740096463133011458100387006276325192223993452314873089466451613079029429327880672384210802191677586975844471189127835578979108767548290181668434770385199468588493042256788539610, 76177813724283720012398394789596589415486093955132688784865364048503447246391866424200071522136707581280434193680972230914105236504028522288780213089260160776489804587209115330412067560802680789338779056583047491942817016437672075192528508677997165703606520158178725128251694801612417667440677124932361973397, 17188209523466762369281362386525396145127294763502094183797065621821932913685690176344514910405677170931795652509426794846131051983826422536084073462084935517166603832542862106287058675490933197600813710203114108790043880150305327523679949543592622443904084453387396870899883324751789625806819506542619123964, 120007173989070249117019147454557020213723707722383599019972471016186584968096445904023372671513462965078400715365736756710078805039115601609874780421117795585342458478316236202328120583456334489780231976628584606042971207759763658961365139429661536955996519512283283500790612975034779837647053750631763512799, 18797057418663411295612229938999282286746920748194349166509084258061650142260043277698907538088835210620841171754186980908772147495732980563542600139935202965632319542217264685208215907551992891370166006725534397313373079841419662622936316343820775075897977228084528246337988431658221881343556854053475137330]</span><br><span class="line"></span><br><span class="line">L = matrix(es).T.augment(matrix.identity(len(es)))</span><br><span class="line">L[:, 0] *= 2 ^ 2048</span><br><span class="line">L = L.LLL()</span><br><span class="line">print(L[0][1:])</span><br><span class="line">print(L[1][1:])</span><br><span class="line">xx = product([ZZ(y) ^ x for x, y in zip(L[0][1:], cs)])</span><br><span class="line">yy = product([ZZ(y) ^ x for x, y in zip(L[1][1:], cs)])</span><br><span class="line">n = gcd(xx.numer() - xx.denom(), yy.numer() - yy.denom())</span><br><span class="line">print(f&quot;n = &#123;n&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># n = 144195616225517130139553879032789087363345719184209965153957734484017481087563259298073412179385691339856835367038233652960921043438130441546622467854561746540234185779818652424614702625694747523202592051400384839225423182264627929190443610610683526608116658120285614198376504623869469278859145863411493155577</span><br></pre></td></tr></table></figure><p>然后题目给出， <span class="math display">\[c1=a^{e1}\textbf{ }mod\textbf{ }n\\c2=a^{e2}\textbf{ }mod\textbf{ }n\]</span></p><p>公模攻击求<span class="math inline">\(a\)</span>,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">n = 144195616225517130139553879032789087363345719184209965153957734484017481087563259298073412179385691339856835367038233652960921043438130441546622467854561746540234185779818652424614702625694747523202592051400384839225423182264627929190443610610683526608116658120285614198376504623869469278859145863411493155577</span><br><span class="line"></span><br><span class="line">e1 = 2333</span><br><span class="line">e2 = 23333</span><br><span class="line">c1 =  132894829064255831243210470637067717685821770359549730768366345840525257033166172926149293454192143005551270166547902269036843756318967855047301751521125394803373953151753927497701242767032542708689455184991906629946511295108898559666019232955132938245031352553261823905498810285940911315433144300083027795647</span><br><span class="line">c2 =  24086830909813702968855830967174364278115647345064163689290457852025690324300607354444884288995399344650789235347773145941872226843099538451759854505842021844881825309790171852845467221751852440178862638893185965125776165397575087879479327323737686652198357863042305078811580074617322063509435591981140533310</span><br><span class="line"></span><br><span class="line">s, a, b = gmpy2.gcdext(e1, e2)</span><br><span class="line">a = ((pow(c1, a, n) * pow(c2, b, n)) % n)</span><br><span class="line">print(f&#x27;a = &#123;a&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># a = 6916067937269950974206746204164509896240838110131015886297814490101615527867219160040558623231859474391279572961225727366045095864405799615600246029206211</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后<span class="math inline">\(LCG\)</span>求出<span class="math inline">\(b\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line">a = 6916067937269950974206746204164509896240838110131015886297814490101615527867219160040558623231859474391279572961225727366045095864405799615600246029206211</span><br><span class="line">output1 =  54997286032365904331111467760366122947903752273328087460831713533712307510311367648330090376100815622160705007873798883153287827481112070182047111994066594911019010222064952859306742931009422376955635523160546531204043294436812066746785938062292942759004837173423765427628610568097898331237064396308950601636</span><br><span class="line">output2 =  115015764780168428067411132384122324817310808727138440691727747976276050930701648349452842302609389394467134068064132550313721128807222231505312226682756817617177620169804112319332815872107656884931985435898097063491690413460967856530075292289784649593915313885813931026280791070577034075346669028068003251024</span><br><span class="line"></span><br><span class="line">b  = (output2-output1*a)%n</span><br><span class="line">print(long_to_bytes(b))</span><br></pre></td></tr></table></figure><p>得到<span class="math inline">\(flag\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSSCTF&#123;407f8832-6ffd-43bf-91a0-6900758cdff7&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 格密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023蓝帽杯</title>
      <link href="/2023/09/04/2023%E8%93%9D%E5%B8%BD%E6%9D%AF/"/>
      <url>/2023/09/04/2023%E8%93%9D%E5%B8%BD%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="dhrsa">DHRSA</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sage</span><br><span class="line">from sage.all import *</span><br><span class="line">from Crypto.Util.number import getPrime,getStrongPrime, isPrime, bytes_to_long</span><br><span class="line">from secret import r,g</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">assert r.bit_length() == 512 and isPrime(r)</span><br><span class="line">FLAG = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">def gen_DH_key(g,r):</span><br><span class="line">    x = randint(2,r-1)</span><br><span class="line">    return x, pow(g,x,r)</span><br><span class="line"></span><br><span class="line">def gen_RSA_parameters(g,r):</span><br><span class="line">    main_key = gen_DH_key(g,r)</span><br><span class="line">    sub_key = gen_DH_key(g,r)</span><br><span class="line">    x, X = main_key</span><br><span class="line">    w, W = sub_key</span><br><span class="line">    print(f&quot;[+] Public DH Keys &#123; X = &#125;&quot;)</span><br><span class="line">    print(f&quot;[+] Public DH Keys &#123; W = &#125;&quot;)</span><br><span class="line">    while True:</span><br><span class="line">        c, C = gen_DH_key(g,r)</span><br><span class="line">        t1 = randint(0,1)</span><br><span class="line">        t2 = randint(0,1)</span><br><span class="line">        p = ZZ(C * W^t1 * pow(X, c, r) % r)</span><br><span class="line">        if not is_prime(p):</span><br><span class="line">            continue</span><br><span class="line">        q = ZZ(pow(W, -t2, r) * pow(X, -c, r) % r)</span><br><span class="line">        if not is_prime(q):</span><br><span class="line">            print(f&quot;[+] Try &#123;c ,C&#125;&quot;)</span><br><span class="line">            continue</span><br><span class="line">        return p,q</span><br><span class="line">    </span><br><span class="line">p, q = gen_RSA_parameters(g,r)</span><br><span class="line">n = p*q</span><br><span class="line">e = 65537</span><br><span class="line">c = pow(FLAG,e,n)</span><br><span class="line">print(f&quot;&#123; c = &#125;&quot;)</span><br><span class="line">print(f&quot;&#123; n = &#125;&quot;)</span><br></pre></td></tr></table></figure><p>题目已经说了是考的是<span class="math inline">\(DH\)</span>和<span class="math inline">\(RSA\)</span>，先看一下函数<strong>en_RSA_parameters(g,r)</strong></p><p>已知 <span class="math display">\[W,X\]</span> 未知</p><p><span class="math display">\[g,r,p,q,且p=(C*W^{t1}*X^{c})\textbf{ }mod\textbf{}r,q=(W^{-t2}*X^{-c})mod\textbf{ }r\]</span></p><p><span class="math display">\[n=p*q=C*W^{t1-t2}(mod\textbf{ }r)\]</span></p><p>所以，要解出<span class="math inline">\(p,q\)</span>,得先解出<span class="math inline">\(g,r,c,C\)</span></p><p>先求模数<span class="math inline">\(r\)</span>，在github上找了一个脚本</p><p><a href="https://github.com/maple3142/My-CTF-Challenges/tree/master/ImaginaryCTF/Round%2026/no_modulus">https://github.com/maple3142/My-CTF-Challenges/tree/master/ImaginaryCTF/Round%2026/no_modulus</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">es = [9771395973011655803041049350400889693558053786906788399593857181577256033087775470396528142785531153656250742163382306394790826547696369519066900832598632, 8272821018041191335817314516024870641634584838709754134295649414123178842937800314505950304166260273130361466329869880024580711311122266329063823157928578, 9224196545381524434689958500941052085722509493323098161219607220849299786695264643219965900283680542442505315754998495711744726427299710433730839117822341, 1008469491610938216099437983993305774398678547360061529021095399886442276321623596589458980857784117593111375842386009804225494459153563491699302948435260, 7616413788891104674175703849368746136014029498968757620534065604935400737852925875633996435081025804169137754721194517660132118370608033038162779303724417, 7584549797616896430743312033954227311758800006881758430848397006388599762762869550122276429056861398410906389124143882721771887174154825862686488628829556, 4857850091039904852357309328743353934107579830869744999969242154323443783533786032181281694960711385606506579359066323294671727886753617501542207839926790, 4779727649310569079487754450225462592903787505885564750560744245118977747200287996364352093535624060190258736345242819222383024403591273643223505871273937, 6240985007555841990183784512088706027373526355604287377336898927100013200525239698399664369530638033756622723154794368086253680721133641187916109948879111, 1440004269550837930069561548693107407163496872089856298023372643037792305541293783438854412197014895824653797468093046886645122408623089543218627931731325, 8686467414540984479883981478664234832161994713954432326787817013306458410596539074149482305300161480885280412716015692242140611122632851558942831571969449, 6397234126429549747756931006796154340671325181680459289481852293242757656214345178451346712629678435704959420962366420623987135911533358778558089423502498, 5154817535857960073707963384183439709586920855602419290358137674661940402006427565850098044416106066822250682276679669427811522910392723378330585054966700, 6184278632740706257559650240918607859111635320246236350819849684258206208438537742565177660943106119452934940861754989735447208681922747166941649495976923, 514519457570888784111073733278759745960446948568600524535727800070517989361086156941193628192360355612444575477626855845530581162562486612799738968800436, 5311179737168594393380387500131139705986775208655298446331668896011718110177021579502837999280939324755245947626117007502618967826854797851195037805622236, 8033599809537397449739222496469120219661376235214159758353162913590149327454313351545152320436531803584693342228310830634381278274606584366951286641362730, 2051625798280743150753404437482448207490537448098276190886365473636618906352671153607072757637879642085246666882064116331781620620841788195957363592387053, 2539152850168044131443627430873275266571063321601722994164719426048365057966357258486918206613866328867765905303734883912389577646355187342721384787506424, 9008908156612389991869885743985152554064654014600155665167153423864293462953589139136986609123719868913243556793248046592418855144217044361551263069240329, 6803170457708082062222117551095454287816962526481935030699353660846602430067188624302070998045883149555451692203871683262881999463532897654910797581195808, 4342007382390611975323457544296213170925503797306373729093603079594595092127747819980737254901463722358222828653606693041546906868729342511025828114827555, 2183664030657588356550029801438062011696791479721050550709966793162412846063789309880633528422512509596396589027054806885718000781675200132948682901735072, 2676285609364173142435111238008478736925861736006673806161674291385422525644573866393884559955797190936826061311631872102982470113155601869660746965071177, 8615874523824944863326511893784594675845807173709888717969574953112250736770386882455890231726119912526638461175690953959512359266034187901901745135706561, 1922646621448654308731099545672266646199287008430733010575325812508661111446471076682347110401317422369989378526004562648871357970249460937394842515685185, 6894871210132644262428509750998583740904489962095581087369230603087765684170566562618210470507349665138476792990203975299249821414179702286974952108308908, 8398850863544147035551562678201580675747803434116699749690629994755381632713482161869699483278515661816496168924359580050657657882041095486710223992321329, 1103558165483499140082633087824207492178842328222110372040372946709534675630035763166805943256640202241094017653484224302180964104596684146937840328056737, 7616579463842058663956538981992016396022484825826970703537944742179864728054422301128359842636130918256966522509540733872238802637426513398702545806054711, 6093447739151580910739487321763042257093662388037797880895310207982236604441330252766468220299149762533760095283275798097190217074233307392113562823550055, 10465708577087930103510908920924173959169681089467884381473219422666982876773505479708456794740072800789393882374346444466352555495590221538783880064776747, 10605081135879456867591725577517023044111094541257015514457259942700651158240017447609481228325274221251138332472541861502584164767676203023712244274563455, 7012967814560006293648272691588998637134646550513726240939227681138521268647913550031357555656822375449692357834760862939125678022083697005023949012937826, 9566656433910278946608540460883633932965000205012896340833001038283123101223701427477589683926930217368102196484226996825067156057344586227513445332021767, 2721818943333539016612702886003757042711221957746352716329164140315057299599294376527853842627041607856599108409067242878086913811106172846700928991925332, 4144627466364250800792304430295727495765908688276307878705582041004315000843879026660231248370219826205974342880901591994064400526974281681872092036583360, 9540229122766028258950784907897705565229274273296271759903007071156790536497946170835990412260104194662363036458196704652014673749423907001422969301809735, 1639227724203684234308217138545474026323237719482542327552473107710807011133804919537706806005714199832933437746623612694760178087234912102227060818821785, 9812993094473406654107168236073328125261683326416570529798110665650382711989965459219636103724052319209618994008458512967332799786202713476231778145396012, 2295945877832163407010322597202468334423912618570523561408751634022642288041211919141444020534567414838616766574885544294608146290275196633317265741751883, 9510449404755931940739075753727979306152379874217663126425580183559239591750519861496413596214874972534376534993718874211977861576694865786452346685079911, 10068147483643758261431583499786421277358011934810052604576663733186448278692924596285775100821424123316623283150527146388692332413482534235601982259977735, 2631234993744978915205564833565878360368731366415913670587100334887962760531396262264711195036515169369826941240935633330766040802965514627738944637938312, 6245294849421435385844087800549243031764408455344779721346137213398733894945891825456797247066883570457936878961279970460851977076618685374684565064011000, 6360363966721028786772622616611684728619548477569800250827865049949218224355237880474537231095562612445154765235574973379248267372638478052576176958426893, 1374748162508202790788170508306104425630569793823780168413397583022077368721695853340144854392562470438547910808098360313836434314988050372444336622005939, 5923217938277229682931188522357086770659121539648879409111011010394233354709847779031983270180639474376432548198701507987857799064509215702865822042304601, 7912839476386587387207319066546154431303391126303542720169612844312157005989844595260178178012638805394179538160638000205856329132154797855491159908316825, 6989926221520213501850965026707723308003729842929136196471532798477250492469686905792383597327729987647258260679589434132606672791962970232535673677457343, 7743517306425849045036228617259140769029348885373635895025449298661791309426243487821079837754283770418719515017823088333131732906019584031613089554304420, 8228064864747011743632289680585658563799395413457976150375450901737657367769151734010130073897880115256353583883179331874018722072209939664833555092694721, 4450010894214163101815316096785687407009534536454667314772668698898901466717062024203232842836467444518468762248095700604843848000837792037078167960588129, 3345145753946526259843311380078979114463790107484347721093757348344369710001786833260087626842713916819817705043732430232104986213669502412941799451378137, 411849644960126121049073725849225927315782894933779533599764821078891693733248333351876043256232845616011887951112364725817456430915422262433159009162810, 9070143529402968690182170891432541186624926767431297375488478998005501150531907444673746153178512705131935537332064808055931815290499208703009298348987029, 8213219975300001733306975337422619448976655134956761580838409562843071867497978077677323154897320151428562911412904177153952495821256190104983710364972232, 8349268362247390165742295418698754062525395439803096486083911273583071915526604580013826747245858881943244980602181641712932537086321708434534161167021746, 7509668912649960854961670452151045790218876057511153068414836771472470302685381796706603632853037886139531473147215132055911891985689199108998563497337555, 2131204693980301034358939270790217044118874047688648828664882105193013493634681490541248365340356833966291527168399270652784557243494787018476812050661672, 94628342448609390736618683703832565995079347007818829426672834242066920587964251445868380536604059942251553430692068690115557207157069742355783092463878, 8730838489034161299210542834892857189755559366635478365056603032000438656615452617258885131782074530795256008985786448336781306335727153569211343667279688]</span><br><span class="line">cs = [8139606023160038223737079478941118590185130735073983268534523900466799026361464500424904356248753891316780445417573842978538788878976916399246204378441056, 6731047210123888962354325580924677204725121336252367061814596228770531939085170702108835833376855510135160514592212524395740859425722612967050674897558554, 8618477079542034439812499299348172601780082410118486479357089433765711733400709574657418048464225715724091467457454996920521245517408697962287328781660172, 9243753430474436162138755988303772102594989764465818886594050158035773372691908643200174705510107166901553683916448850166844368808268900160791189879886461, 5081325787403850070122342963066210472728109263877409302015934601768721956580972368361384922036489915214279268746375195256103574903758346112788101331060421, 1628416782427642576537753826054924818984220964280741905185643986017630454253562852051349318488828073385103084138926801432973213673304459124585445072035446, 1436555309056212704783260154843715809916541935750195541226776332006326501592432597657580990741764167962753224321573279559350979014777173060581697942160790, 8457854453119605903801540115672523550270614339671410689633028758723786021115482172319549655156915937495339811221100830546511268665457084873839271917131026, 7516353799796514587790845891436757011323761869044622559902758322970504358548733636938457083535644723388210752578649311718854524047992380524533863744945353, 9434919345479338423866102885320010476913815819406622512632495616332678841660980531307718949753248131094030185131327688989259983673428169616967926536549981, 2376239907248313997443412718623933371621229548870946158597654591040113647645833393016706072537549866458668992268347350086597733853645352669964694698209002, 9555521900012304016219328488701400452052438846888508591910947639752080094465009622568296701465965949214617545676819204984390042310077453137495863845140433, 10496354188266114334878155842846706785121191402898647321044421232085059338092949629088561418326794767424754926615669196297619927139682997591511869107757767, 1684156496026762626171388002895398201456656580507920519170549327618625423797366792075116257872626605002727580286505567977884867816788235806054395449066065, 5279615925666476607393445956667230310409008481693792914481184221733250114518482573243209594428350182047703213893421465095795062348864307647570060060929176, 7950931857867551139311900477185535034704935066837216411367230952920436620973145933605969605301127988180373211783836800949372831376277678318587671147544812, 7363787374432448634707849149426821610638073413299588217259428219319013703633673213128364594170782521444300561327439516770200289550957339013848496654479674, 183450164326164222959035748035117444906396515108356683081562421715885871762215055266356577117853857983960152113987173865737809535655981046541363297829205, 585756688754350904695498684365256423604945135941557021419402686079315456435190920620640430630667903578283746531894135845972607789350856875988416502844449, 9289266081720210076238040168621209559442099796466275176059195696650031235127294873962598972974303719540193547570326682610716804488839647659399702777957625, 1643238506993581048346556120580389927181837132286120379981936140856072993887401596354919001634656489755991432524216993664019969824657062288544062028928533, 493026654262682081757325540069692089465639980280029378402651778901949559259891879708898948140085681814535573742826826476110468079719504023996492906928688, 4073523873469606498132661552527997945998461149945931939857824343164584528157149801459596694594269553069502164902110100517378462894925649504277727979281804, 5526482056568056411108977820792619135217540155238365597030616097363450824489623669450770143884401364973046003465586645009073389711906524301615929500348726, 5107189939984481100533490360348985070143842143450775903588073100128259350554726370669643384672212451094463934881485403663403067465232413753838963311526164, 1338120870830450195003052688429825997002475569804112786250323375715461269426478757154438256599704658856730012976479429755682431385902070463000523922633485, 4504561167146108444334786062824835552812933921903812225075224152011097132132118554220621595724113517743942246047411740399148959904624805479075676539627179, 3703218408290286096237533977791248727917587395526646685991666829723493582004703462287201605547754231978350368593066630613342669719057740600396410750130713, 4235755736045407691815950643821304187431993958805648566903603216981196118628996746825748374999189542155866127214016604808037761824195261283013629856811915, 7613956756687648883142522461784563921781848082096750733536680658594629733709520676386003626030270049444324311590771818500145651113869039994374079094176389, 5582983596876204457658414033643566916925741632988960872444165950150568674358568563750393895942021859292068409582131557028759494904690654084568015540958387, 5560992116323139630261388939207466766129106144662938095552878745416852271253443975908911908133192704735692594156704890845632323597567684452235384416207560, 9427064851222629681715722784660850738968685559393550747518608089108082562625632566953024798342737795332503266772616759203825637407245190460310558481011553, 7751396645197086848500999313322914076346713513943719371985230447422327437680224631606199418400131531054197437203771034578401374585091741737281898844967403, 546093125292516349289304554067672438202855144942643384818235748136017154830766962667037846395737218002229971788635923471525750360984025965229960880138015, 8708958215469085753181574046119339162501035682760128157682876145155787404749378257091769354933553751411564910339364737060790592181298353503681772458140296, 6503617996420087519121999497592564753358269947368728580707909964656915488241450906561184006580947106530919025122027342914550816267613360293886470939638147, 3133970773026394333676271959039363252995983077058359556442048424274114546996306660500141330973026720710258226380296916344738000286752906153301531192145588, 8270247841707725063403103311221827713218425321540707437203780169848645054354422606444548218532045886590764337285894491599474684125156258721180140005227879, 6348941299458047229603035571553554254637277183847732341685362698641456768747093952193394610221610467378544424914425383192254952105296121873394965907483421, 5994603535835080395017357896928637354820646460778770882917760856532399920260202826867821549261784608902276626362339800015674269038970155327507870854956789, 4425254452956426634646344097191468359576571843417153278931037524323172136339917846491397351511099933539635058142094213472513676095819902241563092702688501, 2486099330626766737257165308745024530097078778638782229355520177306987440002696878039888805275868528396743863481534888478552983793450062429371941132535078, 4167116570391804600255654075462038844507091559173265725625706455067299132147050347586004334123441342458308129150386241209679630518761986850258774882817936, 10185168995554407266816276622812659886483756602705301925351101031752727294301531965596293802652862084495500685833881517475134558625964721775303100038614160, 5456722125978665120229905841107251183374955393168570741251463630873840897267613318536370613164271366075428107312082239190184994439809325775182251507346825, 2939543075586963360992868413324864290837308216610370795940797957094565066506489483089379278658514795189713701943386974203309580258770009927268150497535566, 8743821334723368976778894507033225804145157545090682229505938930782456568432992185052055300701880227956622698441050884506223378607674824402614530393729367, 9157713754021073809434421172656952683393171530300224019784181318620517764533872565796337369744270420561987117136110183189161447503240922447481705416792933, 5878746531427980282714190471263188376089128406106851686623310774890789241719381568167580210027581541900359110459878728688406025608100014784866859967415069, 4723171396311923892248342600001144805520828588734579829312137837892547473549988680030764497200183283689846461436720606808050677973475562028290802376894040, 2843792191169572505424299937637335345928688319904295706002781014868972565908100208212634694593060855068754141546774316683717972204080538819157716088784950, 5649760949181251560547472271598936178113043683541495970916235935289470274241813254378868964502496661853777833292127852117859645515779670872354035434010971, 4449864701816030502869094392702038297167798303739676692580712480289620671504896451221373121095485571657769741067946182294271935296786038388717131050743105, 6015559474636248088561229697316533148096304587912722704321346276808664704462122988070466258472892491390452320498582384705624788234989258086915479317589554, 404470006641663392206752968026191050354477219085475176007692089093673919513513760805174543858749324166919507964495235284709646802332010921978754916213842, 6400060591708772742036825960295348204573787431673486966335080578765346768135800288344580251211949027002658413241092081227396455353862253913043273557206036, 4139621554482255887742647243977351847150733617205749719993940245058866579901045219083635101090422724513229414103870573743420533567984369212416328299201648, 3168193697707475529193822215328153723009219332354194589973887573663124790963735981601241436331461792216723819214300690004321006157765917632838358657075965, 7458978598400749076925462287692314594837852961494454950837549434543148869247423634127441385921463980373281159265749886433453416941713109715452118403890765, 10491155550479668966723346610934052049109810767277413338024524325905994360818069675936484156539236718504294063495115065935392782490138348869081026608020887, 8076329104944759931627228905172809552808063163769317826043905443799635345365021015532382100166858241152720115250871898592915217180839896374819810099249842]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L = matrix(es).T.augment(matrix.identity(len(es)))</span><br><span class="line">L[:, 0] *= 2 ^ 2048</span><br><span class="line">L = L.LLL()</span><br><span class="line">print(L[0][1:])</span><br><span class="line">print(L[1][1:])</span><br><span class="line">xx = product([ZZ(y) ^ x for x, y in zip(L[0][1:], cs)])</span><br><span class="line">yy = product([ZZ(y) ^ x for x, y in zip(L[1][1:], cs)])</span><br><span class="line">n = gcd(xx.numer() - xx.denom(), yy.numer() - yy.denom())</span><br><span class="line">print(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># r = 10667924450645948100608927157603781268991945924055943816082403476371801785989561454936076097627912279097114498936308342036099904242687703932444772733243819</span><br></pre></td></tr></table></figure><p>结果</p><figure><img src="/2023/09/04/2023%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20230826191338930.png" alt="image-20230826191338930"><figcaption aria-hidden="true">image-20230826191338930</figcaption></figure><p>然后共模攻击求<span class="math inline">\(g\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">n = r</span><br><span class="line">e1 = es[1]</span><br><span class="line">e2 = es[2]</span><br><span class="line">c1 = cs[1]</span><br><span class="line">c2 = cs[2]</span><br><span class="line">s, a, b = gmpy2.gcdext(e1, e2)</span><br><span class="line">g = ((pow(c1, a, n) * pow(c2, b, n)) % n)</span><br><span class="line">print(f&quot;g = &#123;g&#125;&quot;)</span><br><span class="line"></span><br><span class="line">g = 6019887080267290264230260653584196278384320835640816590398803560025633855808434001764263669714920086295176455397726166743099512294951861972283858355052731</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>验证一下<span class="math inline">\(g,r\)</span>是否求正确</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g = 6019887080267290264230260653584196278384320835640816590398803560025633855808434001764263669714920086295176455397726166743099512294951861972283858355052731</span><br><span class="line">t = pow(g,es[3],r)</span><br><span class="line">print(t==cs[3])   # True</span><br></pre></td></tr></table></figure><p>输出<span class="math inline">\(True\)</span>,说明求对了</p><p>接下来求<span class="math inline">\(C\)</span> <span class="math display">\[n=p*q=C*W^{t1-t2}(mod\textbf{ }r)\RightarrowC=n*(W^{t1-t2})^{-1}(mod\textbf{ }r)\]</span> <span class="math inline">\(t1-t2\)</span>有四种情况，经过验证发现<span class="math inline">\(t1=0,t2=1\)</span>是正确的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import invert</span><br><span class="line"></span><br><span class="line">n = 66022752859576751705544115674843820574619778139841743306742674741819040147745776264697779394213058328572691946505564202779552568613562176486470653760142864852745249430164256770469301179840812051842363261404790355057115296671805975126795017665392798621718740402876024901551851638786170466127104615340863081593</span><br><span class="line">r = 10667924450645948100608927157603781268991945924055943816082403476371801785989561454936076097627912279097114498936308342036099904242687703932444772733243819</span><br><span class="line">X = 197551296081022143608034360606381334253374533627365455002683616928330857539205836504075700389569213696043700490195977045586318090211726350917451410932216</span><br><span class="line">W = 10625560347436147537644301075885059900758953251551866239435327407977591190018531918316486861730777808988185029637608372445416280896280058313924537678128258</span><br><span class="line"></span><br><span class="line">n_1 = n%r</span><br><span class="line">W1 = pow(W,-1,r)</span><br><span class="line">C = n_1 * invert(W1,r) % r</span><br><span class="line">print(f&quot;C = &#123;C&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># C = 6613722522065187905640046954383188209052479436223100597862198940156665449370413746028107951701333399470737154699175059198545308803566143547068905213158730</span><br></pre></td></tr></table></figure><p>之后就是离散对数求解<span class="math inline">\(c\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = 10667924450645948100608927157603781268991945924055943816082403476371801785989561454936076097627912279097114498936308342036099904242687703932444772733243819</span><br><span class="line">g = 6019887080267290264230260653584196278384320835640816590398803560025633855808434001764263669714920086295176455397726166743099512294951861972283858355052731</span><br><span class="line"></span><br><span class="line">y = 6613722522065187905640046954383188209052479436223100597862198940156665449370413746028107951701333399470737154699175059198545308803566143547068905213158730</span><br><span class="line"># y = powmod(g, x, p)</span><br><span class="line"></span><br><span class="line">F = GF(p)             # 关于GF 建立一个有限域（伽罗瓦域）  # https://bbs.ctf.show/thread/68</span><br><span class="line">g = int(F(g))     # 获取元素g并将其转换为有限域的元素，确保涉及的所有算术运算都在有限域内执行</span><br><span class="line">y = int(F(y))</span><br><span class="line"></span><br><span class="line">c = discrete_log(p,y,g)        </span><br><span class="line">print(f&quot;c = &#123;c&#125;&quot;)</span><br><span class="line"></span><br><span class="line">c = 9459072654036531380057822508623309360299476015001753632088039036432789857424193280036533227566474452833834253934061279659663650834198718093112487222065271</span><br></pre></td></tr></table></figure><p>把<span class="math inline">\(c,C,X,W,n\)</span>代入题目所给函数中生成<span class="math inline">\(p,q\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sage.all import *</span><br><span class="line">def gen_DH_key(g,r):</span><br><span class="line">    x = randint(2,r-1)</span><br><span class="line">    return x, pow(g,x,r)</span><br><span class="line"></span><br><span class="line">def gen_RSA_parameters(g,r):</span><br><span class="line">    X = 197551296081022143608034360606381334253374533627365455002683616928330857539205836504075700389569213696043700490195977045586318090211726350917451410932216</span><br><span class="line">    W = 10625560347436147537644301075885059900758953251551866239435327407977591190018531918316486861730777808988185029637608372445416280896280058313924537678128258</span><br><span class="line">    n = 66022752859576751705544115674843820574619778139841743306742674741819040147745776264697779394213058328572691946505564202779552568613562176486470653760142864852745249430164256770469301179840812051842363261404790355057115296671805975126795017665392798621718740402876024901551851638786170466127104615340863081593</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        c = 9459072654036531380057822508623309360299476015001753632088039036432789857424193280036533227566474452833834253934061279659663650834198718093112487222065271</span><br><span class="line">        C = 6613722522065187905640046954383188209052479436223100597862198940156665449370413746028107951701333399470737154699175059198545308803566143547068905213158730</span><br><span class="line">        n = 66022752859576751705544115674843820574619778139841743306742674741819040147745776264697779394213058328572691946505564202779552568613562176486470653760142864852745249430164256770469301179840812051842363261404790355057115296671805975126795017665392798621718740402876024901551851638786170466127104615340863081593</span><br><span class="line"></span><br><span class="line">        t1 = randint(0,1)</span><br><span class="line">        t2 = randint(0,1)</span><br><span class="line">        p = ZZ(C * W^t1 * pow(X, c, r) % r)</span><br><span class="line">        if not is_prime(p):</span><br><span class="line">            continue</span><br><span class="line">        q = ZZ(pow(W, -t2, r) * pow(X, -c, r) % r)</span><br><span class="line">        if not is_prime(q):</span><br><span class="line">            continue</span><br><span class="line">        if p * q == n:</span><br><span class="line">            return p,q</span><br><span class="line">r = 10667924450645948100608927157603781268991945924055943816082403476371801785989561454936076097627912279097114498936308342036099904242687703932444772733243819</span><br><span class="line">g = 6019887080267290264230260653584196278384320835640816590398803560025633855808434001764263669714920086295176455397726166743099512294951861972283858355052731</span><br><span class="line">    </span><br><span class="line">p,q=gen_RSA_parameters(g,r)</span><br><span class="line">print(f&quot;p = &#123;p&#125;&quot;)</span><br><span class="line">print(f&quot;q = &#123;q&#125;&quot;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;p = 9125108445086331925357843149394623354462543858897897154159826615993773522239402208791043686117858047731898804072058031370881324396877080965819439538440937</span><br><span class="line">q = 7235284189431034832042412280826370091519780455676267387609597166985508163736912532994379832384451948567288869573364590805507346423864423622133140637948689&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>最后就是正常的<span class="math inline">\(RSA\)</span>，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line">c = 61040814411609979711931510878805548760848686739454567580358315369154260598969544907138563610735920809370306294050956464828615417082277087799410050319871691154003766481799397897519555113273982347768485719165972634089532894585256662433949694618032747408071953491187718726218120284389638124624152241321006634774</span><br><span class="line">n = 66022752859576751705544115674843820574619778139841743306742674741819040147745776264697779394213058328572691946505564202779552568613562176486470653760142864852745249430164256770469301179840812051842363261404790355057115296671805975126795017665392798621718740402876024901551851638786170466127104615340863081593</span><br><span class="line"></span><br><span class="line">p = 9125108445086331925357843149394623354462543858897897154159826615993773522239402208791043686117858047731898804072058031370881324396877080965819439538440937</span><br><span class="line">q = 7235284189431034832042412280826370091519780455676267387609597166985508163736912532994379832384451948567288869573364590805507346423864423622133140637948689</span><br><span class="line">e = 65537</span><br><span class="line">phi = (p-1)*(q-1)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = gmpy2.powmod(c,d,n)</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>得到<span class="math inline">\(flag\)</span></p><p><img src="/2023/09/04/2023%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20230826193100638-1693842538307-3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 格密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023羊城杯</title>
      <link href="/2023/09/04/2023%E7%BE%8A%E5%9F%8E%E6%9D%AF/"/>
      <url>/2023/09/04/2023%E7%BE%8A%E5%9F%8E%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="easy_3l">Easy_3L</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_key():</span><br><span class="line">    p = getPrime(1400)</span><br><span class="line">    f = getRandomNBitInteger(1024)</span><br><span class="line">    while True:</span><br><span class="line">        q = getPrime(512)</span><br><span class="line">        if gcd(f, q) != 1:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    h = (invert(f, p) * q) % p</span><br><span class="line">    return p, h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt1(m):</span><br><span class="line">    a = getPrime(250)</span><br><span class="line">    b = getRandomNBitInteger(240)</span><br><span class="line">    n = getPrime(512)</span><br><span class="line">    seed = m</span><br><span class="line">    s = [0] * 6</span><br><span class="line">    s[0] = seed</span><br><span class="line">    for i in range(1, 6):</span><br><span class="line">        s[i] = (s[i - 1] * a + b) % n</span><br><span class="line">    return s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt2(msg, p, h):</span><br><span class="line">    s = getRandomNBitInteger(512)</span><br><span class="line">    c = (s * h + msg) % p</span><br><span class="line">    return c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = encrypt1(m)</span><br><span class="line">print(&quot;S1 =&quot;, s[1])</span><br><span class="line">print(&quot;S2 =&quot;, s[2])</span><br><span class="line">print(&quot;S4 =&quot;, s[4])</span><br><span class="line">print(&quot;S5 =&quot;, s[5])</span><br><span class="line"></span><br><span class="line">p, h = get_key()</span><br><span class="line">c = encrypt2(s[3], p, h)</span><br><span class="line">print(&quot;p =&quot;, p)</span><br><span class="line">print(&quot;h =&quot;, h)</span><br><span class="line">print(&quot;c =&quot;, c)</span><br><span class="line"></span><br><span class="line"># S1 = 28572152986082018877402362001567466234043851789360735202177142484311397443337910028526704343260845684960897697228636991096551426116049875141</span><br><span class="line"># S2 = 1267231041216362976881495706209012999926322160351147349200659893781191687605978675590209327810284956626443266982499935032073788984220619657447889609681888</span><br><span class="line"># S4 = 9739918644806242673966205531575183334306589742344399829232076845951304871478438938119813187502023845332528267974698273405630514228632721928260463654612997</span><br><span class="line"># S5 = 9755668823764800147393276745829186812540710004256163127825800861195296361046987938775181398489372822667854079119037446327498475937494635853074634666112736</span><br><span class="line"># p = 25886434964719448194352673440525701654705794467884891063997131230558866479588298264578120588832128279435501897537203249743883076992668855905005985050222145380285378634993563571078034923112985724204131887907198503097115380966366598622251191576354831935118147880783949022370177789175320661630501595157946150891275992785113199863734714343650596491139321990230671901990010723398037081693145723605154355325074739107535905777351</span><br><span class="line"># h = 2332673914418001018316159191702497430320194762477685969994411366563846498561222483921873160125818295447435796015251682805613716554577537183122368080760105458908517619529332931042168173262127728892648742025494771751133664547888267249802368767396121189473647263861691578834674578112521646941677994097088669110583465311980605508259404858000937372665500663077299603396786862387710064061811000146453852819607311367850587534711</span><br><span class="line"># c = 20329058681057003355767546524327270876901063126285410163862577312957425318547938475645814390088863577141554443432653658287774537679738768993301095388221262144278253212238975358868925761055407920504398004143126310247822585095611305912801250788531962681592054588938446210412897150782558115114462054815460318533279921722893020563472010279486838372516063331845966834180751724227249589463408168677246991839581459878242111459287</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span class="math inline">\(LCG\)</span>中的初始种子就是<span class="math inline">\(m\)</span>,已知<span class="math inline">\(S_{1},S_{2},S_{4},S_{5}\)</span>,要恢复初始种子，我们要先求出<span class="math inline">\(S3\)</span>.</p><p>在函数 encrypt2(msg, p, h) 中，已知<span class="math inline">\(p,h,c\)</span>.</p><p><span class="math inline">\(msg,s\)</span>是未知的，考虑用格，</p><p>构造格<span class="math inline">\(L\)</span>, <span class="math display">\[(k,s,1)\begin{pmatrix}-p ,&amp;0,&amp;0 \\-h,&amp;1,&amp;0 \\c,&amp;0,&amp;2^{512}\end{pmatrix}=(msg,s,2^{512})\]</span> <span class="math inline">\(msg\)</span>就是<span class="math inline">\(S_{3}\)</span>,这样就可以恢复<span class="math inline">\(seed\)</span>了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p = 25886434964719448194352673440525701654705794467884891063997131230558866479588298264578120588832128279435501897537203249743883076992668855905005985050222145380285378634993563571078034923112985724204131887907198503097115380966366598622251191576354831935118147880783949022370177789175320661630501595157946150891275992785113199863734714343650596491139321990230671901990010723398037081693145723605154355325074739107535905777351</span><br><span class="line">h = 2332673914418001018316159191702497430320194762477685969994411366563846498561222483921873160125818295447435796015251682805613716554577537183122368080760105458908517619529332931042168173262127728892648742025494771751133664547888267249802368767396121189473647263861691578834674578112521646941677994097088669110583465311980605508259404858000937372665500663077299603396786862387710064061811000146453852819607311367850587534711</span><br><span class="line">c = 20329058681057003355767546524327270876901063126285410163862577312957425318547938475645814390088863577141554443432653658287774537679738768993301095388221262144278253212238975358868925761055407920504398004143126310247822585095611305912801250788531962681592054588938446210412897150782558115114462054815460318533279921722893020563472010279486838372516063331845966834180751724227249589463408168677246991839581459878242111459287</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mat = [[-p,0,0],[-h,1,0],[c,0,2^512]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">hh = M.LLL()[0]</span><br><span class="line"># print(hh)</span><br><span class="line"></span><br><span class="line">msg = hh[0]</span><br><span class="line">print(f&quot;msg = &#123;msg&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># msg = 10700695166096094995375972320865971168959897437299342068124161538902514000691034236758289037664275323635047529647532200693311709347984126070052011571264606</span><br></pre></td></tr></table></figure><p><span class="math inline">\(LCG\)</span>恢复<span class="math inline">\(seed\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c=[28572152986082018877402362001567466234043851789360735202177142484311397443337910028526704343260845684960897697228636991096551426116049875141,</span><br><span class="line">1267231041216362976881495706209012999926322160351147349200659893781191687605978675590209327810284956626443266982499935032073788984220619657447889609681888,</span><br><span class="line">10700695166096094995375972320865971168959897437299342068124161538902514000691034236758289037664275323635047529647532200693311709347984126070052011571264606,</span><br><span class="line">9739918644806242673966205531575183334306589742344399829232076845951304871478438938119813187502023845332528267974698273405630514228632721928260463654612997,</span><br><span class="line">9755668823764800147393276745829186812540710004256163127825800861195296361046987938775181398489372822667854079119037446327498475937494635853074634666112736</span><br><span class="line">]</span><br><span class="line"># print(c[2].bit_length())</span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0                     # 求n</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line"># print(isPrime(m))   # False m的倍数</span><br><span class="line">print(f&quot;n = &#123;m&#125;&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(1,100):</span><br><span class="line">    if isPrime(m//i):</span><br><span class="line">        print(i)   # i是4</span><br><span class="line">        m//=i</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line">print(f&quot;a = &#123;a&#125;&quot;)</span><br><span class="line">print(f&quot;b = &#123;b&#125;&quot;)</span><br><span class="line">print(f&quot;a_1 = &#123;a_1&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = 12433235385460084327215142269091752668477278692416805859007828624838647815241707248797912107322868748847211061641608674422095027981318008221949510129177787</span><br><span class="line">a = 1017579321905754831612145134014116183026524698685218523407174987842084260441</span><br><span class="line">b = 1244547131344198183940330607549789182491018543684349414313485985685030480</span><br><span class="line">a_1 = 11328311979915953125685402059730442802186525001769955129939835010285255328316264293029576580150862310729537002669636904024186460482729761660664512406166499</span><br><span class="line"></span><br><span class="line">m = (c[0]-b)*a_1 % n</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;DASCTF&#123;NTRU_L0G_a6e_S1mpLe&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="danger_rsa">danger_RSA</h3><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_key(a, nbit):</span><br><span class="line">    assert a &gt;= 2</span><br><span class="line">    while True:</span><br><span class="line">        X = getRandomInteger(nbit // a)</span><br><span class="line">        s = getRandomRange(pow(2, a ** 2 - a + 4), pow(2, a ** 2 - a + 5))</span><br><span class="line">        p = X ** a + s</span><br><span class="line">        if isPrime(p):</span><br><span class="line">            return (p, s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p, s = get_key(a, 1024)</span><br><span class="line">q, t = get_key(a, 1024)</span><br><span class="line"></span><br><span class="line">N = p * q</span><br><span class="line">e = s * t</span><br><span class="line">c = pow(m, e, N)</span><br><span class="line">print(&quot;N =&quot;, N)</span><br><span class="line">print(&quot;e =&quot;, e)</span><br><span class="line">print(&quot;c =&quot;, c)</span><br><span class="line"># N = 20289788565671012003324307131062103060859990244423187333725116068731043744218295859587498278382150779775620675092152011336913225797849717782573829179765649320271927359983554162082141908877255319715400550981462988869084618816967398571437725114356308935833701495015311197958172878812521403732038749414005661189594761246154666465178024563227666440066723650451362032162000998737626370987794816660694178305939474922064726534186386488052827919792122844587807300048430756990391177266977583227470089929347969731703368720788359127837289988944365786283419724178187242169399457608505627145016468888402441344333481249304670223</span><br><span class="line"># e = 11079917583</span><br><span class="line"># c = 13354219204055754230025847310134936965811370208880054443449019813095522768684299807719787421318648141224402269593016895821181312342830493800652737679627324687428327297369122017160142465940412477792023917546122283870042482432790385644640286392037986185997262289003477817675380787176650410819568815448960281666117602590863047680652856789877783422272330706693947399620261349458556870056095723068536573904350085124198592111773470010262148170379730937529246069218004969402885134027857991552224816835834207152308645148250837667184968030600819179396545349582556181916861808402629154688779221034610013350165801919342549766</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目最终还是回到<span class="math inline">\(RSA\)</span>,要求解<span class="math inline">\(p,q\)</span>.这里构造了一种公钥生成方式 <span class="math display">\[p=a^{r}+s\\q=b^{r}+t\]</span> 还知道， <span class="math display">\[e=s*t\]</span> 且<span class="math inline">\(s,t\)</span>是在一定范围里面的，思考是否可以通过分解<span class="math inline">\(e\)</span>,然后排列组合求出<span class="math inline">\(s,t\)</span>的组合。<strong>这里需要注意的是，组合有很多种，正确的组合才能求出整数解，要多尝试。</strong></p><p>根据<span class="math inline">\(e_{bit}\)</span>我们是可以推断出<span class="math inline">\(r\)</span>的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(e.bit_length())#34</span><br><span class="line">for m in range(10):</span><br><span class="line">    print(m,m**2-m+4,m**2-m+5)</span><br><span class="line"># 4,16,17</span><br></pre></td></tr></table></figure><p>得到<span class="math inline">\(r=4\)</span>,<span class="math inline">\(s_{bit}=17,t_{bit}=17\)</span>，<span class="math inline">\(a_{bit}=256,b_{bit}=256\)</span>,所以<span class="math inline">\(s,t\)</span>的值不足以影响<span class="math inline">\(N\)</span>的大小，故有 <span class="math display">\[N=p*q=(a^{r}+s)(b^{r}+t)=(ab)^{r}\Rightarrow a*b=gmpy2.iroot(n,4)\]</span> 这样，就能联立方程，求出<span class="math inline">\(a,b\)</span>了</p><p>验证<span class="math inline">\(s_{bit}=t_{bit}\)</span>是17的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tepm = [3,7,7,19,691,5741]</span><br><span class="line">for e in combinations(tepm, 3):</span><br><span class="line">    sum = 1</span><br><span class="line">    for i in e:</span><br><span class="line">        sum *= i</span><br><span class="line">    if sum in range(2**16, 2**17):</span><br><span class="line">        print(e)</span><br><span class="line">        print(sum)</span><br><span class="line"></span><br><span class="line">s,t = [3*7*5741,7*19*691]</span><br><span class="line"># print(tepm1[0].bit_length()) 17</span><br><span class="line"># print(tepm1[1].bit_length())  17</span><br></pre></td></tr></table></figure><p>然后联立方程解<span class="math inline">\(a,b\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">n = 20289788565671012003324307131062103060859990244423187333725116068731043744218295859587498278382150779775620675092152011336913225797849717782573829179765649320271927359983554162082141908877255319715400550981462988869084618816967398571437725114356308935833701495015311197958172878812521403732038749414005661189594761246154666465178024563227666440066723650451362032162000998737626370987794816660694178305939474922064726534186386488052827919792122844587807300048430756990391177266977583227470089929347969731703368720788359127837289988944365786283419724178187242169399457608505627145016468888402441344333481249304670223</span><br><span class="line">e = 11079917583</span><br><span class="line">c = 13354219204055754230025847310134936965811370208880054443449019813095522768684299807719787421318648141224402269593016895821181312342830493800652737679627324687428327297369122017160142465940412477792023917546122283870042482432790385644640286392037986185997262289003477817675380787176650410819568815448960281666117602590863047680652856789877783422272330706693947399620261349458556870056095723068536573904350085124198592111773470010262148170379730937529246069218004969402885134027857991552224816835834207152308645148250837667184968030600819179396545349582556181916861808402629154688779221034610013350165801919342549766</span><br><span class="line"></span><br><span class="line">r,s=[3*7*5741,7*19*691]</span><br><span class="line">ab=int(gmpy2.iroot(n,4)[0])</span><br><span class="line">var(&#x27;a b&#x27;)</span><br><span class="line">f1=a*b==ab</span><br><span class="line">f2=n==(ab**4)+a**4*s+b**4*r+r*s</span><br><span class="line">print(solve([f1,f2],[a,b]))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;a = 47783641287938625512681830427927501009821495321018170621907812035456872958654</span><br><span class="line">b = 44416071018427916652440592614276227563515579156219730344722242565477265479486&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>在求解私钥<span class="math inline">\(d\)</span>的时候发现<span class="math inline">\(e和phi\)</span>不互素。<strong>一般<span class="math inline">\(p和q\)</span>很大，在<span class="math inline">\(flag\)</span>没有填充的情况下，会小于<span class="math inline">\(p和q\)</span>,可以将<span class="math inline">\(p,q\)</span>单独作为公钥求解。</strong></p><p><strong>先把不互素的部分去除，然后剩下的利用<span class="math inline">\(p或者q\)</span>构建多项式环求根。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 47783641287938625512681830427927501009821495321018170621907812035456872958654</span><br><span class="line">b = 44416071018427916652440592614276227563515579156219730344722242565477265479486</span><br><span class="line">p=a**4+r</span><br><span class="line">q=b**4+s</span><br><span class="line"># print(gcd(e,p-1) #3</span><br><span class="line">d=inverse(e//3,p-1)</span><br><span class="line">m_3=pow(c,d,n)</span><br><span class="line">e=3</span><br><span class="line">P.&lt;a&gt;=PolynomialRing(Zmod(p),implementation=&#x27;NTL&#x27;)</span><br><span class="line">f=a^e-m_3</span><br><span class="line">mps=f.monic().roots()</span><br><span class="line">for i in mps:</span><br><span class="line">    flag=long_to_bytes(int(i[0]))</span><br><span class="line">    if b&#x27;DASCTF&#x27; in flag or b&#x27;dasctf&#x27; in flag:</span><br><span class="line">        print(flag)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;DASCTF&#123;C0nsTruct!n9_Techn1qUe2_f0r_RSA_Pr1me_EnC2ypt10N&#125;&#x27;</span><br></pre></td></tr></table></figure><p>赛后尝试用<span class="math inline">\(q\)</span>作为公钥来求解。发现有一个问题就是<strong>去除公因数不彻底,逆元不存在</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcd_eq_1 = gmpy2.gcd(e,q-1) # 7</span><br><span class="line">gcd_2 = gmpy2.gcd(e//7,q-1) # 7</span><br></pre></td></tr></table></figure><p>所以为了<strong>一次性把公因数去除彻底，让<span class="math inline">\(e\)</span>和<span class="math inline">\(q-1\)</span>都除以最大公因数，而不应该只让一边去除公因数(只让<span class="math inline">\(e//7\)</span>).</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">#print(e.bit_length())  34</span><br><span class="line"></span><br><span class="line"># for m in range(10):</span><br><span class="line">#     print(m,m**2-m+4,m**2-m+5)</span><br><span class="line">#4,16,17</span><br><span class="line">r,s=[3*7*5741,7*19*691]</span><br><span class="line">ab=int(gmpy2.iroot(n,4)[0])</span><br><span class="line"># var(&#x27;a b&#x27;)</span><br><span class="line"># f1=a*b==ab</span><br><span class="line"># f2=n==(ab**4)+a**4*s+b**4*r+r*s</span><br><span class="line"># print(solve([f1,f2],[a,b]))</span><br><span class="line">a = 47783641287938625512681830427927501009821495321018170621907812035456872958654</span><br><span class="line">b = 44416071018427916652440592614276227563515579156219730344722242565477265479486</span><br><span class="line">p=a**4+r</span><br><span class="line">q=b**4+s</span><br><span class="line"># print(gcd(e//7,q-1)</span><br><span class="line">d = inverse(e//7,(q-1)//7) </span><br><span class="line"># d = inverse(e//49,q-1)</span><br><span class="line">m_49 = pow(c,d,n)</span><br><span class="line">e = 7  </span><br><span class="line"># e = 49</span><br><span class="line">q.&lt;a&gt;=PolynomialRing(Zmod(q),implementation=&#x27;NTL&#x27;)</span><br><span class="line">f = a^e-m_49</span><br><span class="line">mps = f.monic().roots()</span><br><span class="line">for i in mps:</span><br><span class="line">    flag=long_to_bytes(int(i[0]))</span><br><span class="line">    if b&#x27;DASCTF&#x27; in flag or b&#x27;dasctf&#x27; in flag:</span><br><span class="line">        print(flag)</span><br></pre></td></tr></table></figure><h3 id="xor贯穿始终">XOR贯穿始终</h3><p>第一次做这样的题，卡了很久很久。。</p><p>题目附件是加密的，要想办法拿到密码。注意到题目给了一个<span class="math inline">\(massege.txt\)</span>，打开一看，是社会主义核心价值观编码，在线网站解密就行。</p><p><span class="math inline">\(massege.txt\)</span>的内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自由和谐和谐富强公正友善爱国公正法治法治文明和谐自由法治自由法治平等公正友善公正公正民主法治自由公正敬业和谐富强公正友善爱国和谐平等平等友善敬业法治敬业和谐富强法治平等平等友善敬业公正公正公正友善敬业法治平等平等诚信自由公正自由平等友善敬业公正友善法治和谐和谐</span><br></pre></td></tr></table></figure><p>解码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C0ngr4tulati0n5_y0u_fou^d_m3</span><br></pre></td></tr></table></figure><p>现在就能打开附件了，看到题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import gcd</span><br><span class="line">from Crypto.Util.number import getPrime</span><br><span class="line">from secret import enflag</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = q * p</span><br><span class="line">phi = (p - 1) * (q - 1)</span><br><span class="line">e = getPrime(17)</span><br><span class="line">assert gcd(e, phi) == 1</span><br><span class="line"># 以上信息生成了私钥文件,但文件被损坏了你能提取有用信息吗</span><br><span class="line"></span><br><span class="line">c = pow(enflag, e, n)</span><br><span class="line">print(&#x27;c = &#x27; + str(c))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">c = 91817924748361493215143897386603397612753451291462468066632608541316135642691873237492166541761504834463859351830616117238028454453831120079998631107520871612398404926417683282285787231775479511469825932022611941912754602165499500350038397852503264709127650106856760043956604644700201911063515109074933378818</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>私钥丢失了，但是给了一个<span class="math inline">\(pem\)</span>证书，要我们从中提取私钥。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALmtMy+2uH1ZtbIL</span><br><span class="line">SuiAukFthyQRH5mp7UmLyzZQkdg9zEP9/5tgffikQ7ytx5kHySHnazgAO1sOzmYE</span><br><span class="line">N4Axlev6uafiP8B1Eij97v5VkYJ1I9e3mtBNheTbXKoT8op+ASQ1fQaF4A8UzLuW</span><br><span class="line">eZeZI8JTH/SH+bolAK3kiZXDFdkTAgMBAAECgYEAl067LaC7Cvs2A5cMPhfYsESv</span><br><span class="line">IgcKN1CwW4Sd3u8dSphhgu7TgyzIuvwxbuo2g1BC6WwKhaI6vGN+csfw6nh98GEn</span><br><span class="line">/p3D0huNroAYvf/DRRB9UnHdttX7wB+Mv3P0RBDWHgBiCDVvHFuFUV78cIs0tnbn</span><br><span class="line">jxjU07aPV2XRC3AfA2ECQQDqWUNPVg3i6vTyHCL7EGkbeUheYpAAfcKCQrxjc5+5</span><br><span class="line">X6A+XtgHAA1JHwykPlCpHUOmlA85DJF1ejuoImzlgRLJAkEAytTCnQF+MN2r1gaA</span><br><span class="line">UETZyj5qMYT7Th8zKEVVVJjDawLnuX4usJ2FyRnjCkk86U75QSJhw5mMc0QnG25u</span><br><span class="line">Gz3++w==</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p>先了解一下<span class="math inline">\(pem\)</span>证书吧</p><p><a href="https://blog.csdn.net/good123day/article/details/25496507">RSA公私钥结构</a></p><p><a href="https://zhuanlan.zhihu.com/p/461349946">(PKCS1) RSA 公私钥pem 文件解析</a></p><p><a href="https://blog.csdn.net/boweiqiang/article/details/116309452">非对称加密RSA公私钥pkcs1与pkcs8格式的转换</a></p><p>将<span class="math inline">\(pem\)</span>证书的<strong><span class="math inline">\(base64\)</span>解码，再转<span class="math inline">\(hex\)</span></strong>,分割出<span class="math inline">\(n,e,d,p,q\)</span>.在这里<span class="math inline">\(d_{p},d_{q},m_{p}\)</span>是没有泄露的。</p><p><img src="/2023/09/04/2023%E7%BE%8A%E5%9F%8E%E6%9D%AF/xor-1693824738136-2.jpg"></p><p>最后发现真正的<span class="math inline">\(flag\)</span>是<span class="math inline">\(RSA\)</span>的<span class="math inline">\(flag\)</span>和社会主义核心价值观解码结果异或的结果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes, bytes_to_long</span><br><span class="line"></span><br><span class="line"># s = &#x27;00 ca d4 c2 9d 01 7e 30 dd ab d6 06 80 50 44 d9 ca 3e 6a 31 84 fb 4e 1f 33 28 45 55 54 98 c3 6b 02 e7 b9 7e 2e b0 9d 85 c9 19 e3 0a 49 3c e9 4e f9 41 22 61 c3 99 8c 73 44 27 1b 6e 6e 1b 3d fe fb&#x27;</span><br><span class="line"># n1 = &#x27;&#x27;</span><br><span class="line"># sum = 0</span><br><span class="line"># for i in s:</span><br><span class="line">#     if i != &#x27; &#x27;:</span><br><span class="line">#         n1 += i</span><br><span class="line">#     else:</span><br><span class="line">#         sum += 1</span><br><span class="line"># print(n1)</span><br><span class="line"># print(sum)</span><br><span class="line">n = 0x00b9ad332fb6b87d59b5b20b4ae880ba416d8724111f99a9ed498bcb365091d83dcc43fdff9b607df8a443bcadc79907c921e76b38003b5b0ece660437803195ebfab9a7e23fc0751228fdeefe5591827523d7b79ad04d85e4db5caa13f28a7e0124357d0685e00f14ccbb9679979923c2531ff487f9ba2500ade48995c315d9130203010001</span><br><span class="line">d = 0x00974ebb2da0bb0afb3603970c3e17d8b044af22070a3750b05b849ddeef1d4a986182eed3832cc8bafc316eea36835042e96c0a85a23abc637e72c7f0ea787df06127fe9dc3d21b8dae8018bdffc345107d5271ddb6d5fbc01f8cbf73f44410d61e006208356f1c5b85515efc708b34b676e78f18d4d3b68f5765d10b701f0361</span><br><span class="line">p = 0x00ea59434f560de2eaf4f21c22fb10691b79485e6290007dc28242bc63739fb95fa03e5ed807000d491f0ca43e50a91d43a6940f390c91757a3ba8226ce58112c9</span><br><span class="line">q = 0x00cad4c29d017e30ddabd606805044d9ca3e6a3184fb4e1f332845555498c36b02e7b97e2eb09d85c919e30a493ce94ef9412261c3998c7344271b6e6e1b3dfefb</span><br><span class="line">e = 0x010001</span><br><span class="line">c = 91817924748361493215143897386603397612753451291462468066632608541316135642691873237492166541761504834463859351830616117238028454453831120079998631107520871612398404926417683282285787231775479511469825932022611941912754602165499500350038397852503264709127650106856760043956604644700201911063515109074933378818</span><br><span class="line"># print(p*q == n)</span><br><span class="line"></span><br><span class="line"># print(p == p1)</span><br><span class="line"># print(q == q1)</span><br><span class="line">m = gmpy2.powmod(c,d,p*q)</span><br><span class="line">m1 = b&#x27;C0ngr4tulati0n5_y0u_fou^d_m3&#x27;</span><br><span class="line">print(long_to_bytes(m^bytes_to_long(m1)))</span><br></pre></td></tr></table></figure><h3 id="复现">复现</h3><h4 id="esyrsa">esyRSA</h4><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import invert</span><br><span class="line">from md5 import md5</span><br><span class="line">from secret import p, q</span><br><span class="line"></span><br><span class="line">e = ?????</span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-1)*(q-1)</span><br><span class="line">d = invert(e, phi)</span><br><span class="line">ans = gcd(e,phi)</span><br><span class="line"></span><br><span class="line">print n, e, d</span><br><span class="line">print &quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p + q)).hexdigest()</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">n = 8064259277274639864655809758868795854117113170423331934498023294296505063511386001711751916634810056911517464467899780578338013011453082479880809823762824723657495915284790349150975180933698827382368698861967973964030509129133021116919437755292590841218316278732797712538885232908975173746394816520256585937380642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br><span class="line">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>题目分析：就是一个<span class="math inline">\(RSA\)</span>，给了<span class="math inline">\(n,d\)</span>但是需要恢复<span class="math inline">\(e\)</span>，最后让我们求的是<span class="math inline">\(p+q\)</span>.这里需要注意的是，<span class="math inline">\(n\)</span>重复了一遍，去除重复部分才是真正的<span class="math inline">\(n\)</span>.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br></pre></td></tr></table></figure><h5 id="格求解">格求解</h5><p>比赛的时候我其实是想过用格来解决的，但是我尝试失败了。之后看到一个师傅的<span class="math inline">\(WP\)</span>就是用格来求解的。 <span class="math display">\[e*d\equiv1\textbf{ }mod\textbf{ }phi\Rightarrow\]</span></p><p><span class="math display">\[e*d=k*n-k*(p+q-1)+1\]</span></p><p><span class="math display">\[(k,e)\begin{pmatrix}n, &amp;0 \\-d,&amp;2^{512}\end{pmatrix}=(k*(p+q-1)-1,e*2^{512})\]</span></p><p><strong>这里解释一下为什么要这样构造格。</strong></p><p><strong><span class="math inline">\(p,q\)</span>都是<span class="math inline">\(512bit\)</span>,而<span class="math inline">\(e\)</span>是比较小的（只有5位数），为了使目标向量的两个坐标差不多大，让<span class="math inline">\(e\)</span>乘上<span class="math inline">\(2^{512}\)</span>.</strong>(我当时就是没乘。。)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from hashlib import md5</span><br><span class="line">import gmpy2</span><br><span class="line">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br><span class="line">n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br><span class="line">m = matrix(ZZ, [[n,0],[-d,2**512]])</span><br><span class="line">k_pq, e = m.LLL()[0]</span><br><span class="line">print(&quot;k_pq = &quot;, k_pq)</span><br><span class="line">print(&quot;e = &quot;,e)</span><br><span class="line">k_pq = abs(k_pq)</span><br><span class="line">e = abs(e)//2**512</span><br><span class="line">k = gcd(e*d-1,k_pq+1)</span><br><span class="line">p_q = (k_pq+1)//k+1</span><br><span class="line">print(&quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p_q).encode()).hexdigest())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flag: DASCTF&#123;4ae33bea90f030bfddb7ac4d9222ef8f&#125;</span><br></pre></td></tr></table></figure><h5 id="连分数求解">连分数求解</h5><p><span class="math display">\[e*d\equiv1\textbf{ }mod\textbf{ }phi\Rightarrow\]</span></p><p><span class="math display">\[e*d=k*phi+1\Rightarrow\]</span></p><p><span class="math display">\[同除以e*phi,\frac{d}{phi}=\frac{k}{e}+\frac{1}{e*phi}\]</span></p><p><span class="math display">\[因为phi\approx n,且phi非常大,所以\frac{1}{e*phi}\approx 0\]</span></p><p><span class="math display">\[所以，\frac{d}{n}=\frac{k}{e}+\frac{1}{e*phi}\]</span></p><p><span class="math display">\[也就是说，\frac{d}{n}\approx\frac{k}{e}\]</span></p><p><span class="math display">\[而d,n是已知的，所以对\frac{d}{n}进行连分数展开，得到的一串分母很有可能就是e\]</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sage</span><br><span class="line">from hashlib import md5</span><br><span class="line"></span><br><span class="line">n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br><span class="line">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br><span class="line"></span><br><span class="line">c = continued_fraction(d/n)  # 计算连分数</span><br><span class="line">i = 1</span><br><span class="line">while True:</span><br><span class="line">    k = c.numerator(i)  # 分子</span><br><span class="line">    e = c.denominator(i) # 分母</span><br><span class="line">    if (e*d-1) % k == 0 and len(str(e)) == 5:</span><br><span class="line">        print(k)</span><br><span class="line">        print(e)</span><br><span class="line">        p_q = n+1-(e*d-1)//k</span><br><span class="line">        break</span><br><span class="line">    i+=1</span><br><span class="line">print(f&quot;p+q = &#123;p_q&#125;&quot;)</span><br><span class="line">print(&quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p_q).encode()).hexdigest())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flag: DASCTF&#123;4ae33bea90f030bfddb7ac4d9222ef8f&#125;</span><br></pre></td></tr></table></figure><h5 id="维纳攻击求解">维纳攻击求解</h5><p><strong>维纳攻击的核心就在于连分数</strong>，所以用维纳攻击的脚本来求解也是可以的。</p><p>参考：<a href="https://blog.csdn.net/fengerxi33/article/details/123007453">CTF-RSA_维纳攻击脚本</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from hashlib import md5</span><br><span class="line"></span><br><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">def continuedFra(x, y):</span><br><span class="line">    &quot;&quot;&quot;计算连分数</span><br><span class="line">    :param x: 分子</span><br><span class="line">    :param y: 分母</span><br><span class="line">    :return: 连分数列表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    cf = []</span><br><span class="line">    while y:</span><br><span class="line">        cf.append(x // y)</span><br><span class="line">        x, y = y, x % y</span><br><span class="line">    return cf</span><br><span class="line">def gradualFra(cf):</span><br><span class="line">    &quot;&quot;&quot;计算传入列表最后的渐进分数</span><br><span class="line">    :param cf: 连分数列表</span><br><span class="line">    :return: 该列表最后的渐近分数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    numerator = 0</span><br><span class="line">    denominator = 1</span><br><span class="line">    for x in cf[::-1]:</span><br><span class="line">        # 这里的渐进分数分子分母要分开</span><br><span class="line">        numerator, denominator = denominator, x * denominator + numerator</span><br><span class="line">    return numerator, denominator</span><br><span class="line">def solve_pq(a, b, c):</span><br><span class="line">    &quot;&quot;&quot;使用韦达定理解出pq，x^2−(p+q)∗x+pq=0</span><br><span class="line">    :param a:x^2的系数</span><br><span class="line">    :param b:x的系数</span><br><span class="line">    :param c:pq</span><br><span class="line">    :return:p，q</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    par = gmpy2.isqrt(b * b - 4 * a * c)</span><br><span class="line">    return (-b + par) // (2 * a), (-b - par) // (2 * a)</span><br><span class="line">def getGradualFra(cf):</span><br><span class="line">    &quot;&quot;&quot;计算列表所有的渐近分数</span><br><span class="line">    :param cf: 连分数列表</span><br><span class="line">    :return: 该列表所有的渐近分数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    gf = []</span><br><span class="line">    for i in range(1, len(cf) + 1):</span><br><span class="line">        gf.append(gradualFra(cf[:i]))</span><br><span class="line">    return gf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def wienerAttack(d, n):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param d:</span><br><span class="line">    :param n:</span><br><span class="line">    :return: e</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    cf = continuedFra(d, n)</span><br><span class="line">    gf = getGradualFra(cf)</span><br><span class="line">    for e, k in gf:</span><br><span class="line">        if k == 0:</span><br><span class="line">            continue</span><br><span class="line">        if (e * d - 1) % k != 0:</span><br><span class="line">            continue</span><br><span class="line">        phi = (e * d - 1) // k</span><br><span class="line">        # p, q = solve_pq(1, n - phi + 1, n)</span><br><span class="line">        if len(str(e))==5:</span><br><span class="line">            p_q = n+1-(e*d-1)//k</span><br><span class="line">            return e,p_q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br><span class="line">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br><span class="line"></span><br><span class="line">e,p_q = wienerAttack(d, n)</span><br><span class="line">print(f&quot;e = &#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p_q).encode()).hexdigest())</span><br></pre></td></tr></table></figure><h6 id="xenny库">xenny库</h6><p>值得一提的是，我们也<strong>可以直接用<span class="math inline">\(Xenny库\)</span>里面的<span class="math inline">\(wiener函数\)</span>解决</strong>。<span class="math inline">\(xenny师傅\)</span>真的泰裤辣！！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from hashlib import md5</span><br><span class="line">from xenny.ctf.crypto.modern.asymmetric.rsa import wiener</span><br><span class="line">n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br><span class="line">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br><span class="line"></span><br><span class="line">e,p,q = wiener.attack(n, d)</span><br><span class="line">print(f&quot;e = &#123;e&#125;&quot;)</span><br><span class="line">print(&quot;p = &quot;,p)</span><br><span class="line">print(&quot;q = &quot;,q)</span><br><span class="line">print(&quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p + q).encode()).hexdigest())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 13521</span><br><span class="line">p =  10181341212828413853336916619161138854377885230386496425058202154486415709366161346816273366144505351043947477469664133317598479763451392984403646602585037</span><br><span class="line">q =  7920625690369490250766357750388349704260128405941822835255851274284409978206593795103040446837018619894098452542488850045009467407103749792461438242280929</span><br><span class="line">Flag: DASCTF&#123;4ae33bea90f030bfddb7ac4d9222ef8f&#125;</span><br></pre></td></tr></table></figure><h4 id="mceorpkpleer">MCeorpkpleer</h4><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pubkey(list, m, w):</span><br><span class="line">    pubkey_list = []</span><br><span class="line">    for i in range(len(e_bin)):</span><br><span class="line">        pubkey_list.append(w * list[i] % m)</span><br><span class="line">    return pubkey_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def e_cry(e, pubkey):</span><br><span class="line">    pubkey_list = pubkey</span><br><span class="line">    encode = 0</span><br><span class="line">    for i in range(len(e)):</span><br><span class="line">        encode += pubkey_list[i] * int(e[i]) % m</span><br><span class="line">    return encode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">n = p * q</span><br><span class="line">e = getPrime(64)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line"></span><br><span class="line">e_bin = (bin(e))[2:]</span><br><span class="line">list = [pow(3, i) for i in range(len(e_bin))]</span><br><span class="line">m = getPrime(len(bin(sum(list))) - 1)</span><br><span class="line">w = getPrime(64)</span><br><span class="line">pubkey = pubkey(list, m, w)</span><br><span class="line">en_e = e_cry(e_bin, pubkey)</span><br><span class="line"></span><br><span class="line">print(&#x27;p = &#123;&#125;\n&#x27;</span><br><span class="line">      &#x27;n = &#123;&#125;\n&#x27;</span><br><span class="line">      &#x27;c = &#123;&#125;\n&#x27;</span><br><span class="line">      &#x27;pubkey = &#123;&#125;\n&#x27;</span><br><span class="line">      &#x27;en_e = &#123;&#125;&#x27;.format((p &gt;&gt; 435) &lt;&lt; 435, n, c, pubkey, en_e))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p = 139540788452365306201344680691061363403552933527922544113532931871057569249632300961012384092481349965600565669315386312075890938848151802133991344036696488204791984307057923179655351110456639347861739783538289295071556484465877192913103980697449775104351723521120185802327587352171892429135110880845830815744</span><br><span class="line">n = 22687275367292715121023165106670108853938361902298846206862771935407158965874027802803638281495587478289987884478175402963651345721058971675312390474130344896656045501040131613951749912121302307319667377206302623735461295814304029815569792081676250351680394603150988291840152045153821466137945680377288968814340125983972875343193067740301088120701811835603840224481300390881804176310419837493233326574694092344562954466888826931087463507145512465506577802975542167456635224555763956520133324723112741833090389521889638959417580386320644108693480886579608925996338215190459826993010122431767343984393826487197759618771</span><br><span class="line">c = 156879727064293983713540449709354153986555741467040286464656817265584766312996642691830194777204718013294370729900795379967954637233360644687807499775502507899321601376211142933572536311131955278039722631021587570212889988642265055045777870448827343999745781892044969377246509539272350727171791700388478710290244365826497917791913803035343900620641430005143841479362493138179077146820182826098057144121231954895739989984846588790277051812053349488382941698352320246217038444944941841831556417341663611407424355426767987304941762716818718024107781873815837487744195004393262412593608463400216124753724777502286239464</span><br><span class="line">pubkey = [18143710780782459577, 54431132342347378731, 163293397027042136193, 489880191081126408579, 1469640573243379225737, 4408921719730137677211, 13226765159190413031633, 39680295477571239094899, 119040886432713717284697, 357122659298141151854091, 1071367977894423455562273, 3214103933683270366686819, 9642311801049811100060457, 28926935403149433300181371, 86780806209448299900544113, 260342418628344899701632339, 781027255885034699104897017, 2343081767655104097314691051, 7029245302965312291944073153, 21087735908895936875832219459, 63263207726687810627496658377, 189789623180063431882489975131, 569368869540190295647469925393, 1708106608620570886942409776179, 601827224419797931380408071500, 1805481673259393794141224214500, 893952418336266652976851386463, 2681857255008799958930554159389, 3523079163584485147344841221130, 1524252287869625983140881149316, 50264262166963219975822190911, 150792786500889659927466572733, 452378359502668979782399718199, 1357135078508006939347199154597, 4071405235524020818041597463791, 3169230503688232995231149877299, 462706308180869526799807117823, 1388118924542608580399421353469, 4164356773627825741198264060407, 3448085117999647764701149667147, 1299270151115113835209806487367, 3897810453345341505629419462101, 2648446157152195057994615872229, 3422845870014670444537026359650, 1223552407160181874717436564876, 3670657221480545624152309694628, 1966986461557807413563286569810, 1378466783231507511243038452393, 4135400349694522533729115357179, 3361215846199738142293703557463, 1038662335715384967987468158315, 3115987007146154903962404474945, 302975818554635252993570910761, 908927455663905758980712732283, 2726782366991717276942138196849, 3657854499533237101379593333510, 1928578295715881845245137486456, 1263242285705730806288591202331, 3789726857117192418865773606993, 2324195368467747797703678306905, 2450093503961328663664213663678, 2827787910442071261545819733997, 3960871129884299055190637944954, 2837628186769067706678271320788]</span><br><span class="line">en_e = 31087054322877663244023458448558</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>题目分析：</p><p>梳理一下已知信息： <span class="math display">\[p高位，n,c,en_e\]</span></p><p><span class="math display">\[e是64bit,那么列表list也是已知的\]</span></p><p>未知： <span class="math display">\[q,e\]</span> 给出<span class="math inline">\(p\)</span>高位，<span class="math inline">\(copper\)</span>就可以恢复<span class="math inline">\(p\)</span>.继而就能知道<span class="math inline">\(q\)</span></p><p>列表<span class="math inline">\(list\)</span>的值是已知的,且<span class="math inline">\(list[0]\)</span>就是<span class="math inline">\(W\)</span>. <span class="math display">\[pubkey[i]=w*list[i]\textbf{ }mod\textbf{ }m\Rightarrow\]</span></p><p><span class="math display">\[k*m=pubkey[i]-w*list[i]\]</span></p><p>求出多组<span class="math inline">\(k*m\)</span>,这些<span class="math inline">\(k*m\)</span>的最大公因数就是<span class="math inline">\(m\)</span>。</p><p>再看<span class="math inline">\(list\)</span>是一个<strong>超递增序列</strong>，直接用<strong>贪心算法</strong>求解<span class="math inline">\(e\)</span>。 <span class="math display">\[encode=(pubkey[0]*e[0]+pubkey[1]*e[1]+...+pubkey[63]*e[63])\textbf{}mod\textbf{ }m\]</span></p><p><span class="math display">\[=((w*list[0])*e[0]+(w*list[1])*e[1]+...+(w*list[63])*e[63])\textbf{}mod\textbf{ }m\]</span></p><p><span class="math display">\[=w*(list[0]*e[0]+list[1]*e[1]+...+list[63]*e[63])\textbf{ }mod \textbf{}m\]</span></p><p><span class="math display">\[所以，encode*w^{-1}=(list[0]*e[0]+list[1]*e[1]+...+list[63]*e[63])\textbf{}mod \textbf{ }m\]</span></p><p><span class="math inline">\(copper\)</span>解<span class="math inline">\(p\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#sage</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">hint = 139540788452365306201344680691061363403552933527922544113532931871057569249632300961012384092481349965600565669315386312075890938848151802133991344036696488204791984307057923179655351110456639347861739783538289295071556484465877192913103980697449775104351723521120185802327587352171892429135110880845830815744</span><br><span class="line">n = 22687275367292715121023165106670108853938361902298846206862771935407158965874027802803638281495587478289987884478175402963651345721058971675312390474130344896656045501040131613951749912121302307319667377206302623735461295814304029815569792081676250351680394603150988291840152045153821466137945680377288968814340125983972875343193067740301088120701811835603840224481300390881804176310419837493233326574694092344562954466888826931087463507145512465506577802975542167456635224555763956520133324723112741833090389521889638959417580386320644108693480886579608925996338215190459826993010122431767343984393826487197759618771</span><br><span class="line"></span><br><span class="line">p_high = hint</span><br><span class="line"># print(p_high)</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = p_high + x</span><br><span class="line">x = f.small_roots(X=2^435, beta=0.4)[0]</span><br><span class="line">p = p_high+int(x)</span><br><span class="line">q = n//p</span><br><span class="line">print(f&quot;p = &#123;p&#125;&quot;)</span><br><span class="line">print(f&quot;q = &#123;q&#125;&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = 139540788452365306201344680691061363403552933527922544113532931871057569249632300961012384092481349965600565669315386312075890938848151802133991344036696488204791984307057923179677630589032444985150800881889090713797496239571291907818169058929859395965304623825442220206712660451198754072531986630133689525911</span><br><span class="line">q = 162585259972480477964240855936099163585362299488578311068842002571891718764319834825730036484383081273549236661473286892739224906812137330941622699836239606393084030874487072527724286268715004074797344316619876830720445250395986443767703356842297999006344406006724963545062388183647988548800359369190326996261</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>求<span class="math inline">\(m\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = [pow(3, i) for i in range(64)]</span><br><span class="line">w = pubkey[0]</span><br><span class="line">m_len = len(bin(sum(list))) - 1</span><br><span class="line">k_m = []</span><br><span class="line">for i in range(63,50,-1):</span><br><span class="line">    k_m.append(pubkey[i]-w*list[i])</span><br><span class="line">m = k_m[0]</span><br><span class="line">for num in k_m[1:]:</span><br><span class="line">    m = gmpy2.gcd(m,num)</span><br><span class="line">    if isPrime(m) and m.bit_length() == m_len:</span><br><span class="line">        print(&quot;m =&quot;,m)</span><br><span class="line">        break</span><br><span class="line">        </span><br><span class="line"># m = 4522492601441914729446821257037</span><br></pre></td></tr></table></figure><p>贪心算法求解<span class="math inline">\(e\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S = en_e * gmpy2.invert(w,m)</span><br><span class="line">M = list</span><br><span class="line">e = &#x27;&#x27;</span><br><span class="line">for i in range(len(M)-1,-1,-1):</span><br><span class="line">    if S &gt;= M[i]:</span><br><span class="line">        e += &#x27;1&#x27;</span><br><span class="line">        S -= M[i]</span><br><span class="line">    else:</span><br><span class="line">        e += &#x27;0&#x27;</span><br><span class="line">e = int(e[::-1],2)</span><br><span class="line">print(&quot;e =&quot;,e)</span><br><span class="line"></span><br><span class="line"># e = 15960663600754919507</span><br></pre></td></tr></table></figure><p>最后解<span class="math inline">\(RSA\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">p = 139540788452365306201344680691061363403552933527922544113532931871057569249632300961012384092481349965600565669315386312075890938848151802133991344036696488204791984307057923179677630589032444985150800881889090713797496239571291907818169058929859395965304623825442220206712660451198754072531986630133689525911</span><br><span class="line">q = 162585259972480477964240855936099163585362299488578311068842002571891718764319834825730036484383081273549236661473286892739224906812137330941622699836239606393084030874487072527724286268715004074797344316619876830720445250395986443767703356842297999006344406006724963545062388183647988548800359369190326996261</span><br><span class="line">c = 156879727064293983713540449709354153986555741467040286464656817265584766312996642691830194777204718013294370729900795379967954637233360644687807499775502507899321601376211142933572536311131955278039722631021587570212889988642265055045777870448827343999745781892044969377246509539272350727171791700388478710290244365826497917791913803035343900620641430005143841479362493138179077146820182826098057144121231954895739989984846588790277051812053349488382941698352320246217038444944941841831556417341663611407424355426767987304941762716818718024107781873815837487744195004393262412593608463400216124753724777502286239464</span><br><span class="line"></span><br><span class="line">e = 15960663600754919507</span><br><span class="line">d = gmpy2.invert(e,(p-1)*(q-1))</span><br><span class="line">real_m = gmpy2.powmod(c,d,p*q)</span><br><span class="line">print(long_to_bytes(real_m))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DASCTF&#123;T81I_tPPS_6r7g_xlPi_OO3M_6vyV_Rkba&#125;</span><br></pre></td></tr></table></figure><h4 id="signincrypto">SigninCrypto</h4><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from random import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from Crypto.Cipher import DES3</span><br><span class="line">from flag import flag</span><br><span class="line">from key import key</span><br><span class="line">from iv import iv</span><br><span class="line">import os</span><br><span class="line">import hashlib</span><br><span class="line">import secrets</span><br><span class="line"></span><br><span class="line">K1= key</span><br><span class="line">hint1 = os.urandom(2) * 8</span><br><span class="line">xor =bytes_to_long(hint1)^bytes_to_long(K1)</span><br><span class="line">print(xor)</span><br><span class="line"></span><br><span class="line">def Rand():</span><br><span class="line">    rseed = secrets.randbits(1024)</span><br><span class="line">    List1 = []</span><br><span class="line">    List2 = []</span><br><span class="line">    seed(rseed)</span><br><span class="line">    for i in range(624):</span><br><span class="line">        rand16 = getrandbits(16)</span><br><span class="line">        List1.append(rand16)</span><br><span class="line">    seed(rseed)</span><br><span class="line">    for i in range(312):</span><br><span class="line">        rand64 = getrandbits(64)</span><br><span class="line">        List2.append(rand64)</span><br><span class="line">    with open(&quot;task.txt&quot;, &quot;w&quot;) as file:</span><br><span class="line">        for rand16 in List1:</span><br><span class="line">            file.write(hex(rand16)+ &quot;\n&quot;)</span><br><span class="line">        for rand64 in List2:</span><br><span class="line">            file.write(hex((rand64 &amp; 0xffff) | ((rand64 &gt;&gt; 32) &amp; 0xffff) &lt;&lt; 16) + &quot;\n&quot;)  #拼接</span><br><span class="line">Rand()</span><br><span class="line"></span><br><span class="line">K2 = long_to_bytes(getrandbits(64))</span><br><span class="line">K3 = flag[:8]</span><br><span class="line"></span><br><span class="line">KEY = K1 + K2 + K3</span><br><span class="line"></span><br><span class="line">IV=iv</span><br><span class="line"></span><br><span class="line">IV1=IV[:len(IV)//2]</span><br><span class="line">IV2=IV[len(IV)//2:]</span><br><span class="line"></span><br><span class="line">digest1 = hashlib.sha512(IV1).digest().hex()</span><br><span class="line">digest2 = hashlib.sha512(IV2).digest().hex()</span><br><span class="line"></span><br><span class="line">digest=digest1+digest2 # type(digest)==&#x27;str&#x27;</span><br><span class="line">hint2=(bytes_to_long(IV)&lt;&lt;32)^bytes_to_long(os.urandom(8))</span><br><span class="line">print(hex(bytes_to_long((digest.encode()))))</span><br><span class="line">print(hint2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mode = DES3.MODE_CBC</span><br><span class="line">des3 = DES3.new(KEY, mode, IV)</span><br><span class="line"></span><br><span class="line">pad_len = 8 - len(flag) % 8</span><br><span class="line">padding = bytes([pad_len]) * pad_len</span><br><span class="line">flag += padding</span><br><span class="line"></span><br><span class="line">cipher = des3.encrypt(flag)</span><br><span class="line"></span><br><span class="line">ciphertext=cipher.hex()</span><br><span class="line">print(ciphertext)</span><br><span class="line"></span><br><span class="line"># 334648638865560142973669981316964458403</span><br><span class="line"># 0x62343937373634656339396239663236643437363738396663393438316230353665353733303939613830616662663633326463626431643139323130616333363363326631363235313661656632636265396134336361623833636165373964343533666537663934646239396462323666316236396232303539336438336234393737363465633939623966323664343736373839666339343831623035366535373330393961383061666266363332646362643164313932313061633336336332663136323531366165663263626539613433636162383363616537396434353366653766393464623939646232366631623639623230353933643833</span><br><span class="line"># 22078953819177294945130027344</span><br><span class="line"># a6546bd93bced0a8533a5039545a54d1fee647007df106612ba643ffae850e201e711f6e193f15d2124ab23b250bd6e1</span><br></pre></td></tr></table></figure><p>分析一下题目，这个题重点是求<span class="math inline">\(KEY\)</span>和<span class="math inline">\(IV\)</span>.</p><p><span class="math inline">\(KEY\)</span>被分成了3段，<span class="math inline">\(IV\)</span>被分成了2段.</p><p>先看一下<span class="math inline">\(K1\)</span>.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K1= key</span><br><span class="line">hint1 = os.urandom(2) * 8  </span><br><span class="line">xor =bytes_to_long(hint1)^bytes_to_long(K1)</span><br><span class="line">print(xor)</span><br></pre></td></tr></table></figure><p>这里解释一下<strong><span class="math inline">\(os.urandom(2)\)</span>是生成2字节的随机数，<span class="math inline">\(os.urandom(2) *8\)</span>将这个随机数重复8遍</strong>.</p><p>我们输出一下，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor = 334648638865560142973669981316964458403</span><br><span class="line">print(long_to_bytes(xor))</span><br></pre></td></tr></table></figure><p>发现有一些片段是重复的.</p><p><img src="/2023/09/04/2023%E7%BE%8A%E5%9F%8E%E6%9D%AF/image-20230914220255316-1694700177752-1.png"></p><p>猜测<span class="math inline">\(hint1\)</span>就是 **b'*8**,那么<span class="math inline">\(K1\)</span>就可以求出来了.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor = 334648638865560142973669981316964458403</span><br><span class="line">print(long_to_bytes(xor))</span><br><span class="line">hint1 = b&#x27;\xfb\xc2&#x27;*8</span><br><span class="line">print(long_to_bytes(bytes_to_long(hint1)^xor))</span><br><span class="line"># b&#x27;dasctfda&#x27;</span><br></pre></td></tr></table></figure><p>接着我们看<span class="math inline">\(K3\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K3 = flag[:8]</span><br></pre></td></tr></table></figure><p><span class="math inline">\(K3\)</span>前7位就是<strong>b'DASCTF{'</strong>，第8位需要爆破一下.</p><p>再来看<span class="math inline">\(IV\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IV=iv</span><br><span class="line"></span><br><span class="line">IV1=IV[:len(IV)//2]</span><br><span class="line">IV2=IV[len(IV)//2:]</span><br><span class="line"></span><br><span class="line">digest1 = hashlib.sha512(IV1).digest().hex()</span><br><span class="line">digest2 = hashlib.sha512(IV2).digest().hex()</span><br><span class="line"></span><br><span class="line">digest=digest1+digest2 # type(digest)==&#x27;str&#x27;</span><br><span class="line">hint2=(bytes_to_long(IV)&lt;&lt;32)^bytes_to_long(os.urandom(8))</span><br><span class="line">print(hex(bytes_to_long((digest.encode()))))</span><br><span class="line">print(hint2)</span><br></pre></td></tr></table></figure><p><span class="math inline">\((bytes_to_long(IV)&lt;&lt;32)\)</span>说明在异或的时候，<span class="math inline">\(IV\)</span>的高32位是不受影响的，所以我们直接打印出<strong>long_to_bytes(hint2)</strong></p><p>，得到<span class="math inline">\(IV1\)</span>.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hint2 = 22078953819177294945130027344</span><br><span class="line">print(long_to_bytes(hint2))</span><br><span class="line"># b&#x27;GWHT\xd9\x13\xbc\xcdu~\x99P&#x27;</span><br><span class="line">IV1 = b&#x27;GWHT&#x27;</span><br></pre></td></tr></table></figure><p>这里特别强调一下，<strong><span class="math inline">\(digest\)</span>的类型是<span class="math inline">\(str\)</span></strong>.(打印一下<span class="math inline">\(type(digest)\)</span>)，那么知道<span class="math inline">\(IV1\)</span>和<strong>diegest_encode</strong>是可以求出<span class="math inline">\(IV2\)</span>的.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digest_encode = 0x62343937373634656339396239663236643437363738396663393438316230353665353733303939613830616662663633326463626431643139323130616333363363326631363235313661656632636265396134336361623833636165373964343533666537663934646239396462323666316236396232303539336438336234393737363465633939623966323664343736373839666339343831623035366535373330393961383061666266363332646362643164313932313061633336336332663136323531366165663263626539613433636162383363616537396434353366653766393464623939646232366631623639623230353933643833</span><br><span class="line">digest1 = hashlib.sha512(IV1).digest().hex()</span><br><span class="line">digest11 = bytes_to_long(digest1.encode())</span><br><span class="line"># print(digest11.bit_length()) 1023</span><br><span class="line">digest2 = digest_encode-(digest11&lt;&lt;1024)</span><br><span class="line">print(digest2==digest11) # True</span><br></pre></td></tr></table></figure><p>说明<span class="math inline">\(IV2\)</span>也是<strong>b'GWHT</strong>'.至此，<span class="math inline">\(IV\)</span>求出，<span class="math inline">\(IV=b&#39;GWHTGWHT&#39;\)</span>（这里讲一下，细心的人可能发现<span class="math inline">\(digest\)</span>是两个相同的数拼接而成，所以<span class="math inline">\(IV2==IV1\)</span>）</p><p>最后求<span class="math inline">\(K2\)</span>,生成<span class="math inline">\(K2\)</span>的方法是<strong>梅森旋转法</strong></p><p><strong><span class="math inline">\(MersenneTwister\)</span>算法有一个内部状态数据库，该数据库由624个32位无符号整数组成。在每次请求随机修改数字时，它都会提取并返回一个值，同时内部状态认为下次请求准备好。当算法消耗了所有624 个状态之后，它会进行一次称为“扭曲”的操作，更新所有 624个状态。</strong></p><p><strong>使用相同的种子对随机数生成器进行初始化，那么生成的随机数序列将是确定的，并且每次都是相同的。</strong></p><p>再看一下<strong>随机数的生成机制：</strong></p><p><strong>通过生成<span class="math inline">\(32bit\)</span>的数进行拼接或者移位</strong>（大佬教的）</p><p><strong>如果要生成<span class="math inline">\(16bit\)</span>的数，是先生成<span class="math inline">\(32bit\)</span>再取这个数的高16位</strong></p><p><strong>如果要生成<span class="math inline">\(64bit\)</span>的数，先生成两个<span class="math inline">\(32bit\)</span>的数<span class="math inline">\(x1,x2\)</span>,再进行拼接<span class="math inline">\(x1|x2\)</span></strong></p><p>有了这些知识，我们就可以<strong>恢复初始状态</strong>，并<strong>预测下一个随机数（也就是<span class="math inline">\(K2\)</span>)</strong>.</p><p>在<span class="math inline">\(Rand()\)</span>中，<strong>通过<span class="math inline">\(List1\)</span>可以得到<span class="math inline">\(624\)</span>个<span class="math inline">\(32bit\)</span>的随机数的高<span class="math inline">\(16\)</span>位.通过<span class="math inline">\(List2\)</span>可以得到<span class="math inline">\(624\)</span>个<span class="math inline">\(32bit\)</span>的随机数的低<span class="math inline">\(16\)</span>位，这样初始状态就恢复了.</strong></p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import DES3</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from randcrack import RandCrack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = open(&quot;task.txt&quot;,&quot;r&quot;)</span><br><span class="line">List = []</span><br><span class="line">for data in f:</span><br><span class="line">    List.append(eval(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List1 = List[:624] # 高16位</span><br><span class="line">List2 = List[624:]</span><br><span class="line">List3 = []</span><br><span class="line"></span><br><span class="line"># 低16位</span><br><span class="line">for data in List2:</span><br><span class="line">    List3.append(data &amp; 0xffff)</span><br><span class="line">    List3.append((data&gt;&gt;16) &amp; 0xffff)</span><br><span class="line"></span><br><span class="line"># 恢复初始624个32bit的随机数</span><br><span class="line">rc = []</span><br><span class="line">for data1,data2 in zip(List1,List3):</span><br><span class="line">    rc.append((data1&lt;&lt;16)+data2)</span><br><span class="line"># print(rc)</span><br><span class="line"></span><br><span class="line">rc1 = RandCrack()</span><br><span class="line">for i in rc:</span><br><span class="line">    rc1.submit(i)</span><br><span class="line">K2 = long_to_bytes(rc1.predict_getrandbits(64))</span><br><span class="line"># print(K2)</span><br><span class="line"></span><br><span class="line">IV1 = b&#x27;GWHT&#x27;</span><br><span class="line">IV2 = IV1</span><br><span class="line">IV = IV1+IV2</span><br><span class="line">K3_7 = b&#x27;DASCTF&#123;&#x27;</span><br><span class="line">K1 = b&#x27;dasctfda&#x27;</span><br><span class="line">c = &#x27;a6546bd93bced0a8533a5039545a54d1fee647007df106612ba643ffae850e201e711f6e193f15d2124ab23b250bd6e1&#x27;</span><br><span class="line">c = bytes.fromhex(c)</span><br><span class="line">for i in range(2**10):</span><br><span class="line">    KEY = K1 + K2 + K3_7 + long_to_bytes(i)</span><br><span class="line">    mode = DES3.MODE_CBC</span><br><span class="line">    des3 = DES3.new(KEY, mode, IV)</span><br><span class="line">    m = des3.decrypt(c)</span><br><span class="line">    if b&#x27;DASCTF&#x27; in m:</span><br><span class="line">        print(m)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DASCTF&#123;8e5ee461-f4e1-4af2-8632-c9d62f4dc073&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格密码</title>
      <link href="/2023/08/25/%E6%A0%BC%E5%AF%86%E7%A0%81/"/>
      <url>/2023/08/25/%E6%A0%BC%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>解格问题的关键其实就是<strong>用已知的信息去构造矩阵，求出未知的信息。</strong></p><p>​</p><h1 id="先看-nssctf-上的一些题">先看 NSSCTF 上的一些题</h1><h2 id="p3用格解决rsa">P3（用格解决RSA)</h2><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">a = getPrime(1024)</span><br><span class="line">b = getPrime(1536)</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">r = random.randint(2**14, 2**15)</span><br><span class="line">assert ((p-r) * a + q) % b &lt; 50</span><br><span class="line"></span><br><span class="line">c = pow( m, 65537, p*q )</span><br><span class="line"></span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line">print(f&#x27;a = &#123;a&#125;&#x27;)</span><br><span class="line">print(f&#x27;b = &#123;b&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">c = 78168998533427639204842155877581577797354503479929547596593341570371249960925614073689003464816147666662937166442652068942931518685068382940712171137636333670133426565340852055387100597883633466292241406019919037053324433086548680586265243208526469135810446004349904985765547633536396188822210185259239807712</span><br><span class="line">a = 134812492661960841508904741709490501744478747431860442812349873283670029478557996515894514952323891966807395438595833662645026902457124893765483848187664404810892289353889878515048084718565523356944401254704006179297186883488636493997227870769852726117603572452948662628907410024781493099700499334357552050587</span><br><span class="line">b = 1522865915656883867403482317171460381324798227298365523650851184567802496240011768078593938858595296724393891397782658816647243489780661999411811900439319821784266117539188498407648397194849631941074737391852399318951669593881907935220986282638388656503090963153968254244131928887025800088609341714974103921219202972691321661198135553928411002184780139571149772037283749086504201758438589417378336940732926352806256093865255824803202598635567105242590697162972609</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>加密过程：</p><p><span class="math display">\[((p-r)*a+q)\textit{ }mod\textit{ }b&lt;50\]</span> 解密：</p><p>​ <span class="math inline">\(已知，r=14\textit{ }bits\)</span></p><p>​ <span class="math inline">\(我们不防设x=((p-r)*a+q)\textit{}mod\textit{ }b\)</span></p><p>​ <span class="math inline">\(则x-q=k*b+(p-r)*a\)</span></p><p>题目已知<span class="math inline">\(c,a,b\)</span>的值，要求<span class="math inline">\(m\)</span>,我们必须要求出<span class="math inline">\(p,q\)</span>,那么我们就可以用<span class="math inline">\(a,b\)</span>来构造矩阵，求解<span class="math inline">\(p,q或者跟p,q有关的信息\)</span></p><p>不防构造格<span class="math inline">\(L\)</span> <span class="math display">\[(k,p-r)\begin{pmatrix}b,0\\a,1\end{pmatrix}=(x-q,p-r)\]</span> 这样我们就能求出<span class="math inline">\(与p,q有关的信息，也就是x-q,p-r\)</span>了。根据<span class="math inline">\(Hermite\)</span>定理我们来计算一下，这样构造格是否可行呢?</p><p>​<br><span class="math display">\[\lambda(L)\leqslant\sqrt{1024*2+512*2}=\sqrt{3072}=\sqrt{2}*\sqrt[2]{b}=\sqrt{2b}\]</span> 所以是满足用<span class="math inline">\(LLL算法\)</span>求解<span class="math inline">\(SVP\)</span>问题的。</p><p>求解出<span class="math inline">\(x-q,p-r\)</span>后，<span class="math inline">\(x和r\)</span>的范围是已知的，我们就可以用循环来爆破出<span class="math inline">\(q和p\)</span></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from tqdm import *</span><br><span class="line"></span><br><span class="line">c = 78168998533427639204842155877581577797354503479929547596593341570371249960925614073689003464816147666662937166442652068942931518685068382940712171137636333670133426565340852055387100597883633466292241406019919037053324433086548680586265243208526469135810446004349904985765547633536396188822210185259239807712</span><br><span class="line">a = 134812492661960841508904741709490501744478747431860442812349873283670029478557996515894514952323891966807395438595833662645026902457124893765483848187664404810892289353889878515048084718565523356944401254704006179297186883488636493997227870769852726117603572452948662628907410024781493099700499334357552050587</span><br><span class="line">b = 1522865915656883867403482317171460381324798227298365523650851184567802496240011768078593938858595296724393891397782658816647243489780661999411811900439319821784266117539188498407648397194849631941074737391852399318951669593881907935220986282638388656503090963153968254244131928887025800088609341714974103921219202972691321661198135553928411002184780139571149772037283749086504201758438589417378336940732926352806256093865255824803202598635567105242590697162972609</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line"># ((p-r) * a + q) % b &lt; 50</span><br><span class="line"></span><br><span class="line">mat = [[b,0],[a,1]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">hh = M.LLL()</span><br><span class="line"># print(hh)</span><br><span class="line"></span><br><span class="line">p = abs(hh[0][1])  # p-r</span><br><span class="line">q = abs(hh[0][0])  # q-x</span><br><span class="line"></span><br><span class="line">for i in tqdm(range(2**14, 2**15)):</span><br><span class="line">    for j in range(50):</span><br><span class="line">        pp = p + i</span><br><span class="line">        qq = q + j</span><br><span class="line">        phi = (pp-1)*(qq-1)</span><br><span class="line">        if gcd(phi, 65537) != 1:</span><br><span class="line">            continue</span><br><span class="line">        d = inverse(e,phi)</span><br><span class="line">        n = pp*qq</span><br><span class="line">        m = pow(c,d,n)</span><br><span class="line">        flag = long_to_bytes(int(m))</span><br><span class="line">        if b&#x27;NSSCTF&#x27; in flag :</span><br><span class="line">            print(flag)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><p>这里解释一下：</p><p><span class="math inline">\(mat\)</span>是一个<span class="math inline">\(2*2\)</span>的矩阵；</p><p><span class="math inline">\(M\)</span>是将这个矩阵转化为整数域<span class="math inline">\(ZZ\)</span> 上的矩阵。</p><h2 id="p4">P4</h2><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">p = getPrime(1024)</span><br><span class="line">r = getPrime(175)</span><br><span class="line">a = inverse(r, p)</span><br><span class="line">a = (a*flag) % p</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;a&#125;&#x27;)</span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247</span><br><span class="line">p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>加密过程： <span class="math display">\[a=(flag*r^{-1})\textit{ }mod\textit{ }p\]</span> 解密： <span class="math display">\[a*r=flag\textit{ }mod\textit{ }p\Rightarrow flag=k*p+a*r\]</span> <span class="math inline">\(a,p\)</span>我们是已知的，我们就可以利用<span class="math inline">\(a,p\)</span>去构造格<span class="math inline">\(L\)</span>, <span class="math display">\[(k,a)\begin{pmatrix}p,0\\r,1\end{pmatrix}=(flag,a)\]</span> exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247</span><br><span class="line">p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591</span><br><span class="line"></span><br><span class="line"># a * r = flag mod p</span><br><span class="line"># r 175 bits </span><br><span class="line"></span><br><span class="line"># k*p  + a* r  = flag </span><br><span class="line">mat = [[p,0],[a,1]] </span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">hh = M.LLL()</span><br><span class="line">m = hh[0][0]</span><br><span class="line">flag = long_to_bytes(m)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h2 id="p5">P5</h2><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">assert m.bit_length() == 351</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">b = getPrime(1024)</span><br><span class="line">c = getPrime(400)</span><br><span class="line"></span><br><span class="line">a = (b*m + c) % p</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;a&#125;&#x27;)</span><br><span class="line">print(f&#x27;b = &#123;b&#125;&#x27;)</span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 92716521851427599147343828266552451834533034815416003395170301819889384044273026852184291232938197215198124164263722270347104189412921224361134013717269051168246275213624264313794650441268405062046423740836145678559969020294978939553573428334198212792931759368218132978344815862506799287082760307048309578592</span><br><span class="line">b = 155530728639099361922541063573602659584927544589739208888076194504495146661257751801481540924821292656785953391450218803112838556107960071792826902126414012831375547340056667753587086997958522683688746248661290255381342148052513971774612583235459904652002495564523557637169529882928308821019659377248151898663</span><br><span class="line">p = 100910862834849216140965884888425432690937357792742349763319405418823395997406883138893618605587754336982681610768197845792843123785451070312818388494074168909379627989079148880913190854232917854414913847526564520719350308494462584771237445179797367179905414074344416047541423116739621805238556845903951985783</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>加密： <span class="math display">\[a=(b*m+c)\textit{ }mod\textit{ }p\]</span> 解密： <span class="math display">\[a=k*p+(b*m+c)\Rightarrow c=k*p-b*m+a\]</span> <span class="math inline">\(a,b,p\)</span>我们是已知的，不防这样构造格<span class="math inline">\(L\)</span>, <span class="math display">\[(k,-m,1)\begin{pmatrix}p,\textit{ }\textit{ }0,\textit{ }0\\b,\textit{}\textit{ }1,\textit{ }0\\\textit{ }\textit{ }\textit{ }\textit{ }a\textit{ },\textit{ }\textit{}0,\textit{ }2^{400}\end{pmatrix}=(c,m,2^{400})\]</span> <strong>这里我们需要解释一下，格<span class="math inline">\(L\)</span>最后一列为什么那样构造。（这里参考了DexterJie师傅的博客）</strong></p><p><strong>我们已经知道，<span class="math inline">\(LLL\)</span>是一种格基规约算法，是用来解决<span class="math inline">\(SVP\)</span>问题的。我们可以根据<span class="math inline">\(Hermite\)</span>定理知道最短向量的上限。即</strong><span class="math display">\[\lambda(L)\leqslant\sqrt{n}\sqrt[n]{det(\lambda)}\]</span> <strong>我们注意到<span class="math inline">\(c=400\textit{}bit,m=351\textit{ }bit\)</span>,所以向量<span class="math inline">\((c,m,?)\)</span>的长度应该在<span class="math inline">\(400\textit{ }bit\)</span>左右。</strong></p><p><strong>所以 <span class="math inline">\(400\leqslant\sqrt{3}\sqrt[3]{det(L)}\)</span>,所以<span class="math inline">\(?\)</span>应该大于等于<span class="math inline">\(180\textit{}bit\)</span>???</strong>(这里我还是比较有疑惑的），附上<span class="math inline">\(DexterJie\)</span>师傅的理解吧</p><p><img src="/2023/08/25/%E6%A0%BC%E5%AF%86%E7%A0%81/image-20230825154823222.png"></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = 92716521851427599147343828266552451834533034815416003395170301819889384044273026852184291232938197215198124164263722270347104189412921224361134013717269051168246275213624264313794650441268405062046423740836145678559969020294978939553573428334198212792931759368218132978344815862506799287082760307048309578592</span><br><span class="line">b = 155530728639099361922541063573602659584927544589739208888076194504495146661257751801481540924821292656785953391450218803112838556107960071792826902126414012831375547340056667753587086997958522683688746248661290255381342148052513971774612583235459904652002495564523557637169529882928308821019659377248151898663</span><br><span class="line">p = 100910862834849216140965884888425432690937357792742349763319405418823395997406883138893618605587754336982681610768197845792843123785451070312818388494074168909379627989079148880913190854232917854414913847526564520719350308494462584771237445179797367179905414074344416047541423116739621805238556845903951985783</span><br><span class="line"></span><br><span class="line"># a*r = flag + k*p</span><br><span class="line">M = Matrix(ZZ,[[p,0,0],[a,2^200,0],[-b,0,1]]) # Matrix()函数通常采用数值作为参数并返回一个矩阵对象</span><br><span class="line">c,k,m = M.LLL()[0]</span><br><span class="line">&#x27;&#x27;&#x27;LLL 算法是一种格约化算法，用于查找格的约简基。</span><br><span class="line">LLL 方法返回一个由两个元素组成的元组：</span><br><span class="line">简化基和将原始基转换为简化基的矩阵&#x27;&#x27;&#x27;</span><br><span class="line">print(m)</span><br><span class="line">flag = long_to_bytes(abs(m))   # abs()返回数字的绝对值</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h2 id="p6-多组enc"><strong>P6 (多组e,n,c)</strong></h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line">d = getPrime(400)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(4):</span><br><span class="line">    p = getPrime(512)</span><br><span class="line">    q = getPrime(512)</span><br><span class="line">    n = p * q</span><br><span class="line">    e = inverse(d, (p-1)*(q-1))</span><br><span class="line">    c = pow(flag, e, n)</span><br><span class="line">    print(f&#x27;e&#123;i&#125; =&#x27;, e)</span><br><span class="line">    print(f&#x27;n&#123;i&#125; =&#x27;, n)</span><br><span class="line">    print(f&#x27;c&#123;i&#125; =&#x27;, c)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">e0 = 14663634286442041092028764808273515750847961898014201055608982250846018719684424125895815390624536073501623753618354026800118456911536861815261996929625814961086913500837475340797921236556312296934664701095834187857404704711288771338418177336783911864595983563560080719582434186801068157426993026446515265411</span><br><span class="line">n0 = 104543450623548393448505960506840545298706691237630183178416927557780858213264769135818447427794932329909731890957245926915280713988801182894888947956846369966245947852409172099018409057129584780443712258590591272371802134906914886744538889099861890573943377480028655951935894660286388060056770675084677768397</span><br><span class="line">c0 = 66400441793466385558399002350812383744096354576421495899465166492721568297592616443643465864544107914461044325088868615645524260480104397769130582397209585192620565774001015221725536884170662700337565613181799442382460047295553807602785067421981837709831158111951991854109179278733629950271657405211417740374</span><br><span class="line">e1 = 62005504700456859456675572895620453845623573672275890584145949847469951381521709553504593023003977393014834639251022203398533914340078480147377747715528821418445514563871411209895815634752533151145061594791024551625615960423026244560340983481137777162236719939420428613005457949228517914830194749293637917667</span><br><span class="line">n1 = 89410873947410184231222334229470195622685051370058935269198780539059522679122059486414591834635266301335656798768270022060656655274640699951736588085471509424575027153387518893978494158981314217195561629375189515702124478687925014362857206223379284909134299260355456357407022417434961226383007916607728238843</span><br><span class="line">c1 = 75133250536426006056029454024900058936095761927174304108454764308417889983571094946046507426319589437822458959089546795698076608690695326741772662156830944126301658579142020817338297043884836598263468494533324693019866746045910394812656639124276516075062088756043949581789436307373276242558429450971458945061</span><br><span class="line">e2 = 5365316217065391632204029784515519544882379449147835081003675696051077792179684123668298103660153980837519314114793091112163153158510344440829742753002176560016265852613076363394396640641504813912550948776926622696268531691467015580417575287779607009068332802842890478748171958455354463809356050553832863427</span><br><span class="line">n2 = 53325942266099921615667538877103327425435396909592382386684073177331528393295928518724880712900970020425481561110366696624090824641115147978830715508666547064446891727446073538022824237798568413003419382767587742032676311751819789672319289920011033523044026418650515529084031754775286163358926609712626506433</span><br><span class="line">c2 = 22289960513520782629306709529908652726794465066357062923684089176607114605563538085483920152508469429311012652149406853144200001391310165612163442404181970125704785325670969551080086517236489885046039799676581310781945432599048686184762485374030278657826206433571162451649808912276118945302558580745346371321</span><br><span class="line">e3 = 57257245945110486431680573908783487217316546039634811903637650579658516537372808464426294780698320301497615457264001148504941375058983426920721566040576604013497311914160175024860226623138659970105781812246471618831032554729317463745699993647224910498474869868186318188994237457335796911524629938029123055027</span><br><span class="line">n3 = 97233843381238063550322854422952777734101562842513647224354265328843953949189054347560960321126304504554067163501318212533606313039536188796999575130115659250566231010092273206623114900781284076452654791214088764465615154940874231056251107863895697778665275804663487113266180838319536762473697586368100928379</span><br><span class="line">c3 = 56606672064789484727896188434430896229911224588055894584797861263107870392831242138537980507537270618683458635389444257040355313948352917061971042629958646854593628522401074068536976581232979947149230764268377747754284783531803366391759725774562719884482404532619163798580872386794273190532863916038929461465</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf</p><p><span class="math display">\[c_{0} = m^{e_{0}} \pmod{n_{0}}\]</span></p><p><span class="math display">\[c_{1} = m^{e_{1}} \pmod{n_{1}}\]</span></p><p><span class="math display">\[c_{2} = m^{e_{2}} \pmod{n_{2}}\]</span></p><p><span class="math display">\[c_{3} = m^{e_{3}} \pmod{n_{3}}\]</span></p><p>分割 <span class="math display">\[M = \sqrt{n_{0}}\]</span></p><p><span class="math display">\[\left[ \begin{matrix} M &amp; e_{0} &amp; e_{1} &amp; e_{2} &amp; e_{3}\\ 0 &amp; -n_{0}&amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -n_{1} &amp;0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -n_{2} &amp; 0 \\ 0 &amp; 0 &amp; 0&amp; 0 &amp; -n_{3} \end{matrix} \right]\]</span></p><p><span class="math display">\[hh = L.LLL()\]</span></p><p><span class="math display">\[d = hh // M\]</span></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">e0 = 14663634286442041092028764808273515750847961898014201055608982250846018719684424125895815390624536073501623753618354026800118456911536861815261996929625814961086913500837475340797921236556312296934664701095834187857404704711288771338418177336783911864595983563560080719582434186801068157426993026446515265411</span><br><span class="line">n0 = 104543450623548393448505960506840545298706691237630183178416927557780858213264769135818447427794932329909731890957245926915280713988801182894888947956846369966245947852409172099018409057129584780443712258590591272371802134906914886744538889099861890573943377480028655951935894660286388060056770675084677768397</span><br><span class="line">c0 = 66400441793466385558399002350812383744096354576421495899465166492721568297592616443643465864544107914461044325088868615645524260480104397769130582397209585192620565774001015221725536884170662700337565613181799442382460047295553807602785067421981837709831158111951991854109179278733629950271657405211417740374</span><br><span class="line">e1 = 62005504700456859456675572895620453845623573672275890584145949847469951381521709553504593023003977393014834639251022203398533914340078480147377747715528821418445514563871411209895815634752533151145061594791024551625615960423026244560340983481137777162236719939420428613005457949228517914830194749293637917667</span><br><span class="line">n1 = 89410873947410184231222334229470195622685051370058935269198780539059522679122059486414591834635266301335656798768270022060656655274640699951736588085471509424575027153387518893978494158981314217195561629375189515702124478687925014362857206223379284909134299260355456357407022417434961226383007916607728238843</span><br><span class="line">c1 = 75133250536426006056029454024900058936095761927174304108454764308417889983571094946046507426319589437822458959089546795698076608690695326741772662156830944126301658579142020817338297043884836598263468494533324693019866746045910394812656639124276516075062088756043949581789436307373276242558429450971458945061</span><br><span class="line">e2 = 5365316217065391632204029784515519544882379449147835081003675696051077792179684123668298103660153980837519314114793091112163153158510344440829742753002176560016265852613076363394396640641504813912550948776926622696268531691467015580417575287779607009068332802842890478748171958455354463809356050553832863427</span><br><span class="line">n2 = 53325942266099921615667538877103327425435396909592382386684073177331528393295928518724880712900970020425481561110366696624090824641115147978830715508666547064446891727446073538022824237798568413003419382767587742032676311751819789672319289920011033523044026418650515529084031754775286163358926609712626506433</span><br><span class="line">c2 = 22289960513520782629306709529908652726794465066357062923684089176607114605563538085483920152508469429311012652149406853144200001391310165612163442404181970125704785325670969551080086517236489885046039799676581310781945432599048686184762485374030278657826206433571162451649808912276118945302558580745346371321</span><br><span class="line">e3 = 57257245945110486431680573908783487217316546039634811903637650579658516537372808464426294780698320301497615457264001148504941375058983426920721566040576604013497311914160175024860226623138659970105781812246471618831032554729317463745699993647224910498474869868186318188994237457335796911524629938029123055027</span><br><span class="line">n3 = 97233843381238063550322854422952777734101562842513647224354265328843953949189054347560960321126304504554067163501318212533606313039536188796999575130115659250566231010092273206623114900781284076452654791214088764465615154940874231056251107863895697778665275804663487113266180838319536762473697586368100928379</span><br><span class="line">c3 = 56606672064789484727896188434430896229911224588055894584797861263107870392831242138537980507537270618683458635389444257040355313948352917061971042629958646854593628522401074068536976581232979947149230764268377747754284783531803366391759725774562719884482404532619163798580872386794273190532863916038929461465</span><br><span class="line"></span><br><span class="line">M = gmpy2.iroot(n0,2)[0]</span><br><span class="line">mat = [[M, e0, e1, e2,e3],</span><br><span class="line">       [0,-n0,  0,  0, 0],</span><br><span class="line">       [0,  0,-n1,  0, 0],</span><br><span class="line">       [0,  0,  0,-n2, 0],</span><br><span class="line">       [0,  0,  0,  0,-n3]]</span><br><span class="line">L = Matrix(ZZ,mat)</span><br><span class="line">hh = L.LLL()[0]</span><br><span class="line">d = hh[0] // M</span><br><span class="line">m = gmpy2.powmod(c0,d,n0)</span><br><span class="line">flag = long_to_bytes(m)</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line"># NSSCTF&#123;12514adb-2c14-4777-96ff-90e95bc2b5cb&#125;</span><br></pre></td></tr></table></figure><h2 id="p7-扩展维纳攻击-两个小解密指数的情况">P7 (扩展维纳攻击两个小解密指数的情况)</h2><p>https://ctf-wiki.org/crypto/asymmetric/rsa/d_attacks/rsa_extending_wiener/</p><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p * q</span><br><span class="line">c = pow(flag, 65537, n)</span><br><span class="line">print(f&#x27;n =&#x27;, n)</span><br><span class="line">print(f&#x27;c =&#x27;, c)</span><br><span class="line">for i in range(2):</span><br><span class="line">    d = getPrime(350)</span><br><span class="line">    e = inverse(d, (p-1)*(q-1))</span><br><span class="line">    print(f&#x27;e&#123;i&#125; =&#x27;, e)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 110697784133988071803253124431092603234028687101567047811203431433689306543322837414808117411806181193598553341878079973980865551938790090419082150555675782822484149943421418447579383449269148197087985041351210982545320569973241390962326458234562044133505940521052500278777242988196544039226173227204865907343</span><br><span class="line">c = 3281096209929505523196793672137624804022934270452947405454462490250571524417033484978613243658208567511735641542935158434165363547355697159503378251318054879687577130170122911449101189974762808655638497967674004219512386442280269940950792767174561412932638740423542930763914255112354969122157915514816022159</span><br><span class="line">e0 = 28562806554366667733480283991307446762365777397933141571728113235368201162305126722188842319240464207580134816039095093401651171977877327756351539588974913736802534970867173212883308325913939353140276201705478124488858328502643345172188729914731042179091733244225184522680724392375975935305371163502863968963</span><br><span class="line">e1 = 28572469216883232254074869113744730984165641173439644880182528671699871929340616919028955398474678696802739685594548793470261306125219888911330937557582939811068530294470712859439149735950996866732508004061234613146407591546995439312326450834903885979660916965052092661398640105827442036234500556755520316031</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>使用 <span class="math display">\[W_1,G_{1,2},W_1*W_2\]</span> 来构造格子</p><p>考虑先构造一个对角矩阵<span class="math inline">\(D\)</span>, <span class="math display">\[D=\begin{pmatrix} N &amp; &amp; &amp; \\ &amp; N^{1/2} &amp; &amp; \\&amp; &amp; N^{1+\alpha 2} &amp; \\ &amp; &amp; &amp; 1 \end{pmatrix}\]</span> 最终我们构造的矩阵为 <span class="math display">\[L=\begin{pmatrix} 1 &amp; -N&amp;0 &amp;N^{2} \\ &amp;e_{1} &amp;-e_{1}&amp;-e_{1}N \\ &amp; &amp; e^{_{2}} &amp;-e_{2}N \\ &amp; &amp; &amp;e_{1}e_{2} \end{pmatrix}*D\]</span> exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line">N = 110697784133988071803253124431092603234028687101567047811203431433689306543322837414808117411806181193598553341878079973980865551938790090419082150555675782822484149943421418447579383449269148197087985041351210982545320569973241390962326458234562044133505940521052500278777242988196544039226173227204865907343</span><br><span class="line">c = 3281096209929505523196793672137624804022934270452947405454462490250571524417033484978613243658208567511735641542935158434165363547355697159503378251318054879687577130170122911449101189974762808655638497967674004219512386442280269940950792767174561412932638740423542930763914255112354969122157915514816022159</span><br><span class="line">e1 = 28562806554366667733480283991307446762365777397933141571728113235368201162305126722188842319240464207580134816039095093401651171977877327756351539588974913736802534970867173212883308325913939353140276201705478124488858328502643345172188729914731042179091733244225184522680724392375975935305371163502863968963</span><br><span class="line">e2 = 28572469216883232254074869113744730984165641173439644880182528671699871929340616919028955398474678696802739685594548793470261306125219888911330937557582939811068530294470712859439149735950996866732508004061234613146407591546995439312326450834903885979660916965052092661398640105827442036234500556755520316031</span><br><span class="line">e=65537</span><br><span class="line">a = 5/14</span><br><span class="line">D = diagonal_matrix(ZZ, [N, int(N^(1/2)), int(N^(1+a)), 1]) #创建对角矩阵</span><br><span class="line">M = matrix(ZZ, [[1, -N, 0, N^2], [0, e1, -e1, -e1*N], [0, 0, e2, -e2*N], [0, 0, 0, e1*e2]])*D</span><br><span class="line">L = M.LLL()</span><br><span class="line">t = vector(ZZ, L[0])  #创建一个管理，管理是一维数组或列表</span><br><span class="line"></span><br><span class="line">x = t * M^(-1)</span><br><span class="line">phi = int(x[1]/x[0]*e1)</span><br><span class="line">          </span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = gmpy2.powmod(c,d,N)</span><br><span class="line">flag = long_to_bytes(int(m))</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line">#  NSSCTF&#123;00121664-7e76-4f6f-a2f7-4813e21ff4aa&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明一下<span class="math inline">\(diagonal_matrix(zz,)\)</span>是在整数域上创建一个对角矩阵。</p>]]></content>
      
      
      <categories>
          
          <category> 格密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔二</title>
      <link href="/2023/08/22/%E9%9A%8F%E7%AC%94%E4%BA%8C/"/>
      <url>/2023/08/22/%E9%9A%8F%E7%AC%94%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="化简s-powp-q-n-powq-p-ntextbf-modtextbf-npq都是素数且npq">化简<span class="math inline">\(s = (pow(p, q, n) + pow(q, p, n))\textbf{ }mod\textbf{ } n,p,q都是素数且n=p*q\)</span></h2><p><span class="math display">\[s = (pow(p, q, n) + pow(q, p, n))\textbf{ } mod\textbf{ } n\]</span></p><p><span class="math display">\[=p^{q}\textbf{ }mod\textbf{ }n+q^{p}\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[=p^{q}\textbf{ }mod\textbf{ }(p*q)+q^{p}\textbf{ }mod\textbf{ }(p*q)\]</span></p><p><span class="math display">\[=(p^{q}\textbf{ }mod\textbf{ }p+p^{q}\textbf{ }mod\textbf{}q)+(q^{p}\textbf{ }mod\textbf{ }p+q^{p}\textbf{ }mod\textbf{ }q)\]</span></p><p><span class="math display">\[=p^{q}\textbf{ }mod\textup{ }q+q^{p}\textup{ }mod\textbf{ }p\]</span></p><p>由费马小定理可知，<span class="math inline">\(a^{p-1}=1\textbf{}mod\textbf{ }p,p是素数\)</span></p><p>所以<span class="math inline">\(p^{q}\textbf{ }mod\textbf{}q=(p^{q-1})*p\textbf{ }mod\textbf{ }q=p\textbf{ }mod\textbf{}q\)</span></p><p>同理可得<span class="math inline">\(q^{p}\textbf{ }mod\textbf{}p=q\textbf{ }mod\textbf{ }p\)</span></p><p>综上，<span class="math inline">\(s = (pow(p, q, n) + pow(q, p,n))\textbf{ } mod\textbf{ } n=p+q\)</span></p><h2 id="爆破4位md5值脚本">爆破4位md5值脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from hashlib import md5</span><br><span class="line">from itertools import product</span><br><span class="line">table=&quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&quot;</span><br><span class="line">tail=&quot;gcwJ&quot;</span><br><span class="line">_hash=&quot;f383dc8fd2157374dc2aec9df83df320&quot;</span><br><span class="line">for i in product(table, repeat=4):</span><br><span class="line">    head = &#x27;&#x27;.join(i)</span><br><span class="line">    t = md5((head + tail).encode()).hexdigest()</span><br><span class="line">    if t == _hash:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure><p>十秒内出结果。</p><h2 id="python的排列组合函数">Python的排列组合函数</h2><p><strong>itertools模块</strong>下提供了一些用于生成排列组合的工具函数。</p><ul><li>product(p, q, …[repeat=1])：用序列p、q、...序列中的元素进行排列（<strong>元素会重复</strong>）。就相当于使用嵌套循环组合。</li><li>permutations(p[,r])：从序列p中取出r个元素的组成<strong>全排列</strong>，组合得到元组作为新迭代器的元素。</li><li>combinations(p,r)：从序列p中取出r个元素组成全组合，<strong>元素不允许重复</strong>，组合得到元组作为新迭代器的元素。</li><li>combinations_with_replacement(p,r)，从序列p中取出r个元素组成全组合，<strong>元素允许重复</strong>，组合得到元组作为新迭代器的元素。</li></ul><p>如下程序示范了上面4个函数的用法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import itertools as it</span><br><span class="line"></span><br><span class="line"># 使用两个序列进行排列组合</span><br><span class="line">for e in it.product(&#x27;AB&#x27;, &#x27;CD&#x27;):</span><br><span class="line">    print(&#x27;&#x27;.join(e), end=&#x27;, &#x27;) # AC, AD, BC, BD,</span><br><span class="line">print(&#x27;\n---------&#x27;)</span><br><span class="line"># 使用一个序列、重复2次进行全排列</span><br><span class="line">for e in it.product(&#x27;AB&#x27;, repeat=2):</span><br><span class="line">    print(&#x27;&#x27;.join(e), end=&#x27;, &#x27;) # AA, AB, BA, BB,</span><br><span class="line">print(&#x27;\n---------&#x27;)</span><br><span class="line"># 从序列中取2个元素进行排列</span><br><span class="line">for e in it.permutations(&#x27;ABCD&#x27;, 2):</span><br><span class="line">    print(&#x27;&#x27;.join(e), end=&#x27;, &#x27;) # AB, AC, AD, BA, BC, BD, CA, CB, CD, DA, DB, DC,</span><br><span class="line">print(&#x27;\n---------&#x27;)</span><br><span class="line"># 从序列中取2个元素进行组合、元素不允许重复</span><br><span class="line">for e in it.combinations(&#x27;ABCD&#x27;, 2):</span><br><span class="line">    print(&#x27;&#x27;.join(e), end=&#x27;, &#x27;) # AB, AC, AD, BC, BD, CD,</span><br><span class="line">print(&#x27;\n---------&#x27;)</span><br><span class="line"># 从序列中取2个元素进行组合、元素允许重复</span><br><span class="line">for e in it.combinations_with_replacement(&#x27;ABCD&#x27;, 2):</span><br><span class="line">    print(&#x27;&#x27;.join(e), end=&#x27;, &#x27;) # AA, AB, AC, AD, BB, BC, BD, CC, CD, DD,</span><br></pre></td></tr></table></figure><p>上面程序用到了一个字符串的join()方法，该方法用于将元组的所有元素都连接成一个字符串。</p><h2 id="rsa中已知phi和n分解n">RSA中已知phi和n分解n</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from math import gcd</span><br><span class="line">from math import isqrt</span><br><span class="line">from random import randrange</span><br><span class="line">from gmpy2 import is_prime</span><br><span class="line"># from sage.all import is_prime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def factorize(N, phi):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    如果欧拉系数已知，则从模中恢复素因数。</span><br><span class="line">    此方法仅适用于由 2 个素数组成的模！</span><br><span class="line">    :param N: 模数</span><br><span class="line">    :param phi: 欧拉 totient，乘法群模 N 的阶数</span><br><span class="line">    :return: 包含素因数的元组，如果未找到因数则返回 None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    s = N + 1 - phi       # p+q</span><br><span class="line">    d = s ** 2 - 4 * N    # （p-q)^2</span><br><span class="line">    p = int(s - isqrt(d)) // 2</span><br><span class="line">    q = int(s + isqrt(d)) // 2</span><br><span class="line">    return p, q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def factorize_multi_prime(N, phi):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Recovers the prime factors from a modulus if Euler&#x27;s totient is known.</span><br><span class="line">    This method works for a modulus consisting of any number of primes, but is considerably be slower than factorize.</span><br><span class="line">    More information: Hinek M. J., Low M. K., Teske E., &quot;On Some Attacks on Multi-prime RSA&quot; (Section 3)</span><br><span class="line">    :param N: the modulus</span><br><span class="line">    :param phi: Euler&#x27;s totient, the order of the multiplicative group modulo N</span><br><span class="line">    :return: a tuple containing the prime factors</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    prime_factors = set()</span><br><span class="line">    factors = [N]</span><br><span class="line">    while len(factors) &gt; 0:</span><br><span class="line">        # Element to factorize.</span><br><span class="line">        N = factors[0]</span><br><span class="line"></span><br><span class="line">        w = randrange(2, N - 1)</span><br><span class="line">        i = 1</span><br><span class="line">        while phi % (2 ** i) == 0:</span><br><span class="line">            sqrt_1 = pow(w, phi // (2 ** i), N)  </span><br><span class="line">            if sqrt_1 &gt; 1 and sqrt_1 != N - 1:      # 计算非平凡平方根</span><br><span class="line">                # We can remove the element to factorize now, because we have a factorization.</span><br><span class="line">                factors = factors[1:]</span><br><span class="line"></span><br><span class="line">                p = gcd(N, sqrt_1 + 1)</span><br><span class="line">                q = N // p</span><br><span class="line"></span><br><span class="line">                if is_prime(p):</span><br><span class="line">                    prime_factors.add(p)</span><br><span class="line">                elif p &gt; 1:</span><br><span class="line">                    factors.append(p)</span><br><span class="line"></span><br><span class="line">                if is_prime(q):</span><br><span class="line">                    prime_factors.add(q)</span><br><span class="line">                elif q &gt; 1:</span><br><span class="line">                    factors.append(q)</span><br><span class="line"></span><br><span class="line">                # Continue in the outer loop</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            i += 1</span><br><span class="line"></span><br><span class="line">    return tuple(prime_factors)</span><br><span class="line">    </span><br><span class="line">N = </span><br><span class="line">phi = </span><br><span class="line">prime = factorize_multi_prime(N,phi)</span><br><span class="line">print(prime)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格的初探</title>
      <link href="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/"/>
      <url>/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="格的定义">格的定义</h2><p>任何一组<strong>线性无关</strong>的向量所生成的<strong>系数为整数</strong>的<strong>向量集合</strong>称为格。</p><p>即<br><span class="math display">\[L=\begin{Bmatrix} a_{1}\nu _{1}+a_{2}\nu  _{2}+...+a_{n}\nu_{n},&amp;a_{1},a_{2},...,a_{n}\in Z \end{Bmatrix}\]</span> 这一组线性无关的向量<span class="math inline">\(v_{1},v_{2},...,v_{n}\)</span>就是格<span class="math inline">\(L\)</span>的基。格<span class="math inline">\(L\)</span>的元素是<span class="math inline">\(v_{1},v_{2},...,v_{n}\)</span>的整系数线性组合。某种程度上，格可以理解为<strong>系数为整数的向量空间。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Harry0597/Imag@master/uPic/image-20221115221257017.png"></p><h2 id="格基变换">格基变换</h2><p>格的基是一组<strong>线性无关的向量</strong>，由这一组向量可以生成完整的格。也就是可以由它们线性组合构成所有的格点。基所包含的<strong>向量个数</strong>成为格的<strong>维度</strong>。通常，<strong>一个格可以有多组基</strong>，也就是说，不同的基可能生成同一个格。</p><p><img src="https://cdn.jsdelivr.net/gh/Harry0597/Imag@master/uPic/image-20221130231915760.png"></p><p>那么如何判断两组格基可以生成同一个格？</p><p>如果把格基用矩阵表示（列向量为每一个基），则对格基做以下操作，对应的格不变：</p><p>1.列向量交换：<span class="math inline">\(v_{i}\leftrightarrowv_{j}\)</span></p><p>2.向量取负：<span class="math inline">\(v_{i}\leftrightarrow-v_{i}\)</span></p><p>3.给一个向量加上k乘另一个向量：<span class="math inline">\(v_{i}\leftrightarrow v_{i}+k*v_{j}\)</span></p><p>更加有趣的是，上述操作均对应为<strong>给格基矩阵右乘一个幺模矩阵</strong>，幺模矩阵是一种特殊矩阵，其为<strong>整数矩阵</strong>，其行列式的值为<strong>正负1</strong>，且这种矩阵的乘法具有封闭性，幺模矩阵的乘积仍为幺模矩阵。</p><p><strong>定理：两个格基等价，当且仅当可以把两格基写成以下格式：</strong><span class="math display">\[B_{2}=B_{1}U\]</span> 其中，<span class="math inline">\(U\)</span>是一个幺模矩阵。</p><p>假定<span class="math inline">\(v_{1},v_{2},...,v_{n}\)</span>是格的一组基，<span class="math inline">\(w_{1},w_{2},...,w{n}\inL\)</span>，则必然存在整系数<span class="math inline">\(a_{ij}\)</span>使得 <span class="math display">\[\left\{\begin{matrix}w_{1} =a_{11}v_{1}+a_{12}v_{2}+...+a_{1n}v_{n}\\w_{2}=a_{21}v_{1}+a_{22}v_{2}+...+a_{2n}v_{n}\\...\\w_{n}=a_{n1}v_{1}+a_{n2}v_{2}+...+a_{nn}v_{n}\end{matrix}\right.\]</span>这样，格的问题，我们就可以<strong>转化为矩阵运算</strong>了。</p><h2 id="格的基本域">格的基本域</h2><h3 id="什么是基本域">什么是基本域</h3><p><img src="https://www.ruanx.net/content/images/2021/01/image.png"></p><p>几何上，基本域就是<strong>这组基围出的区域</strong>，如上图中的阴影部分。</p><h3 id="基本域的性质">基本域的性质</h3><p>一个 lattice会有不同的基，也就会有不同的基本域，但<strong>每个基本域的体积(无论什么形状的)都一样</strong>。</p><h3 id="基本域的应用">基本域的应用</h3><p>另外，我们还可以将空间中的点映射到基本域上，判断<strong>点是否在格上</strong>。</p><p>基本域的表示方法：</p><p>​<br><span class="math display">\[P(B)=a_{1}v_{1}+a_{2}v_{2}+...+a_{n}v_{n},a_{i}\in [0,1)\]</span></p><p>现在假设空间中有一个点，表示为</p><p>​<br><span class="math display">\[x=a_{1}v_{1}+a_{2}v_{2}+...+a_{n}v_{n}\]</span> 那么当对这个点在基本域范围内做模运算时，只需把每个系数<span class="math inline">\(a_{i}\)</span>模1乘上基向量即可。</p><p>​<br><span class="math display">\[x\textbf{ }mod\textbf{ }P(B)=(a_{1}\textbf{ }mod\textbf{}1)*v_{1}+(a_{2}\textbf{ }mod\textbf{ }1)*v_{2}+...+(a_{n}\textbf{}mod\textbf{ }1)*v_{n}\]</span> 这样就把这个点映射到基本域上了。</p><h2 id="行列式协体积">行列式（协体积）</h2><p>格的行列式是<strong>基向量构成的多面体的体积</strong>（标量），也就是基本域的体积。前面说过格的每个基本域的体积是相等的，所以<strong>行列式是格的固有属性</strong>，同一个格选取的不同组基，行列式是相等的。</p><p>前面也讲过格基变换，两组基要生成同一个格，当且仅当两者可以乘一个幺模矩阵进行相互转化，即</p><p>​<br><span class="math display">\[|det(BU)|=|det(B)det(U)|=|det(B)|\]</span>需要注意的是，<strong>行列式可以用来衡量格密度的大小，若行列式越大，格密度越小</strong>。</p><p>再来看一下<strong>协体积的上限</strong>。 若构成 lattice的基向量长度固定，要想得到<strong>最大的协体积</strong>，必然各个基向量都要是<strong>正交</strong>的（类比，长度相同的四条线段要围成平行四边形，当且仅当是正方形是面积最大），于是我们就得到了协体积的上限:</p><p>​<br><span class="math display">\[设L是一个格，F是L的一个基本域，任取一组基向量V_{1},v_{2},..,v_{n}，\\那                             么|det(L)|=Vol(F)\leqslant||v_{1}||*||v_{2}||*...*||v_{n}||\]</span><strong>基向量的各个向量越趋近于正交，行列式越接近上限，当是正交时，上面不等式取到等号</strong>。</p><h2 id="格的困难问题">格的困难问题</h2><h3 id="svpthe-shortest-vector-problem">SVP(The shortest vectorproblem)</h3><p>最短向量问题:找到格中的最短向量，也就是在格中找到一个非零向量<span class="math inline">\(v\in L\)</span>使得<span class="math inline">\(||v||\)</span>最小。</p><h4 id="svp的上限">SVP的上限</h4><p>一个格的最短非零向量到底有多短呢？这其实是<strong>和格的维度以及行列式有关</strong>。</p><p>根据Hermite定理， 有</p><p>​<br><span class="math display">\[\lambda (\Lambda )\leqslant \sqrt{n}*\sqrt[n]{det(\Lambda )}\]</span> ​</p><p>其中，<span class="math inline">\(\Lambda\)</span>是格基矩阵，<span class="math inline">\(\lambda (\Lambda )\)</span>是格中最短向量，<span class="math inline">\(det()\)</span>是行列式</p><h3 id="cvpthe-closest-vector-problem">CVP(<strong>The Closest VectorProblem</strong>)</h3><p>最近向量问题：给定格外的一个点，找到格中离它最近或近似最近的格点。CVP一般要比SVP困难的多，<strong>SVP可以规约到CVP</strong>。</p><h2 id="lll算法格基规约">LLL算法(格基规约)</h2><p>在1982年，A.K.Lenstra，H.W.Lenstra,Jr 和 L.lovasz 提出一种解决 SVP问题的算法，通常称之为<span class="math inline">\(LLL\)</span>算法，它是一种<strong>格基规约算法</strong>。</p><p>在求解 SVI的问题时，最先想到的是对格基进行多种线性组合的尝试，其中最难的问题是如何<strong>基向量变小</strong>，<strong>使基向量最大程度的趋于正交化。</strong></p><p><img src="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img1.png"></p><p>需要 Gram-Schmidt(施密特) 正交化知识的铺垫。</p><h3 id="gram-schmidt施密特-正交化">Gram-Schmidt(施密特) 正交化</h3><p><span class="math display">\[如果x_{1},x_{2},...,x_{n}是某向量空间中的基，那么可通过下列做法找到该向量空间中的n个两两正交的向量\\v_{1},v_{2},...,v_{n},称为施密特正交化。v_{1},v_{2},...,v_{n}就是该向量空间中的一组正交基。\]</span></p><figure><img src="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>现在我们对探讨如何寻找二维空间的正交基。</p><p>下图是二维空间<span class="math inline">\(R^{n}\)</span>的一组基</p><p><img src="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img3.png"></p><p>只要将其中一个向量对另外一个向量进行投影，就可以得到<span class="math inline">\(R^{n}\)</span> 的一组正交基：</p><p><img src="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img4.gif"></p><p>下面我们来进行代数推导，假设基为<span class="math inline">\(x_{1},x_{2}\)</span>，选择<span class="math inline">\(x_{1}\)</span>作为<span class="math inline">\(v_{1}\)</span>,作出<span class="math inline">\(x_{2}\)</span>在<span class="math inline">\(v_{1}\)</span>所在直线上的投影<span class="math inline">\(\vec{x_{2}}\)</span>,连接<span class="math inline">\(x_{2},\vec{x_{2}}\)</span>所得到垂线就是<span class="math inline">\(v_{2}\)</span></p><p><img src="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img4.png"> <span class="math display">\[\left\{\begin{matrix}v_{1} =x_{2}\\v_{2}=x_{2}-\vec{x_{2}}\end{matrix}\right.\Rightarrow \left\{\begin{matrix}v_{1} =x_{2}\\v_{2}=v_{1}-\vec{kv_{1}}\end{matrix}\right.\]</span></p><p><span class="math display">\[由v_{1}v_{2}=0得v_{1}*(v_{1}-kv_{2})=0\Rightarrowk=\frac{v_{2}v_{1}}{v_{1}v_{1}}\]</span></p><p><span class="math display">\[\therefore该向量空间的一组正交基为 \left\{\begin{matrix}v_{1}=x_{1}\\v_{2}=v_{1}-\frac{v_{2}v_{1}}{v_{1}v_{1}}\end{matrix}\right.\]</span></p><p>这样就可以推广到<span class="math inline">\(n\)</span>维向量空间施密特正交化了。</p><h3 id="格基规约的条件">格基规约的条件</h3><p><span class="math inline">\(LLL\)</span>格基规约需要满足以下两个条件： <span class="math display">\[{\forall}1\leq i\leqslant n,j&lt; i,|u_{i,j}|\leq \frac{1}{2}\]</span></p><p><span class="math display">\[{\forall}1\leq i&lt; n,\delta ||b_{i}||^{2}\leqslant||u_{i+1,i}b_{i}+b_{i+1}||^2\]</span></p><p><span class="math inline">\(LLL\)</span>算法最终输出的基称为<span class="math inline">\(LLL\)</span>约化基。</p><h3 id="格基约化的性质">格基约化的性质</h3><p>1、<span class="math inline">\(\delta=\frac{3}{4}\)</span>是该算法的一个特例，<span class="math inline">\(LLL\)</span>算法成立的前提是<span class="math inline">\(\frac{1}{4}&lt; \delta&lt; 1\)</span>.</p><p>2、根据格约化基的定义得， <span class="math display">\[\delta ||b_{i}||^{2}\leqslant||u_{i+1,i}b_{i}+b_{i+1}||^2=u_{i+1,i}^2||b_{i}||^2+||b_{i+1}||^2\]</span></p><p><span class="math display">\[\therefore ||b_{i+1}||^2\geq (\delta -u_{i+1,i}^2)||b_{i}||^2=(\delta-\frac{1}{4})||b_{i}||^2\]</span></p><p>所以<span class="math inline">\(b_{i+1}\)</span>不会比<span class="math inline">\(b_{i}\)</span>短太多。</p><h2 id="例题">例题</h2><p>例题来自 NSSCTF 平台。之前看了格密码理论和做题联系不起来，看了DexterJie 师傅的博客后受益匪浅。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p = getPrime(1024)</span><br><span class="line"></span><br><span class="line">f = getPrime(400)</span><br><span class="line">g = getPrime(512)</span><br><span class="line">r = getPrime(400)</span><br><span class="line"></span><br><span class="line">h = inverse(f, p) * g % p</span><br><span class="line"></span><br><span class="line">m = b&#x27;******&#x27;</span><br><span class="line">m = bytes_to_long(m)</span><br><span class="line"></span><br><span class="line">c = (r*h + m) % p</span><br><span class="line"></span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line">print(f&#x27;h = &#123;h&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p = 170990541130074930801165526479429022133700799973347532191727614846803741888876816210632483231997413973919037199883422312436314365293577997262903161076615619596783971730864586404602951191341733308807254112018161897113881363794353050758324742415299277578203838160939521046655099610387485947145087271531951477031</span><br><span class="line">h = 19027613518333504891337723135627869008620752060390603647368919831595397216728378486716291001290575802095059192000315493444659485043387076261350378464749849058547797538347059869865169867814094180939070464336693973680444770599657132264558273692580535803622882040948521678860110391309880528478220088107038861065</span><br><span class="line">c = 75639016590286995205676932417759002029770539425113355588948888258962338419567264292295302442895077764630601149285564849867773180066274580635377957966186472159256462169691456995594496690536094824570820527164224000505303071962872595619159691416247971024761571538057932032549611221598273371855762399417419551483</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>先根据题目进行一下公式推导，已知：</p>加密： <span class="math display">\[h=f^{-1}*g\textbf{ }mod \textbf{ }p\Rightarrowg=k*p+h*f\\c=(rh+m)\textbf{ }mod\textbf{ }p\Rightarrow(r*f^{-1}*g+m)\textbf{ }mod\textbf{ }p\]</span> 解密： <span class="math display">\[f*c=(r*g+m*f)\textbf{ }mod\textbf{ }p\\\Rightarrow m*f=(f*c-r*g)\textbf{}mod \textbf{ }p\\\Rightarrow m*f=((f*c)\textbf{ }mod\textbf{}p)mod\textbf{ }g\\\Rightarrow m=((f*c\textbf{ }mod\textbf{}p)*f^{-1})mod\textbf{ }g\]</span> 所以要求 <span class="math inline">\(m\)</span>,我们必须得先求出 <span class="math inline">\(f\)</span>。<span class="math inline">\(p,h,c\)</span>是已知的，我们根据$g=k<em>p+h</em>f$构造出格： $$<span class="math display">\[\begin{bmatrix}k,f\end{bmatrix}\begin{bmatrix}p,0\\h,1\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}g,f\end{bmatrix}\]</span><p>$$ 在这里，我们相当于用<span class="math inline">\(LLL\)</span>算法对<span class="math inline">\((p,0),(h,1)\)</span>这一组基进行格基约化，使这组基变成施密特正交化程度最大的一组基，这样我们就可以求解<span class="math inline">\(SVP\)</span>问题了。也就是说，向量<span class="math inline">\((g,f)\)</span>是最短向量。我们来证明一下：</p><p>我们知道最短向量的上限与格的维度和行列式有关： <span class="math display">\[\lambda (\Lambda )\leqslant \sqrt{n}*\sqrt[n]{det(\Lambda )}\]</span> 所以，对于格<span class="math inline">\(L\)</span><span class="math inline">\(\bigl(\begin{smallmatrix} p,0 \\ h,1\end{smallmatrix}\bigr)\)</span>,<span class="math inline">\(\lambda(L)\leqslant\sqrt{2p}\)</span></p><p>我们来计算一下，<span class="math inline">\(p\)</span> 是 <span class="math inline">\(1024 bit\)</span>,<span class="math inline">\(g\)</span>是 <span class="math inline">\(512bit\)</span>,<span class="math inline">\(f\)</span>是 <span class="math inline">\(400bit\)</span>, <span class="math display">\[||(g,f)||=\sqrt{1024+800}=\sqrt{1824})\leqslant\sqrt{2048}\]</span> 是满足的，所以说<span class="math inline">\((g,f)\)</span>是最短向量是正确的。</p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p = 170990541130074930801165526479429022133700799973347532191727614846803741888876816210632483231997413973919037199883422312436314365293577997262903161076615619596783971730864586404602951191341733308807254112018161897113881363794353050758324742415299277578203838160939521046655099610387485947145087271531951477031</span><br><span class="line">h = 19027613518333504891337723135627869008620752060390603647368919831595397216728378486716291001290575802095059192000315493444659485043387076261350378464749849058547797538347059869865169867814094180939070464336693973680444770599657132264558273692580535803622882040948521678860110391309880528478220088107038861065</span><br><span class="line">c = 75639016590286995205676932417759002029770539425113355588948888258962338419567264292295302442895077764630601149285564849867773180066274580635377957966186472159256462169691456995594496690536094824570820527164224000505303071962872595619159691416247971024761571538057932032549611221598273371855762399417419551483</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mat = [[h,1],[p,0]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">g,f = M.LLL()[0]</span><br><span class="line"></span><br><span class="line">m = (f * c %p* invert(f,g)) %g</span><br><span class="line">flag = long_to_bytes(int(m))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>最后附上参考文章：</p><p><a href="https://www.ruanx.net/lattice-2/">格密码笔记（二）(ruanx.net)</a></p><p><a href="https://www.zimablue.life/2022/05/04/Lattice-Lesson0/">Lattice-Lesson0| ZimaBlue's Blog</a></p><p><a href="%5B初识格%20%7C%20DexterJie&#39;Blog%5D(https://dexterjie.github.io/2023/07/28/初识格/#LLL算法)">初识格-LLL算法(DexterJie'Blog)</a></p><p><a href="https://blog.csdn.net/forest_LL/article/details/123733641">格密码LLL算法：如何解决最短向量SVP问题（1）</a></p><p><a href="https://blog.csdn.net/ccnt_2012/article/details/124866094">如何通俗地理解施密特正交化</a></p>]]></content>
      
      
      <categories>
          
          <category> 格密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔一</title>
      <link href="/2023/08/13/%E9%9A%8F%E7%AC%94%E4%B8%80/"/>
      <url>/2023/08/13/%E9%9A%8F%E7%AC%94%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一同余式求模数">一、同余式求模数</h2><p>已知 a % flag = (a%p)，且 a 、(a%p)以及 flag 的格式已知，a是一个素数，求 flag.</p><p>令 t = (a%p),有 <span class="math display">\[a \equiv t \textbf{ }mod\textbf{ }flag\Rightarrow a= k*flag+t\]</span></p><p><span class="math display">\[\Rightarrow k*flag=a-t\]</span> 所以 k*flag 我们是知道的，问题是我们如何才能求出 flag 呢？</p><p>这里我们可以将 k*flag 分解成多个素因子的乘积，而flag必定是其中几个素因子的乘积。可以将分解出来的各个素因子进行排列组合，求出每一种可能的乘积，找出符合flag 格式的那一种可能就行。</p><h2 id="二rsa中已知-kphi">二、RSA中已知 k*phi</h2><p>已知 <span class="math display">\[n = p*q*r,hint = p*s*q - p*s -q*s+s,且r也已知\]</span></p><p>可以得到， <span class="math display">\[n_{1}=n/(p*q),hint=s*(p*q-p-q+1)=s*phi\]</span> 这个 phi 是 n1 的欧拉函数，就可以用 s*phi 代替 phi进行求解。</p><p>推导一下， <span class="math display">\[m\equiv c^{d}\textbf{ }mod \textbf{ }n\Rightarrow m\equiv(m^{e})^{d}\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[\because e*d\equiv 1\textbf{ }mod\textbf{ }k*phi\Rightarrowe*d=k_{1}*k*phi+1\]</span></p><p><span class="math display">\[\therefore m\equiv m^{k_{1}*k*phi+1}\textbf{ }mod\textbf{ }n\Rightarrowm\equiv m^{k_{1}*k*phi}*m\textbf{ }mod\textbf{ }n\]</span></p><p>又由费马小定理可知， <span class="math display">\[m^{\varphi (n)}\equiv 1\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[\therefore m\equiv 1*m\textbf{ }mod\textbf{ }n\]</span></p><p>综上，用 k*phi 代替 phi 进行求解是可行的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCG入门</title>
      <link href="/2023/08/10/LCG%E5%85%A5%E9%97%A8/"/>
      <url>/2023/08/10/LCG%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="lcg线性同余生成器">LCG(线性同余生成器)</h2><p>LCG属于PRNG(伪随机数生成器)和streamcipher(流密码)的一种，是一种产生伪随机数的方法。 <span class="math display">\[X_{n+1}=(a*X_{n}+b)\textbf{ }mod\textbf{ }m\]</span>其中，Xn代表第n个生成的随机数，X0被称为种子值。这里还定义了三个整数：a乘数、b增量、m模数，是产生器设定的常数。</p><h2 id="参数选择">参数选择</h2><p>LCG的性质与参数的选择密切相关，不同的参数可能导致不同的随机序列。一般按照如下要求选择参数：</p><p>1、m是随机序列的模数，必须一个大于0的正整数。一般是一个比较大的素数或者是2的幂，以便提供较长的周期长度。</p><p>2、a是乘数，必须是一个与m互素的正整数。</p><p>3、b是增量，也必须是一个与m互素的正整数。</p><h2 id="常用公式">常用公式</h2><h3 id="公式一由xn1反推xn">公式一：由Xn+1反推Xn</h3><p><span class="math display">\[X_{n}=((X_{n+1}-b)*a^{-1})\textbf{ }mod\textbf{ }m，这里a^{-1}是模逆元\]</span></p><h3 id="公式二求a">公式二：求a</h3><p><span class="math display">\[\left\{\begin{matrix}X_{n+1} &amp; = &amp;(a*X_{n}+b)  &amp;mod  &amp;m \\X_{n} &amp; = &amp;(a*X_{n-1})  &amp; mod &amp;m\end{matrix}\right.\Rightarrowa=((X_{n+1}-X_{n})*(X_{n}-X_{n-1})^{-1}\textup{ })mod\textbf{ }m\]</span></p><h3 id="公式三求b">公式三：求b</h3><p><span class="math display">\[b=(X_{n+1}-a*X_{n})\textbf{ }mod\textbf{ }m\]</span></p><h3 id="公式四求m">公式四：求m</h3><p><span class="math display">\[t_{n}=X_{n+1}-X_{n},t_{n}=(a*X_{n}+b)-(a*X_{n-1}+b)=a(X_{n}-X_{n-1})=a*t_{n-1}\textbf{} mod\textbf{ }m.\]</span></p><p><span class="math display">\[\thereforet_{n+1}t_{n-1}-t_{n}t_{n}=a*a*t_{n-1}*t_{n-1}-a*t_{n-1}*a*t_{n-1}=0\textup{}mod\textup{ }m\]</span></p><p><span class="math display">\[即T_{n}=t_{n+1}t_{n-1}-t_{n}t_{n}是m的倍数，故T_{n}和T_{n-1}的最大公因数即为m\]</span></p><h2 id="常见六种题型">常见六种题型</h2><p><strong><em>LCG_1:a、b、m都知道，此类题相当于由Xn+1反推Xn.</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;lcg.a&#125;&#x27;)</span><br><span class="line">print(f&#x27;b = &#123;lcg.b&#125;&#x27;)</span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 113439939100914101419354202285461590291215238896870692949311811932229780896397</span><br><span class="line">b = 72690056717043801599061138120661051737492950240498432137862769084012701248181</span><br><span class="line">m = 72097313349570386649549374079845053721904511050364850556329251464748004927777</span><br><span class="line">9772191239287471628073298955242262680551177666345371468122081567252276480156</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>有一个问题就是，我们需要反推多少项呢？我们并不知道，因为迭代的次数(getPrime(16))是一个随机数。但是这并不妨碍我们求解flag。因为flag的格式(b'NSSFCT{')我们已经知道，只需要不断反推，直至找到符合格式的flag为止。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">a = 113439939100914101419354202285461590291215238896870692949311811932229780896397</span><br><span class="line">b = 72690056717043801599061138120661051737492950240498432137862769084012701248181</span><br><span class="line">m = 72097313349570386649549374079845053721904511050364850556329251464748004927777</span><br><span class="line">c=9772191239287471628073298955242262680551177666345371468122081567252276480156</span><br><span class="line"></span><br><span class="line"># c=(a*c0+b)%m</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c - b) * a_1 % m</span><br><span class="line">    #print(c)</span><br><span class="line">    flag=libnum.n2s(int(c))</span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_2:不知道b,要先求出b,之后操作就和LCG_1没什么区别了</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;lcg.a&#125;&#x27;)</span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 83968440254358975953360088805517488739689448515913931281582194839594954862517</span><br><span class="line">m = 77161425490597512806099499399561161959645895427463118872087051902811605680317</span><br><span class="line">43959768681328408257423567932475057408934775157371406900460140947365416240650</span><br><span class="line">8052043336238864355872102889254781281466728072798160448260752595038552944808</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">from Crypto.Util.number import isPrime</span><br><span class="line"></span><br><span class="line">a = 83968440254358975953360088805517488739689448515913931281582194839594954862517</span><br><span class="line">m = 77161425490597512806099499399561161959645895427463118872087051902811605680317</span><br><span class="line">c1=43959768681328408257423567932475057408934775157371406900460140947365416240650</span><br><span class="line">c2=8052043336238864355872102889254781281466728072798160448260752595038552944808</span><br><span class="line"></span><br><span class="line">b=(c2-a*c1) % m</span><br><span class="line">#print(b)</span><br><span class="line">#print(gmpy2.gcd(b,m))</span><br><span class="line">a_1 = gmpy2.invert(a,m)</span><br><span class="line">c = c1</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c-b) * a_1 % m</span><br><span class="line">    flag = libnum.n2s(int(c))</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_3:a、b都不知道，先求出a,之后操作同LCG_2</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">m = 96343920769213509183566159649645883498232615147408833719260458991750774595569</span><br><span class="line">10252710164251491500439276567353270040858009893278574805365710282130751735178</span><br><span class="line">45921408119394697679791444870712342819994277665465694974769614615154688489325</span><br><span class="line">27580830484789044454303424960338587428190874764114011948712258959481449527087</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">m = 96343920769213509183566159649645883498232615147408833719260458991750774595569</span><br><span class="line">c1 = 10252710164251491500439276567353270040858009893278574805365710282130751735178</span><br><span class="line">c2 = 45921408119394697679791444870712342819994277665465694974769614615154688489325</span><br><span class="line">c3 = 27580830484789044454303424960338587428190874764114011948712258959481449527087</span><br><span class="line"></span><br><span class="line">a = (c3-c2) * gmpy2.invert(c2-c1,m) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line">a_1 = gmpy2.invert(a,m)</span><br><span class="line">b = (c2-a*c1) % m</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">c = c1</span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c-b) * a_1 % m</span><br><span class="line">    flag = libnum.n2s(int(c))</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_4：a、b、m都不知道，给出多组输出，让我们恢复初始种子。</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">47513456973995038401745402734715062697203139056061145149400619356555247755807</span><br><span class="line">57250853157569177664354712595458385047274531304709190064872568447414717938749</span><br><span class="line">30083421760501477670128918578491346192479634327952674530130693136467154794135</span><br><span class="line">38739029019071698539301566649413274114468266283936163804522278316663267625091</span><br><span class="line">42506270962409723585330663340839465445484970240895653869393419413017237427900</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>首先，我们要先求出m，才能LCG_3的操作。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c=[47513456973995038401745402734715062697203139056061145149400619356555247755807,</span><br><span class="line">   57250853157569177664354712595458385047274531304709190064872568447414717938749,</span><br><span class="line">   30083421760501477670128918578491346192479634327952674530130693136467154794135,</span><br><span class="line">   38739029019071698539301566649413274114468266283936163804522278316663267625091,</span><br><span class="line">   42506270962409723585330663340839465445484970240895653869393419413017237427900]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line"># print(isPrime(m))       False</span><br><span class="line"></span><br><span class="line">m//=2</span><br><span class="line"># print(isPrime(m))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>这里需要解释一下代码中为什么要进行 m//=2这样的操作？</em></strong></p><p><strong><em>我们虽然得到了m的倍数，通过求解 GCD 也确实能得到m。但是在数据不够多的情况下，我们可能得到的是 k</em>m(不信的话，你可以输出一下 isPrime(m) 发现 m 确实不是素数),这时就需要我们遍历一些小数，手动去除 k 。</strong>*</p><p><strong><em>LCG_5:本题给出信息和LCG_4一样需要我们恢复参数。</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = self.a * (self.seed - self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">57648351648792284446777383544515312078150027665462203747924668509833442797796</span><br><span class="line">90378879763416486117626477831653213918315023665514305359005153448529276829825</span><br><span class="line">21826576702665114807208181233864324586557058567478767825970403161758214940301</span><br><span class="line">47594460970742467761038407996122637655856234121180714918606854365482948918701</span><br><span class="line">11871076497267630136796123094001159466754095580273018347962555675375123133730</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>需要注意的是，这里所给的LCG递归式是</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.seed = self.a * (self.seed - self.b) % self.m</span><br></pre></td></tr></table></figure><p><strong><em>我们只需要把 -ab 看成一个整体，这样我们就可以转化为标准式ax+b 的形式。因为这里我们只需要恢复初始种子m，所以代码和LCG_4没什么区别。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c=[57648351648792284446777383544515312078150027665462203747924668509833442797796,</span><br><span class="line">   90378879763416486117626477831653213918315023665514305359005153448529276829825,</span><br><span class="line">   21826576702665114807208181233864324586557058567478767825970403161758214940301,</span><br><span class="line">   47594460970742467761038407996122637655856234121180714918606854365482948918701,</span><br><span class="line">   11871076497267630136796123094001159466754095580273018347962555675375123133730]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line">print(isPrime(m))   # False m的倍数</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">for i in range(1,100):</span><br><span class="line">    if isPrime(m//i):</span><br><span class="line">        print(i)   # i是4</span><br><span class="line">        m//=i</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_6:同样需要恢复参数</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(255), getPrime(255), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br></pre></td></tr></table></figure><p><strong><em>这里进行了两次加密，我们得到的并不是连续的输出，而是隔位输出，比如是X2,X4,X6,X8,X10</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">self.seed = (self.a * self.seed + self.b) % self.m</span><br></pre></td></tr></table></figure><p>首先要恢复模数 m， <span class="math display">\[\left\{\begin{matrix}X_{2} &amp;=  &amp;(a*X_{1}+b) &amp;mod  &amp;m \\X_{4}&amp; = &amp; (aX_{3}+b) &amp;mod  &amp;m\end{matrix}\right.\Rightarrow (X_{4}-X_{2})=a(X_{3}-X_{1})\textbf{}mod\textbf{ }m\]</span> 依然可以构造消去增量 b构造等比数列，所以我们依然可以用之前的方法求 m 。</p><p>接下来就是求 a， <span class="math display">\[(X_{4}-X_{2})=a(X_{3}-X_{1})\textbf{ }mod\textbf{}m=a((aX_{2}+b)-(aX_{0}+b))\textbf{ }mod\textbf{}m=a^{2}(X_{2}-X_{0})\textbf{ }mod\textbf{ }m\]</span> 那么，这个平方我们该如何处理呢？我们看Xenny师傅 怎么解决。</p><figure><img src="/2023/08/10/LCG%E5%85%A5%E9%97%A8/P6.png" alt="P6"><figcaption aria-hidden="true">P6</figcaption></figure><p>这个方法我也还是一知半解(AMM算法也不是很明白)。这里，讲一下我的做法。前面已经说过，本题进行了两轮加密，所给输出是间隔的。<span class="math display">\[X_{n+1}=(aX_{n}+b)\textbf{ }mod\textbf{ }m=(a(aX_{n-1}+b)+b)\textbf{}mod\textbf{ }m\]</span> 可以把 a**2 看作 a,把 (a+1)b 看成b，这样就相当于重新构造了一个LCG。</p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c = [25445927935559969212648839062255651208014967526951331344342413906051118248013,</span><br><span class="line">81572970970116732975667604095930675262596098540738447440566868976253289440293,</span><br><span class="line">6956793925625110803779114150160476498676179542815207353218944386232051429289,</span><br><span class="line">88042506866508011592456777776490262927213783361334741921985316105965255450508,</span><br><span class="line">5652832125321707726481846809536180176877263519327268361130605456255558285092]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line"># print(isPrime(m))   # true</span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m             # 把(a+1)*b当成b就可以了</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>最后附上我参考的文章：</p><p><a href="https://blog.csdn.net/superprintf/article/details/108964563">ctf之lcg算法</a></p><p><a href="https://blog.csdn.net/weixin_45883223/article/details/115299389">LCG(线性同余生成器)</a></p>]]></content>
      
      
      <categories>
          
          <category> 流密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023DASCTF七月挑战赛复现</title>
      <link href="/2023/08/03/2023DASCTF%E4%B8%83%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/08/03/2023DASCTF%E4%B8%83%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="ezdhke">EzDHKE</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from hashlib import sha256</span><br><span class="line">from random import randbytes, getrandbits</span><br><span class="line">from flag import flag</span><br><span class="line">def diffie_hellman(g, p, flag):</span><br><span class="line">    alice = getrandbits(1024)</span><br><span class="line">    bob = getrandbits(1024)</span><br><span class="line">    alice_c = pow(g, alice, p)</span><br><span class="line">    bob_c = pow(g, bob, p)</span><br><span class="line">    print(alice_c , bob_c)</span><br><span class="line">    key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br><span class="line"></span><br><span class="line">    iv = b&quot;dasctfdasctfdasc&quot;</span><br><span class="line"></span><br><span class="line">    aes = AES.new(key, AES.MODE_CBC, iv)  </span><br><span class="line">    </span><br><span class="line">    enc = aes.encrypt(flag)</span><br><span class="line">    print(enc)</span><br><span class="line"></span><br><span class="line">def getp():</span><br><span class="line">    p = int(input(&quot;P = &quot;))</span><br><span class="line">    assert isPrime(p)</span><br><span class="line">    assert p.bit_length() &gt;= 1024 and p.bit_length() &lt;= 2048</span><br><span class="line">    g = 2</span><br><span class="line">    diffie_hellman(g, p, flag)</span><br><span class="line"></span><br><span class="line">getp()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br></pre></td></tr></table></figure><p>获取 Bob 发送的值( bob_c)，将其提高到 Alice 私钥的幂，然后取模p。</p><p>然后将生成的长整数转换为字节并使用 SHA-256进行哈希处理，哈希运算的结果作为字节字符串返回。</p><p>最终结果作为 Alice 和 Bob 的共享密钥。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iv = b&quot;dasctfdasctfdasc&quot;</span><br></pre></td></tr></table></figure><p>AES的CBC模式（分组密码链接模式）设置初始化向量(IV)。</p><p>IV 是一个随机数，用作密文的第一个块。这是必要的，因为 AES是分组密码，而分组密码需要初始化向量来启动加密过程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)  #创建一个新的 AES 对象</span><br></pre></td></tr></table></figure><p>密钥、IV 和明文必须都是类似字节的对象。密钥的长度必须为 16、24 或 32字节(128bit,192bit,256bit)， IV 的长度必须为 16 字节（因为 AES 在 16字节的块上运行），明文的长度必须是 16 字节的倍数。 如果明文不是 16字节的倍数，则必须对其进行填充以达到 16 的倍数的大小。</p><p><strong><em>flag被CBC(分组密码链接模式)进行加密，我们已知初始化向量(IV),目的是求key。</em></strong></p><p><strong><em>而key是被DH加密了的，要求key,还需求出alice。</em></strong></p><p><strong><em>get()函数要求我们传入一个1024bit-2048bit的素数p,我们不防传入一个光滑素数，能很快求解</em></strong> <span class="math display">\[Alice_c\equiv g^{alice}\textbf{ }mod\textbf{ }p\]</span> wp:</p><p>生成光滑素数p</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from random import choice</span><br><span class="line">from Crypto.Util.number import isPrime</span><br><span class="line">def myPrime(bits):</span><br><span class="line">    while True:</span><br><span class="line">        n = 2</span><br><span class="line">        while n.bit_length() &lt; bits:</span><br><span class="line">            n *= choice(primes)</span><br><span class="line">        if isPrime(n + 1):</span><br><span class="line">            return n + 1</span><br><span class="line">p = myPrime(1024)</span><br><span class="line">print(p)</span><br><span class="line">#189748605665158082111275872557704333522039726199999895031706315085902660337411854647983122666062556936534670800160523701824801162274106958140146326402455411620555437280926462736018015567166363230091558715628717720419196163767507352475201252315824517036725244214039625995753473481520129898146252693266565762094927</span><br></pre></td></tr></table></figure><p>求解alice</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 环境：sage</span><br><span class="line"># Baby-step Giant-step法</span><br><span class="line">def babystep_giantstep(g, y, p, q=None):</span><br><span class="line">    if q is None:</span><br><span class="line">        q = p - 1</span><br><span class="line">    m = int(q**0.5 + 0.5)</span><br><span class="line">    # Baby step</span><br><span class="line">    table = &#123;&#125;</span><br><span class="line">    gr = 1  # g^r</span><br><span class="line">    for r in range(m):</span><br><span class="line">        table[gr] = r</span><br><span class="line">        gr = (gr * g) % p</span><br><span class="line">    # Giant step</span><br><span class="line">    try:</span><br><span class="line">        gm = pow(g, -m, p)  # gm = g^&#123;-m&#125;</span><br><span class="line">    except:</span><br><span class="line">        return None</span><br><span class="line">    ygqm = y                # ygqm = y * g^&#123;-qm&#125;</span><br><span class="line">    for q in range(m):</span><br><span class="line">        if ygqm in table:</span><br><span class="line">            return q * m + table[ygqm]</span><br><span class="line">        ygqm = (ygqm * gm) % p</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"># Pohlig–Hellman法</span><br><span class="line">def pohlig_hellman_DLP(g, y, p):</span><br><span class="line">    crt_moduli = []</span><br><span class="line">    crt_remain = []</span><br><span class="line">    for q, _ in factor(p-1):</span><br><span class="line">        x = babystep_giantstep(pow(g,(p-1)//q,p), pow(y,(p-1)//q,p), p, q)</span><br><span class="line">        if (x is None) or (x &lt;= 1):</span><br><span class="line">            continue</span><br><span class="line">        crt_moduli.append(q)</span><br><span class="line">        crt_remain.append(x)</span><br><span class="line">    x = crt(crt_remain, crt_moduli)</span><br><span class="line">    return x</span><br><span class="line">    </span><br><span class="line">p = 189748605665158082111275872557704333522039726199999895031706315085902660337411854647983122666062556936534670800160523701824801162274106958140146326402455411620555437280926462736018015567166363230091558715628717720419196163767507352475201252315824517036725244214039625995753473481520129898146252693266565762094927</span><br><span class="line">g=2</span><br><span class="line">y=126335148728121839165214578712616714896068088431242768032099119311672927960066757778886759581732563397664623281291468786455806669506289945000832687256947547715890013891156717873951970575686566623998313033814629227260784874473674493141956695555624444324423123550043331270766000934442345084521173496612684244521817 </span><br><span class="line"></span><br><span class="line">x = pohlig_hellman_DLP(g, y, p)</span><br><span class="line">print(x)</span><br><span class="line">print(pow(g, x, p) == y)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;19725268140486219931273670184627509421886594371218668473170713602614775174554822553913723749247515418643589204928857895458812995617382397101146613792597234401181086237828962337082170640415285598027205377319087246590523359362089919920879645846905409986181936892939004568920963678760604527317649686645891069878</span><br><span class="line">True&#x27;&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后求key,解flag</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alice=19725268140486219931273670184627509421886594371218668473170713602614775174554822553913723749247515418643589204928857895458812995617382397101146613792597234401181086237828962337082170640415285598027205377319087246590523359362089919920879645846905409986181936892939004568920963678760604527317649686645891069878</span><br><span class="line">bob_c=82024715586746697978530132111368994011716076980502454618150572158919032873444387902613386183552926303651710370065737129756192440674145837908673206529875835887003844314561287987895409315122184287323905278866402929779666428512421254584747210553034542812693842282458559568445136236463734031158504503149333460169444</span><br><span class="line"></span><br><span class="line">enc=b&quot;Ky\x91\xf5\n\xe4\x03&#x27;\xa8\xf2c\xd6\x95m\xa7\x8bj\xfb\x03nU\x0e\x95\xd7(\xb9\xa4\xcf\xcbg\xd6gR\xe1m\xef7Q\x151h\x0c\xc6x\xb1\xfcZ^&quot;</span><br><span class="line"></span><br><span class="line">key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br><span class="line">iv = b&quot;dasctfdasctfdasc&quot;</span><br><span class="line"></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">flag = aes.decrypt(enc)</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line"># b&#x27;DASCTF&#123;1c65a8d9-ca95-4217-a98c-b119c6f313b1&#125;</span><br></pre></td></tr></table></figure><h2 id="ezrsa">ezRSA</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import secret, flag</span><br><span class="line">def encrypt(m):</span><br><span class="line">    return pow(m, e, n)</span><br><span class="line">assert flag == b&quot;dasctf&#123;&quot; + secret + b&quot;&#125;&quot;</span><br><span class="line">e = 11</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p * q</span><br><span class="line">P = getPrime(512)</span><br><span class="line">Q = getPrime(512)</span><br><span class="line">N = P * Q</span><br><span class="line">gift = P ^ (Q &gt;&gt; 16)</span><br><span class="line">print(N, gift, pow(n, e, N))</span><br><span class="line">print(encrypt(bytes_to_long(secret)),</span><br><span class="line">    encrypt(bytes_to_long(flag)))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line">a=1418376318449536765352288414795105463017701595274559335835409895217396556048810421351756309867602851654191c1=5855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009 </span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>已知P高16位，可以根据P=gift^Q恢复P,所以要先根据Q=N//P恢复Q。</p><p>wp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line"></span><br><span class="line">pp=bin(gift)[2:18]  # 截取p的高16位</span><br><span class="line">#print(pp)</span><br><span class="line"></span><br><span class="line">gift=bin(gift)[2:][16:]  # 截取gift的剩余位</span><br><span class="line">#print(gift)</span><br><span class="line">k = 512-16</span><br><span class="line"></span><br><span class="line"># 恢复p</span><br><span class="line">x=4</span><br><span class="line">for i in range(k//x):</span><br><span class="line">    PP = int(pp + &#x27;0&#x27;*k,2)  # 已知高位</span><br><span class="line">    #print(PP)</span><br><span class="line">    QQ=bin(N//PP)[2:][i*x:(i+1)*x] # 计算Q高位</span><br><span class="line">    #print(QQ)</span><br><span class="line">    gg = gift[i*x:(i+1)*x]</span><br><span class="line">    #print(gg)</span><br><span class="line">    pb = bin(int(QQ, 2) ^ int(gg, 2))[2:].zfill(x)</span><br><span class="line">    #print(pb)</span><br><span class="line">    pp+=pb</span><br><span class="line">    k-=x</span><br><span class="line">px=int(pp,2)</span><br><span class="line">if N//px:</span><br><span class="line">    p=N//px</span><br><span class="line">    print(p)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line"></span><br><span class="line">#pp=bin(gift)[2:][:16]  # 截取gift的前16位</span><br><span class="line">pp=bin(gift)[2:18]</span><br><span class="line"># print(bin(gift))</span><br><span class="line"># print(pp)</span><br><span class="line">b=512-16</span><br><span class="line"></span><br><span class="line">gift=bin(gift)[2:][16:] # 截取gift剩余的位数</span><br><span class="line">#print(gift)</span><br><span class="line"></span><br><span class="line">x=5</span><br><span class="line">for i in range((512-16)//x):</span><br><span class="line">    PP=int(pp+&#x27;0&#x27;*b,2)  #已知高位</span><br><span class="line">    #print(PP)</span><br><span class="line">    Qb=bin(N//PP)[2:][i*x:x*i+x]  #算出Q的高位,取5</span><br><span class="line">    #print(Qb)</span><br><span class="line">    gb=gift[i*x:i*x+x]</span><br><span class="line">    #print(gb)</span><br><span class="line">    pb=bin(int(gb,2)^int(Qb,2))[2:].zfill(x)</span><br><span class="line">    #print(pb)</span><br><span class="line">    pp+=pb</span><br><span class="line">    #print(pp)</span><br><span class="line">    b-=x</span><br><span class="line">for i in range(3): #还差1位</span><br><span class="line">    px = int(pp+bin(i)[2:],2)</span><br><span class="line">    if N//px:</span><br><span class="line">        p=N//px</span><br><span class="line">        print(p)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>这里解释一下，为什么一小段一小段的恢复。</em></strong></p><p><strong><em>因为我们是知道P的一部分高位，Q=N//P也只能求出Q的一部分高位。为了精准，我们可以把间隔选短一点儿。</em></strong></p><p><strong><em>上面脚本中我所选的间隔分别是4和5</em></strong></p><p>求解n</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">p = 9366986529377069783394625848920106951220134111548343265311677163992169555436421569730703291128771472885865288798344038000984911921843088200997725324682297</span><br><span class="line">q=N//p</span><br><span class="line"></span><br><span class="line">e=11</span><br><span class="line">phi=(p-1)*(q-1)</span><br><span class="line">d=invert(e,phi)</span><br><span class="line">c1=14183763184495367653522884147951054630177015952745593358354098952173965560488104213517563098676028516541915855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span><br><span class="line"></span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line"></span><br><span class="line">n=pow(c1,d,N)  # n可能比N大</span><br><span class="line"># print(n.bit_length()) 1020bit</span><br><span class="line">n = n + N</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><p><strong><em>因为n=pow(c1,d,N)求出来的n只有1020bit,而理论上n应该有1024bit,所以手动加上N.</em></strong></p><p>求解secret</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c2 = x ^ 11 </span><br><span class="line">c3 = (bytes_to_long(b&#x27;dasctf&#123;&#x27; + b&#x27;\00&#x27; * i + b&#x27;&#125;&#x27; ) * 256 ** (i + 1) + 256 * x) ^ 11</span><br><span class="line">(其中x = secret , i = len(secret))</span><br></pre></td></tr></table></figure><p><strong><em>典型的相关信息攻击</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 83410392685813224685786027640778560521035854332627839979281105731457044069408118952629284089869335506983096270269822559619624906180108256504440296527471536363057103101146262613593336072556587341466840510200003498265457285439149541137127199088938421905041387224795918868443175561632999479925818053898100117419</span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line">def GCD(a,b):      # 求解多项式的最大公因子</span><br><span class="line">    if b == 0:</span><br><span class="line">        return a.monic()</span><br><span class="line">    else:</span><br><span class="line">        return GCD(b,a % b)</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">for i in range(50):</span><br><span class="line">    f1 = x ^ 11 - c2</span><br><span class="line">    f2 = (bytes_to_long(b&#x27;dasctf&#123;&#x27; + b&#x27;\x00&#x27; * i + b&#x27;&#125;&#x27;) + 256 * x) ^ 11 - c3</span><br><span class="line">    if GCD(f1,f2)[0] != 1:</span><br><span class="line">        print(b&#x27;dasctf&#123;&#x27; + long_to_bytes(int(n - GCD(f1,f2)[0])) + b&#x27;&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># dasctf&#123;C0pper_Sm1th_Mak3s_T1ng5_Bet4er&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def GCD(a,b):      # 求解多项式的最大公因子</span><br><span class="line">    if b == 0:</span><br><span class="line">        return a.monic()</span><br><span class="line">    else:</span><br><span class="line">        return GCD(b,a % b)</span><br></pre></td></tr></table></figure><p><strong><em>使用辗转相除法求多项式的最大公因子</em></strong><strong><em>在代数中，一个多项式的首项系数通常被称为该多项式的引导系数（leadingcoefficient），而将多项式变成首项系数为1的形式被称为将多项式化为首一形式（monicform）</em></strong><strong><em>调用函数g1.monic()将g1转换为首一多项式（monicpolynomial），并返回该多项式。</em></strong><strong><em>使用g.monic()[0]，则会返回g(x)除以引导系数后得到的多项式的常数项</em></strong><strong><em>比如：g.monic() = x + 32412345</em></strong><strong><em>那么：g.monic()[0] = 32412345</em></strong></p><h2 id="ezalgebra">ezAlgebra</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import getPrime, bytes_to_long</span><br><span class="line"></span><br><span class="line">def YiJiuJiuQiNian(Wo, Xue, Hui, Le, Kai):</span><br><span class="line">    Qi = 1997</span><br><span class="line">    Che = Wo+Hui if Le==1 else Wo*Hui</span><br><span class="line">    while(Xue):</span><br><span class="line">        Qi += (pow(Che, Xue, Kai)) % Kai</span><br><span class="line">        Xue -= 1</span><br><span class="line">    return Qi</span><br><span class="line">l = 512</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(l)</span><br><span class="line">q = getPrime(l//2)</span><br><span class="line">r = getPrime(l//2)</span><br><span class="line">n = p * q * r</span><br><span class="line">t = getrandbits(32)</span><br><span class="line">c1 = YiJiuJiuQiNian(t, 4, p, 1, n)</span><br><span class="line">c2 = YiJiuJiuQiNian(m, 19, t, 0, q)</span><br><span class="line">c3 = YiJiuJiuQiNian(m, 19, t, 1, q)</span><br><span class="line">print(f&quot;n = &#123;n&#125;&quot;)</span><br><span class="line">print(f&quot;c1 = &#123;c1&#125;&quot;)</span><br><span class="line">print(f&quot;c2 = &#123;c2&#125;&quot;)</span><br><span class="line">print(f&quot;c3 = &#123;c3&#125;&quot;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 119156144845956004769507478085325079414190248780654060840257869477965140304727088685316579445017214576182010373548273474121727778923582544853293534996805340795355149795694121455249972628980952137874014208209750135683003125079012121116063371902985706907482988687895813788980275896804461285403779036508897592103</span><br><span class="line">c1 = 185012145382155564763088060801282407144264652101028110644849089283749320447842262397065972319766119386744305208284231153853897076876529326779092899879401876069911627013491974285327376378421323298147156687497709488102574369005495618201253946225697404932436143348932178069698091761601958275626264379615139864425</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>简单化简一下题目信息： <span class="math display">\[n = p*q*r\]</span></p><p><span class="math display">\[c1 -1997= che^{4}+che^{3}+che^{2}+che\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[c_{2}-1997=(t*m)^{19}+(t*m)^{18}+...+(t*m)^{2}+(t*m)\textbf{}mod\textbf{ }q\]</span></p><p><span class="math display">\[c_{3}-1997=(t+m)^{19}+(t+m)^{18}+...+(t+m)^{2}+(t+m)\textbf{}mod\textbf{ }q\]</span></p><p>根据模腐蚀性质， <span class="math display">\[c1-1997=t^{4}+t^{3}+t^{2}+t\textbf{ }mod\textbf{ }p\Rightarrowk*p=c_{1}-(t^{4}+t^{3}+t^{2}+t+1997)\]</span> 就相当于已知p高位，运用copper求解t</p><p>之后用gcd(k*p,n)求p</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import isPrime, long_to_bytes</span><br><span class="line">n = 119156144845956004769507478085325079414190248780654060840257869477965140304727088685316579445017214576182010373548273474121727778923582544853293534996805340795355149795694121455249972628980952137874014208209750135683003125079012121116063371902985706907482988687895813788980275896804461285403779036508897592103</span><br><span class="line">c1 = 185012145382155564763088060801282407144264652101028110644849089283749320447842262397065972319766119386744305208284231153853897076876529326779092899879401876069911627013491974285327376378421323298147156687497709488102574369005495618201253946225697404932436143348932178069698091761601958275626264379615139864425</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">#xue1=4 ,che1=t+p,kai=n</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x^4+x^3+x^2+x-c1+1997</span><br><span class="line">t = f.small_roots(X=2^32, beta=0.4)[0]</span><br><span class="line"># print(t)</span><br><span class="line"></span><br><span class="line">t=2915836867</span><br><span class="line">kp=t**4+t**3+t**2+t-c1+1997</span><br><span class="line">p = gmpy2.gcd(kp,n)</span><br><span class="line"># print(p)</span><br><span class="line"># print(p.bit_length())</span><br><span class="line">#print(isPrime(p))</span><br><span class="line">N=n//p</span><br></pre></td></tr></table></figure><p>两个模q下的19次同解多项式，利用groebner_basis求出q</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xue2=19 che=m*t kai=q</span><br><span class="line">Qi-1997=che^19+che^18 +....+che</span><br><span class="line"></span><br><span class="line">xue3=19 che=(m+t) kai=q</span><br><span class="line">Qi-1997=che^19+che^18+....+che</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">P.&lt;x,y&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f1=1997-c2</span><br><span class="line">f2=1997-c3</span><br><span class="line">for i in range(1,20):</span><br><span class="line">    f1+=(x*t)^i</span><br><span class="line">    f2+=(x+t)^i</span><br><span class="line">G=[f1,f2]</span><br><span class="line">B=Ideal(G).groebner_basis() #Gröbner 基是多项式环中理想的一种特殊生成集，用于许多运算，例如求解多项式方程组。</span><br><span class="line"># print(B)</span><br><span class="line"></span><br><span class="line">q=87038069032840052005520908272237788908169043580221040711149494083975743478969</span><br><span class="line">r = n//(p*q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q=87038069032840052005520908272237788908169043580221040711149494083975743478969</span><br><span class="line">x=56985796272753226120469211992443340429346162287195965942430959147227534853120</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">for i in range(2**25):</span><br><span class="line">    flag=long_to_bytes(x+i*q)</span><br><span class="line">    if b&#x27;dasctf&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
