<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023羊城杯</title>
      <link href="/2023/09/04/2023%E7%BE%8A%E5%9F%8E%E6%9D%AF/"/>
      <url>/2023/09/04/2023%E7%BE%8A%E5%9F%8E%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="easy_3l">Easy_3L</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_key():</span><br><span class="line">    p = getPrime(1400)</span><br><span class="line">    f = getRandomNBitInteger(1024)</span><br><span class="line">    while True:</span><br><span class="line">        q = getPrime(512)</span><br><span class="line">        if gcd(f, q) != 1:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    h = (invert(f, p) * q) % p</span><br><span class="line">    return p, h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt1(m):</span><br><span class="line">    a = getPrime(250)</span><br><span class="line">    b = getRandomNBitInteger(240)</span><br><span class="line">    n = getPrime(512)</span><br><span class="line">    seed = m</span><br><span class="line">    s = [0] * 6</span><br><span class="line">    s[0] = seed</span><br><span class="line">    for i in range(1, 6):</span><br><span class="line">        s[i] = (s[i - 1] * a + b) % n</span><br><span class="line">    return s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt2(msg, p, h):</span><br><span class="line">    s = getRandomNBitInteger(512)</span><br><span class="line">    c = (s * h + msg) % p</span><br><span class="line">    return c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = encrypt1(m)</span><br><span class="line">print(&quot;S1 =&quot;, s[1])</span><br><span class="line">print(&quot;S2 =&quot;, s[2])</span><br><span class="line">print(&quot;S4 =&quot;, s[4])</span><br><span class="line">print(&quot;S5 =&quot;, s[5])</span><br><span class="line"></span><br><span class="line">p, h = get_key()</span><br><span class="line">c = encrypt2(s[3], p, h)</span><br><span class="line">print(&quot;p =&quot;, p)</span><br><span class="line">print(&quot;h =&quot;, h)</span><br><span class="line">print(&quot;c =&quot;, c)</span><br><span class="line"></span><br><span class="line"># S1 = 28572152986082018877402362001567466234043851789360735202177142484311397443337910028526704343260845684960897697228636991096551426116049875141</span><br><span class="line"># S2 = 1267231041216362976881495706209012999926322160351147349200659893781191687605978675590209327810284956626443266982499935032073788984220619657447889609681888</span><br><span class="line"># S4 = 9739918644806242673966205531575183334306589742344399829232076845951304871478438938119813187502023845332528267974698273405630514228632721928260463654612997</span><br><span class="line"># S5 = 9755668823764800147393276745829186812540710004256163127825800861195296361046987938775181398489372822667854079119037446327498475937494635853074634666112736</span><br><span class="line"># p = 25886434964719448194352673440525701654705794467884891063997131230558866479588298264578120588832128279435501897537203249743883076992668855905005985050222145380285378634993563571078034923112985724204131887907198503097115380966366598622251191576354831935118147880783949022370177789175320661630501595157946150891275992785113199863734714343650596491139321990230671901990010723398037081693145723605154355325074739107535905777351</span><br><span class="line"># h = 2332673914418001018316159191702497430320194762477685969994411366563846498561222483921873160125818295447435796015251682805613716554577537183122368080760105458908517619529332931042168173262127728892648742025494771751133664547888267249802368767396121189473647263861691578834674578112521646941677994097088669110583465311980605508259404858000937372665500663077299603396786862387710064061811000146453852819607311367850587534711</span><br><span class="line"># c = 20329058681057003355767546524327270876901063126285410163862577312957425318547938475645814390088863577141554443432653658287774537679738768993301095388221262144278253212238975358868925761055407920504398004143126310247822585095611305912801250788531962681592054588938446210412897150782558115114462054815460318533279921722893020563472010279486838372516063331845966834180751724227249589463408168677246991839581459878242111459287</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span class="math inline">\(LCG\)</span>中的初始种子就是<span class="math inline">\(m\)</span>,已知<span class="math inline">\(S_{1},S_{2},S_{4},S_{5}\)</span>,要恢复初始种子，我们要先求出<span class="math inline">\(S3\)</span>.</p><p>在函数 encrypt2(msg, p, h) 中，已知<span class="math inline">\(p,h,c\)</span>.</p><p><span class="math inline">\(msg,s\)</span>是未知的，考虑用格，</p><p>构造格<span class="math inline">\(L\)</span>, <span class="math display">\[(k,s,1)\begin{pmatrix}-p ,&amp;0,&amp;0 \\-h,&amp;1,&amp;0 \\c,&amp;0,&amp;2^{512}\end{pmatrix}=(msg,s,2^{512})\]</span> <span class="math inline">\(msg\)</span>就是<span class="math inline">\(S_{3}\)</span>,这样就可以恢复<span class="math inline">\(seed\)</span>了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p = 25886434964719448194352673440525701654705794467884891063997131230558866479588298264578120588832128279435501897537203249743883076992668855905005985050222145380285378634993563571078034923112985724204131887907198503097115380966366598622251191576354831935118147880783949022370177789175320661630501595157946150891275992785113199863734714343650596491139321990230671901990010723398037081693145723605154355325074739107535905777351</span><br><span class="line">h = 2332673914418001018316159191702497430320194762477685969994411366563846498561222483921873160125818295447435796015251682805613716554577537183122368080760105458908517619529332931042168173262127728892648742025494771751133664547888267249802368767396121189473647263861691578834674578112521646941677994097088669110583465311980605508259404858000937372665500663077299603396786862387710064061811000146453852819607311367850587534711</span><br><span class="line">c = 20329058681057003355767546524327270876901063126285410163862577312957425318547938475645814390088863577141554443432653658287774537679738768993301095388221262144278253212238975358868925761055407920504398004143126310247822585095611305912801250788531962681592054588938446210412897150782558115114462054815460318533279921722893020563472010279486838372516063331845966834180751724227249589463408168677246991839581459878242111459287</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mat = [[-p,0,0],[-h,1,0],[c,0,2^512]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">hh = M.LLL()[0]</span><br><span class="line"># print(hh)</span><br><span class="line"></span><br><span class="line">msg = hh[0]</span><br><span class="line">print(f&quot;msg = &#123;msg&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># msg = 10700695166096094995375972320865971168959897437299342068124161538902514000691034236758289037664275323635047529647532200693311709347984126070052011571264606</span><br></pre></td></tr></table></figure><p><span class="math inline">\(LCG\)</span>恢复<span class="math inline">\(seed\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c=[28572152986082018877402362001567466234043851789360735202177142484311397443337910028526704343260845684960897697228636991096551426116049875141,</span><br><span class="line">1267231041216362976881495706209012999926322160351147349200659893781191687605978675590209327810284956626443266982499935032073788984220619657447889609681888,</span><br><span class="line">10700695166096094995375972320865971168959897437299342068124161538902514000691034236758289037664275323635047529647532200693311709347984126070052011571264606,</span><br><span class="line">9739918644806242673966205531575183334306589742344399829232076845951304871478438938119813187502023845332528267974698273405630514228632721928260463654612997,</span><br><span class="line">9755668823764800147393276745829186812540710004256163127825800861195296361046987938775181398489372822667854079119037446327498475937494635853074634666112736</span><br><span class="line">]</span><br><span class="line"># print(c[2].bit_length())</span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0                     # 求n</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line"># print(isPrime(m))   # False m的倍数</span><br><span class="line">print(f&quot;n = &#123;m&#125;&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(1,100):</span><br><span class="line">    if isPrime(m//i):</span><br><span class="line">        print(i)   # i是4</span><br><span class="line">        m//=i</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line">print(f&quot;a = &#123;a&#125;&quot;)</span><br><span class="line">print(f&quot;b = &#123;b&#125;&quot;)</span><br><span class="line">print(f&quot;a_1 = &#123;a_1&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = 12433235385460084327215142269091752668477278692416805859007828624838647815241707248797912107322868748847211061641608674422095027981318008221949510129177787</span><br><span class="line">a = 1017579321905754831612145134014116183026524698685218523407174987842084260441</span><br><span class="line">b = 1244547131344198183940330607549789182491018543684349414313485985685030480</span><br><span class="line">a_1 = 11328311979915953125685402059730442802186525001769955129939835010285255328316264293029576580150862310729537002669636904024186460482729761660664512406166499</span><br><span class="line"></span><br><span class="line">m = (c[0]-b)*a_1 % n</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;DASCTF&#123;NTRU_L0G_a6e_S1mpLe&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="danger_rsa">danger_RSA</h3><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_key(a, nbit):</span><br><span class="line">    assert a &gt;= 2</span><br><span class="line">    while True:</span><br><span class="line">        X = getRandomInteger(nbit // a)</span><br><span class="line">        s = getRandomRange(pow(2, a ** 2 - a + 4), pow(2, a ** 2 - a + 5))</span><br><span class="line">        p = X ** a + s</span><br><span class="line">        if isPrime(p):</span><br><span class="line">            return (p, s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p, s = get_key(a, 1024)</span><br><span class="line">q, t = get_key(a, 1024)</span><br><span class="line"></span><br><span class="line">N = p * q</span><br><span class="line">e = s * t</span><br><span class="line">c = pow(m, e, N)</span><br><span class="line">print(&quot;N =&quot;, N)</span><br><span class="line">print(&quot;e =&quot;, e)</span><br><span class="line">print(&quot;c =&quot;, c)</span><br><span class="line"># N = 20289788565671012003324307131062103060859990244423187333725116068731043744218295859587498278382150779775620675092152011336913225797849717782573829179765649320271927359983554162082141908877255319715400550981462988869084618816967398571437725114356308935833701495015311197958172878812521403732038749414005661189594761246154666465178024563227666440066723650451362032162000998737626370987794816660694178305939474922064726534186386488052827919792122844587807300048430756990391177266977583227470089929347969731703368720788359127837289988944365786283419724178187242169399457608505627145016468888402441344333481249304670223</span><br><span class="line"># e = 11079917583</span><br><span class="line"># c = 13354219204055754230025847310134936965811370208880054443449019813095522768684299807719787421318648141224402269593016895821181312342830493800652737679627324687428327297369122017160142465940412477792023917546122283870042482432790385644640286392037986185997262289003477817675380787176650410819568815448960281666117602590863047680652856789877783422272330706693947399620261349458556870056095723068536573904350085124198592111773470010262148170379730937529246069218004969402885134027857991552224816835834207152308645148250837667184968030600819179396545349582556181916861808402629154688779221034610013350165801919342549766</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目最终还是回到<span class="math inline">\(RSA\)</span>,要求解<span class="math inline">\(p,q\)</span>.这里构造了一种公钥生成方式 <span class="math display">\[p=a^{r}+s\\q=b^{r}+t\]</span> 还知道， <span class="math display">\[e=s*t\]</span> 且<span class="math inline">\(s,t\)</span>是在一定范围里面的，思考是否可以通过分解<span class="math inline">\(e\)</span>,然后排列组合求出<span class="math inline">\(s,t\)</span>的组合。<strong>这里需要注意的是，组合有很多种，正确的组合才能求出整数解，要多尝试。</strong></p><p>根据<span class="math inline">\(e_{bit}\)</span>我们是可以推断出<span class="math inline">\(r\)</span>的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(e.bit_length())#34</span><br><span class="line">for m in range(10):</span><br><span class="line">    print(m,m**2-m+4,m**2-m+5)</span><br><span class="line"># 4,16,17</span><br></pre></td></tr></table></figure><p>得到<span class="math inline">\(r=4\)</span>,<span class="math inline">\(s_{bit}=17,t_{bit}=17\)</span>，<span class="math inline">\(a_{bit}=256,b_{bit}=256\)</span>,所以<span class="math inline">\(s,t\)</span>的值不足以影响<span class="math inline">\(N\)</span>的大小，故有 <span class="math display">\[N=p*q=(a^{r}+s)(b^{r}+t)=(ab)^{r}\Rightarrow a*b=gmpy2.iroot(n,4)\]</span> 这样，就能联立方程，求出<span class="math inline">\(a,b\)</span>了</p><p>验证<span class="math inline">\(s_{bit}=t_{bit}\)</span>是17的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tepm = [3,7,7,19,691,5741]</span><br><span class="line">for e in combinations(tepm, 3):</span><br><span class="line">    sum = 1</span><br><span class="line">    for i in e:</span><br><span class="line">        sum *= i</span><br><span class="line">    if sum in range(2**16, 2**17):</span><br><span class="line">        print(e)</span><br><span class="line">        print(sum)</span><br><span class="line"></span><br><span class="line">s,t = [3*7*5741,7*19*691]</span><br><span class="line"># print(tepm1[0].bit_length()) 17</span><br><span class="line"># print(tepm1[1].bit_length())  17</span><br></pre></td></tr></table></figure><p>然后联立方程解<span class="math inline">\(a,b\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">n = 20289788565671012003324307131062103060859990244423187333725116068731043744218295859587498278382150779775620675092152011336913225797849717782573829179765649320271927359983554162082141908877255319715400550981462988869084618816967398571437725114356308935833701495015311197958172878812521403732038749414005661189594761246154666465178024563227666440066723650451362032162000998737626370987794816660694178305939474922064726534186386488052827919792122844587807300048430756990391177266977583227470089929347969731703368720788359127837289988944365786283419724178187242169399457608505627145016468888402441344333481249304670223</span><br><span class="line">e = 11079917583</span><br><span class="line">c = 13354219204055754230025847310134936965811370208880054443449019813095522768684299807719787421318648141224402269593016895821181312342830493800652737679627324687428327297369122017160142465940412477792023917546122283870042482432790385644640286392037986185997262289003477817675380787176650410819568815448960281666117602590863047680652856789877783422272330706693947399620261349458556870056095723068536573904350085124198592111773470010262148170379730937529246069218004969402885134027857991552224816835834207152308645148250837667184968030600819179396545349582556181916861808402629154688779221034610013350165801919342549766</span><br><span class="line"></span><br><span class="line">r,s=[3*7*5741,7*19*691]</span><br><span class="line">ab=int(gmpy2.iroot(n,4)[0])</span><br><span class="line">var(&#x27;a b&#x27;)</span><br><span class="line">f1=a*b==ab</span><br><span class="line">f2=n==(ab**4)+a**4*s+b**4*r+r*s</span><br><span class="line">print(solve([f1,f2],[a,b]))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;a = 47783641287938625512681830427927501009821495321018170621907812035456872958654</span><br><span class="line">b = 44416071018427916652440592614276227563515579156219730344722242565477265479486&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>在求解私钥<span class="math inline">\(d\)</span>的时候发现<span class="math inline">\(e和phi\)</span>不互素。<strong>一般<span class="math inline">\(p和q\)</span>很大，在<span class="math inline">\(flag\)</span>没有填充的情况下，会小于<span class="math inline">\(p和q\)</span>,可以将<span class="math inline">\(p,q\)</span>单独作为公钥求解。</strong></p><p><strong>先把不互素的部分去除，然后剩下的利用<span class="math inline">\(p或者q\)</span>构建多项式环求根。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 47783641287938625512681830427927501009821495321018170621907812035456872958654</span><br><span class="line">b = 44416071018427916652440592614276227563515579156219730344722242565477265479486</span><br><span class="line">p=a**4+r</span><br><span class="line">q=b**4+s</span><br><span class="line"># print(gcd(e,p-1) #3</span><br><span class="line">d=inverse(e//3,p-1)</span><br><span class="line">m_3=pow(c,d,n)</span><br><span class="line">e=3</span><br><span class="line">P.&lt;a&gt;=PolynomialRing(Zmod(p),implementation=&#x27;NTL&#x27;)</span><br><span class="line">f=a^e-m_3</span><br><span class="line">mps=f.monic().roots()</span><br><span class="line">for i in mps:</span><br><span class="line">    flag=long_to_bytes(int(i[0]))</span><br><span class="line">    if b&#x27;DASCTF&#x27; in flag or b&#x27;dasctf&#x27; in flag:</span><br><span class="line">        print(flag)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;DASCTF&#123;C0nsTruct!n9_Techn1qUe2_f0r_RSA_Pr1me_EnC2ypt10N&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="xor贯穿始终">XOR贯穿始终</h3><p>第一次做这样的题，卡了很久很久。。</p><p>题目附件是加密的，要想办法拿到密码。注意到题目给了一个<span class="math inline">\(massege.txt\)</span>，打开一看，是社会主义核心价值观编码，在线网站解密就行。</p><p><span class="math inline">\(massege.txt\)</span>的内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自由和谐和谐富强公正友善爱国公正法治法治文明和谐自由法治自由法治平等公正友善公正公正民主法治自由公正敬业和谐富强公正友善爱国和谐平等平等友善敬业法治敬业和谐富强法治平等平等友善敬业公正公正公正友善敬业法治平等平等诚信自由公正自由平等友善敬业公正友善法治和谐和谐</span><br></pre></td></tr></table></figure><p>解码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C0ngr4tulati0n5_y0u_fou^d_m3</span><br></pre></td></tr></table></figure><p>现在就能打开附件了，看到题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import gcd</span><br><span class="line">from Crypto.Util.number import getPrime</span><br><span class="line">from secret import enflag</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = q * p</span><br><span class="line">phi = (p - 1) * (q - 1)</span><br><span class="line">e = getPrime(17)</span><br><span class="line">assert gcd(e, phi) == 1</span><br><span class="line"># 以上信息生成了私钥文件,但文件被损坏了你能提取有用信息吗</span><br><span class="line"></span><br><span class="line">c = pow(enflag, e, n)</span><br><span class="line">print(&#x27;c = &#x27; + str(c))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">c = 91817924748361493215143897386603397612753451291462468066632608541316135642691873237492166541761504834463859351830616117238028454453831120079998631107520871612398404926417683282285787231775479511469825932022611941912754602165499500350038397852503264709127650106856760043956604644700201911063515109074933378818</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>私钥丢失了，但是给了一个<span class="math inline">\(pem\)</span>证书，要我们从中提取私钥。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALmtMy+2uH1ZtbIL</span><br><span class="line">SuiAukFthyQRH5mp7UmLyzZQkdg9zEP9/5tgffikQ7ytx5kHySHnazgAO1sOzmYE</span><br><span class="line">N4Axlev6uafiP8B1Eij97v5VkYJ1I9e3mtBNheTbXKoT8op+ASQ1fQaF4A8UzLuW</span><br><span class="line">eZeZI8JTH/SH+bolAK3kiZXDFdkTAgMBAAECgYEAl067LaC7Cvs2A5cMPhfYsESv</span><br><span class="line">IgcKN1CwW4Sd3u8dSphhgu7TgyzIuvwxbuo2g1BC6WwKhaI6vGN+csfw6nh98GEn</span><br><span class="line">/p3D0huNroAYvf/DRRB9UnHdttX7wB+Mv3P0RBDWHgBiCDVvHFuFUV78cIs0tnbn</span><br><span class="line">jxjU07aPV2XRC3AfA2ECQQDqWUNPVg3i6vTyHCL7EGkbeUheYpAAfcKCQrxjc5+5</span><br><span class="line">X6A+XtgHAA1JHwykPlCpHUOmlA85DJF1ejuoImzlgRLJAkEAytTCnQF+MN2r1gaA</span><br><span class="line">UETZyj5qMYT7Th8zKEVVVJjDawLnuX4usJ2FyRnjCkk86U75QSJhw5mMc0QnG25u</span><br><span class="line">Gz3++w==</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p>先了解一下<span class="math inline">\(pem\)</span>证书吧</p><p><a href="https://blog.csdn.net/good123day/article/details/25496507">RSA公私钥结构</a></p><p><a href="https://zhuanlan.zhihu.com/p/461349946">(PKCS1) RSA 公私钥pem 文件解析</a></p><p><a href="https://blog.csdn.net/boweiqiang/article/details/116309452">非对称加密RSA公私钥pkcs1与pkcs8格式的转换</a></p><p>将<span class="math inline">\(pem\)</span>证书的<strong><span class="math inline">\(base64\)</span>解码，再转<span class="math inline">\(hex\)</span></strong>,分割出<span class="math inline">\(n,e,d,p,q\)</span>.在这里<span class="math inline">\(d_{p},d_{q},m_{p}\)</span>是没有泄露的。</p><p><img src="/2023/09/04/2023%E7%BE%8A%E5%9F%8E%E6%9D%AF/xor-1693824738136-2.jpg"></p><p>最后发现真正的<span class="math inline">\(flag\)</span>是<span class="math inline">\(RSA\)</span>的<span class="math inline">\(flag\)</span>和社会主义核心价值观解码结果异或的结果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes, bytes_to_long</span><br><span class="line"></span><br><span class="line"># s = &#x27;00 ca d4 c2 9d 01 7e 30 dd ab d6 06 80 50 44 d9 ca 3e 6a 31 84 fb 4e 1f 33 28 45 55 54 98 c3 6b 02 e7 b9 7e 2e b0 9d 85 c9 19 e3 0a 49 3c e9 4e f9 41 22 61 c3 99 8c 73 44 27 1b 6e 6e 1b 3d fe fb&#x27;</span><br><span class="line"># n1 = &#x27;&#x27;</span><br><span class="line"># sum = 0</span><br><span class="line"># for i in s:</span><br><span class="line">#     if i != &#x27; &#x27;:</span><br><span class="line">#         n1 += i</span><br><span class="line">#     else:</span><br><span class="line">#         sum += 1</span><br><span class="line"># print(n1)</span><br><span class="line"># print(sum)</span><br><span class="line">n = 0x00b9ad332fb6b87d59b5b20b4ae880ba416d8724111f99a9ed498bcb365091d83dcc43fdff9b607df8a443bcadc79907c921e76b38003b5b0ece660437803195ebfab9a7e23fc0751228fdeefe5591827523d7b79ad04d85e4db5caa13f28a7e0124357d0685e00f14ccbb9679979923c2531ff487f9ba2500ade48995c315d9130203010001</span><br><span class="line">d = 0x00974ebb2da0bb0afb3603970c3e17d8b044af22070a3750b05b849ddeef1d4a986182eed3832cc8bafc316eea36835042e96c0a85a23abc637e72c7f0ea787df06127fe9dc3d21b8dae8018bdffc345107d5271ddb6d5fbc01f8cbf73f44410d61e006208356f1c5b85515efc708b34b676e78f18d4d3b68f5765d10b701f0361</span><br><span class="line">p = 0x00ea59434f560de2eaf4f21c22fb10691b79485e6290007dc28242bc63739fb95fa03e5ed807000d491f0ca43e50a91d43a6940f390c91757a3ba8226ce58112c9</span><br><span class="line">q = 0x00cad4c29d017e30ddabd606805044d9ca3e6a3184fb4e1f332845555498c36b02e7b97e2eb09d85c919e30a493ce94ef9412261c3998c7344271b6e6e1b3dfefb</span><br><span class="line">e = 0x010001</span><br><span class="line">c = 91817924748361493215143897386603397612753451291462468066632608541316135642691873237492166541761504834463859351830616117238028454453831120079998631107520871612398404926417683282285787231775479511469825932022611941912754602165499500350038397852503264709127650106856760043956604644700201911063515109074933378818</span><br><span class="line"># print(p*q == n)</span><br><span class="line"></span><br><span class="line"># print(p == p1)</span><br><span class="line"># print(q == q1)</span><br><span class="line">m = gmpy2.powmod(c,d,p*q)</span><br><span class="line">m1 = b&#x27;C0ngr4tulati0n5_y0u_fou^d_m3&#x27;</span><br><span class="line">print(long_to_bytes(m^bytes_to_long(m1)))</span><br></pre></td></tr></table></figure><h3 id="复现">复现</h3><h4 id="esyrsa">esyRSA</h4><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import invert</span><br><span class="line">from md5 import md5</span><br><span class="line">from secret import p, q</span><br><span class="line"></span><br><span class="line">e = ?????</span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-1)*(q-1)</span><br><span class="line">d = invert(e, phi)</span><br><span class="line">ans = gcd(e,phi)</span><br><span class="line"></span><br><span class="line">print n, e, d</span><br><span class="line">print &quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p + q)).hexdigest()</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">n = 8064259277274639864655809758868795854117113170423331934498023294296505063511386001711751916634810056911517464467899780578338013011453082479880809823762824723657495915284790349150975180933698827382368698861967973964030509129133021116919437755292590841218316278732797712538885232908975173746394816520256585937380642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br><span class="line">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>题目分析：就是一个<span class="math inline">\(RSA\)</span>，给了<span class="math inline">\(n,d\)</span>但是需要恢复<span class="math inline">\(e\)</span>，最后让我们求的是<span class="math inline">\(p+q\)</span>.这里需要注意的是，<span class="math inline">\(n\)</span>重复了一遍，去除重复部分才是真正的<span class="math inline">\(n\)</span>.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br></pre></td></tr></table></figure><h5 id="格求解">格求解</h5><p>比赛的时候我其实是想过用格来解决的，但是我尝试失败了。之后看到一个师傅的<span class="math inline">\(WP\)</span>就是用格来求解的。 <span class="math display">\[e*d\equiv1\textbf{ }mod\textbf{ }phi\Rightarrow\]</span></p><p><span class="math display">\[e*d=k*n-k*(p+q-1)+1\]</span></p><p><span class="math display">\[(k,e)\begin{pmatrix}n, &amp;0 \\-d,&amp;2^{512}\end{pmatrix}=(k*(p+q-1)-1,e*2^{512})\]</span></p><p><strong>这里解释一下为什么要这样构造格。</strong></p><p><strong><span class="math inline">\(p,q\)</span>都是<span class="math inline">\(512bit\)</span>,而<span class="math inline">\(e\)</span>是比较小的（只有5位数），为了使目标向量的两个坐标差不多大，让<span class="math inline">\(e\)</span>乘上<span class="math inline">\(2^{512}\)</span>.</strong>(我当时就是没乘。。)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from hashlib import md5</span><br><span class="line">import gmpy2</span><br><span class="line">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br><span class="line">n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br><span class="line">m = matrix(ZZ, [[n,0],[-d,2**512]])</span><br><span class="line">k_pq, e = m.LLL()[0]</span><br><span class="line">print(&quot;k_pq = &quot;, k_pq)</span><br><span class="line">print(&quot;e = &quot;,e)</span><br><span class="line">k_pq = abs(k_pq)</span><br><span class="line">e = abs(e)//2**512</span><br><span class="line">k = gcd(e*d-1,k_pq+1)</span><br><span class="line">p_q = (k_pq+1)//k+1</span><br><span class="line">print(&quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p_q).encode()).hexdigest())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flag: DASCTF&#123;4ae33bea90f030bfddb7ac4d9222ef8f&#125;</span><br></pre></td></tr></table></figure><h5 id="连分数求解">连分数求解</h5><p><span class="math display">\[e*d\equiv1\textbf{ }mod\textbf{ }phi\Rightarrow\]</span></p><p><span class="math display">\[e*d=k*phi+1\Rightarrow\]</span></p><p><span class="math display">\[同除以e*phi,\frac{d}{phi}=\frac{k}{e}+\frac{1}{e*phi}\]</span></p><p><span class="math display">\[因为phi\approx n,且phi非常大,所以\frac{1}{e*phi}\approx 0\]</span></p><p><span class="math display">\[所以，\frac{d}{n}=\frac{k}{e}+\frac{1}{e*phi}\]</span></p><p><span class="math display">\[也就是说，\frac{d}{n}\approx\frac{k}{e}\]</span></p><p><span class="math display">\[而d,n是已知的，所以对\frac{d}{n}进行连分数展开，得到的一串分母很有可能就是e\]</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sage</span><br><span class="line">from hashlib import md5</span><br><span class="line"></span><br><span class="line">n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br><span class="line">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br><span class="line"></span><br><span class="line">c = continued_fraction(d/n)  # 计算连分数</span><br><span class="line">i = 1</span><br><span class="line">while True:</span><br><span class="line">    k = c.numerator(i)  # 分子</span><br><span class="line">    e = c.denominator(i) # 分母</span><br><span class="line">    if (e*d-1) % k == 0 and len(str(e)) == 5:</span><br><span class="line">        print(k)</span><br><span class="line">        print(e)</span><br><span class="line">        p_q = n+1-(e*d-1)//k</span><br><span class="line">        break</span><br><span class="line">    i+=1</span><br><span class="line">print(f&quot;p+q = &#123;p_q&#125;&quot;)</span><br><span class="line">print(&quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p_q).encode()).hexdigest())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flag: DASCTF&#123;4ae33bea90f030bfddb7ac4d9222ef8f&#125;</span><br></pre></td></tr></table></figure><h5 id="维纳攻击求解">维纳攻击求解</h5><p><strong>维纳攻击的核心就在于连分数</strong>，所以用维纳攻击的脚本来求解也是可以的。</p><p>参考：<a href="https://blog.csdn.net/fengerxi33/article/details/123007453">CTF-RSA_维纳攻击脚本</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from hashlib import md5</span><br><span class="line"></span><br><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">def continuedFra(x, y):</span><br><span class="line">    &quot;&quot;&quot;计算连分数</span><br><span class="line">    :param x: 分子</span><br><span class="line">    :param y: 分母</span><br><span class="line">    :return: 连分数列表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    cf = []</span><br><span class="line">    while y:</span><br><span class="line">        cf.append(x // y)</span><br><span class="line">        x, y = y, x % y</span><br><span class="line">    return cf</span><br><span class="line">def gradualFra(cf):</span><br><span class="line">    &quot;&quot;&quot;计算传入列表最后的渐进分数</span><br><span class="line">    :param cf: 连分数列表</span><br><span class="line">    :return: 该列表最后的渐近分数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    numerator = 0</span><br><span class="line">    denominator = 1</span><br><span class="line">    for x in cf[::-1]:</span><br><span class="line">        # 这里的渐进分数分子分母要分开</span><br><span class="line">        numerator, denominator = denominator, x * denominator + numerator</span><br><span class="line">    return numerator, denominator</span><br><span class="line">def solve_pq(a, b, c):</span><br><span class="line">    &quot;&quot;&quot;使用韦达定理解出pq，x^2−(p+q)∗x+pq=0</span><br><span class="line">    :param a:x^2的系数</span><br><span class="line">    :param b:x的系数</span><br><span class="line">    :param c:pq</span><br><span class="line">    :return:p，q</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    par = gmpy2.isqrt(b * b - 4 * a * c)</span><br><span class="line">    return (-b + par) // (2 * a), (-b - par) // (2 * a)</span><br><span class="line">def getGradualFra(cf):</span><br><span class="line">    &quot;&quot;&quot;计算列表所有的渐近分数</span><br><span class="line">    :param cf: 连分数列表</span><br><span class="line">    :return: 该列表所有的渐近分数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    gf = []</span><br><span class="line">    for i in range(1, len(cf) + 1):</span><br><span class="line">        gf.append(gradualFra(cf[:i]))</span><br><span class="line">    return gf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def wienerAttack(d, n):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param d:</span><br><span class="line">    :param n:</span><br><span class="line">    :return: e</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    cf = continuedFra(d, n)</span><br><span class="line">    gf = getGradualFra(cf)</span><br><span class="line">    for e, k in gf:</span><br><span class="line">        if k == 0:</span><br><span class="line">            continue</span><br><span class="line">        if (e * d - 1) % k != 0:</span><br><span class="line">            continue</span><br><span class="line">        phi = (e * d - 1) // k</span><br><span class="line">        # p, q = solve_pq(1, n - phi + 1, n)</span><br><span class="line">        if len(str(e))==5:</span><br><span class="line">            p_q = n+1-(e*d-1)//k</span><br><span class="line">            return e,p_q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br><span class="line">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br><span class="line"></span><br><span class="line">e,p_q = wienerAttack(d, n)</span><br><span class="line">print(f&quot;e = &#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p_q).encode()).hexdigest())</span><br></pre></td></tr></table></figure><h6 id="xenny库">xenny库</h6><p>值得一提的是，我们也<strong>可以直接用<span class="math inline">\(Xenny库\)</span>里面的<span class="math inline">\(wiener函数\)</span>解决</strong>。<span class="math inline">\(xenny师傅\)</span>真的泰裤辣！！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from hashlib import md5</span><br><span class="line">from xenny.ctf.crypto.modern.asymmetric.rsa import wiener</span><br><span class="line">n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span><br><span class="line">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span><br><span class="line"></span><br><span class="line">e,p,q = wiener.attack(n, d)</span><br><span class="line">print(f&quot;e = &#123;e&#125;&quot;)</span><br><span class="line">print(&quot;p = &quot;,p)</span><br><span class="line">print(&quot;q = &quot;,q)</span><br><span class="line">print(&quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p + q).encode()).hexdigest())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 13521</span><br><span class="line">p =  10181341212828413853336916619161138854377885230386496425058202154486415709366161346816273366144505351043947477469664133317598479763451392984403646602585037</span><br><span class="line">q =  7920625690369490250766357750388349704260128405941822835255851274284409978206593795103040446837018619894098452542488850045009467407103749792461438242280929</span><br><span class="line">Flag: DASCTF&#123;4ae33bea90f030bfddb7ac4d9222ef8f&#125;</span><br></pre></td></tr></table></figure><h3 id="mceorpkpleer">MCeorpkpleer</h3><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pubkey(list, m, w):</span><br><span class="line">    pubkey_list = []</span><br><span class="line">    for i in range(len(e_bin)):</span><br><span class="line">        pubkey_list.append(w * list[i] % m)</span><br><span class="line">    return pubkey_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def e_cry(e, pubkey):</span><br><span class="line">    pubkey_list = pubkey</span><br><span class="line">    encode = 0</span><br><span class="line">    for i in range(len(e)):</span><br><span class="line">        encode += pubkey_list[i] * int(e[i]) % m</span><br><span class="line">    return encode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">n = p * q</span><br><span class="line">e = getPrime(64)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line"></span><br><span class="line">e_bin = (bin(e))[2:]</span><br><span class="line">list = [pow(3, i) for i in range(len(e_bin))]</span><br><span class="line">m = getPrime(len(bin(sum(list))) - 1)</span><br><span class="line">w = getPrime(64)</span><br><span class="line">pubkey = pubkey(list, m, w)</span><br><span class="line">en_e = e_cry(e_bin, pubkey)</span><br><span class="line"></span><br><span class="line">print(&#x27;p = &#123;&#125;\n&#x27;</span><br><span class="line">      &#x27;n = &#123;&#125;\n&#x27;</span><br><span class="line">      &#x27;c = &#123;&#125;\n&#x27;</span><br><span class="line">      &#x27;pubkey = &#123;&#125;\n&#x27;</span><br><span class="line">      &#x27;en_e = &#123;&#125;&#x27;.format((p &gt;&gt; 435) &lt;&lt; 435, n, c, pubkey, en_e))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p = 139540788452365306201344680691061363403552933527922544113532931871057569249632300961012384092481349965600565669315386312075890938848151802133991344036696488204791984307057923179655351110456639347861739783538289295071556484465877192913103980697449775104351723521120185802327587352171892429135110880845830815744</span><br><span class="line">n = 22687275367292715121023165106670108853938361902298846206862771935407158965874027802803638281495587478289987884478175402963651345721058971675312390474130344896656045501040131613951749912121302307319667377206302623735461295814304029815569792081676250351680394603150988291840152045153821466137945680377288968814340125983972875343193067740301088120701811835603840224481300390881804176310419837493233326574694092344562954466888826931087463507145512465506577802975542167456635224555763956520133324723112741833090389521889638959417580386320644108693480886579608925996338215190459826993010122431767343984393826487197759618771</span><br><span class="line">c = 156879727064293983713540449709354153986555741467040286464656817265584766312996642691830194777204718013294370729900795379967954637233360644687807499775502507899321601376211142933572536311131955278039722631021587570212889988642265055045777870448827343999745781892044969377246509539272350727171791700388478710290244365826497917791913803035343900620641430005143841479362493138179077146820182826098057144121231954895739989984846588790277051812053349488382941698352320246217038444944941841831556417341663611407424355426767987304941762716818718024107781873815837487744195004393262412593608463400216124753724777502286239464</span><br><span class="line">pubkey = [18143710780782459577, 54431132342347378731, 163293397027042136193, 489880191081126408579, 1469640573243379225737, 4408921719730137677211, 13226765159190413031633, 39680295477571239094899, 119040886432713717284697, 357122659298141151854091, 1071367977894423455562273, 3214103933683270366686819, 9642311801049811100060457, 28926935403149433300181371, 86780806209448299900544113, 260342418628344899701632339, 781027255885034699104897017, 2343081767655104097314691051, 7029245302965312291944073153, 21087735908895936875832219459, 63263207726687810627496658377, 189789623180063431882489975131, 569368869540190295647469925393, 1708106608620570886942409776179, 601827224419797931380408071500, 1805481673259393794141224214500, 893952418336266652976851386463, 2681857255008799958930554159389, 3523079163584485147344841221130, 1524252287869625983140881149316, 50264262166963219975822190911, 150792786500889659927466572733, 452378359502668979782399718199, 1357135078508006939347199154597, 4071405235524020818041597463791, 3169230503688232995231149877299, 462706308180869526799807117823, 1388118924542608580399421353469, 4164356773627825741198264060407, 3448085117999647764701149667147, 1299270151115113835209806487367, 3897810453345341505629419462101, 2648446157152195057994615872229, 3422845870014670444537026359650, 1223552407160181874717436564876, 3670657221480545624152309694628, 1966986461557807413563286569810, 1378466783231507511243038452393, 4135400349694522533729115357179, 3361215846199738142293703557463, 1038662335715384967987468158315, 3115987007146154903962404474945, 302975818554635252993570910761, 908927455663905758980712732283, 2726782366991717276942138196849, 3657854499533237101379593333510, 1928578295715881845245137486456, 1263242285705730806288591202331, 3789726857117192418865773606993, 2324195368467747797703678306905, 2450093503961328663664213663678, 2827787910442071261545819733997, 3960871129884299055190637944954, 2837628186769067706678271320788]</span><br><span class="line">en_e = 31087054322877663244023458448558</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>题目分析：</p><p>梳理一下已知信息： <span class="math display">\[p高位，n,c,en_e\]</span></p><p><span class="math display">\[e是64bit,那么列表list也是已知的\]</span></p><p>未知： <span class="math display">\[q,e\]</span> 给出<span class="math inline">\(p\)</span>高位，<span class="math inline">\(copper\)</span>就可以恢复<span class="math inline">\(p\)</span>.继而就能知道<span class="math inline">\(q\)</span></p><p>列表<span class="math inline">\(list\)</span>的值是已知的,且<span class="math inline">\(list[0]\)</span>就是<span class="math inline">\(W\)</span>. <span class="math display">\[pubkey[i]=w*list[i]\textbf{ }mod\textbf{ }m\Rightarrow\]</span></p><p><span class="math display">\[k*m=pubkey[i]-w*list[i]\]</span></p><p>求出多组<span class="math inline">\(k*m\)</span>,这些<span class="math inline">\(k*m\)</span>的最大公因数就是<span class="math inline">\(m\)</span>。</p><p>再看<span class="math inline">\(list\)</span>是一个<strong>超递增序列</strong>，直接用<strong>贪心算法</strong>求解<span class="math inline">\(e\)</span>。 <span class="math display">\[encode=(pubkey[0]*e[0]+pubkey[1]*e[1]+...+pubkey[63]*e[63])\textbf{}mod\textbf{ }m\]</span></p><p><span class="math display">\[=((w*list[0])*e[0]+(w*list[1])*e[1]+...+(w*list[63])*e[63])\textbf{}mod\textbf{ }m\]</span></p><p><span class="math display">\[=w*(list[0]*e[0]+list[1]*e[1]+...+list[63]*e[63])\textbf{ }mod \textbf{}m\]</span></p><p><span class="math display">\[所以，encode*w^{-1}=(list[0]*e[0]+list[1]*e[1]+...+list[63]*e[63])\textbf{}mod \textbf{ }m\]</span></p><p><span class="math inline">\(copper\)</span>解<span class="math inline">\(p\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#sage</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">hint = 139540788452365306201344680691061363403552933527922544113532931871057569249632300961012384092481349965600565669315386312075890938848151802133991344036696488204791984307057923179655351110456639347861739783538289295071556484465877192913103980697449775104351723521120185802327587352171892429135110880845830815744</span><br><span class="line">n = 22687275367292715121023165106670108853938361902298846206862771935407158965874027802803638281495587478289987884478175402963651345721058971675312390474130344896656045501040131613951749912121302307319667377206302623735461295814304029815569792081676250351680394603150988291840152045153821466137945680377288968814340125983972875343193067740301088120701811835603840224481300390881804176310419837493233326574694092344562954466888826931087463507145512465506577802975542167456635224555763956520133324723112741833090389521889638959417580386320644108693480886579608925996338215190459826993010122431767343984393826487197759618771</span><br><span class="line"></span><br><span class="line">p_high = hint</span><br><span class="line"># print(p_high)</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = p_high + x</span><br><span class="line">x = f.small_roots(X=2^435, beta=0.4)[0]</span><br><span class="line">p = p_high+int(x)</span><br><span class="line">q = n//p</span><br><span class="line">print(f&quot;p = &#123;p&#125;&quot;)</span><br><span class="line">print(f&quot;q = &#123;q&#125;&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = 139540788452365306201344680691061363403552933527922544113532931871057569249632300961012384092481349965600565669315386312075890938848151802133991344036696488204791984307057923179677630589032444985150800881889090713797496239571291907818169058929859395965304623825442220206712660451198754072531986630133689525911</span><br><span class="line">q = 162585259972480477964240855936099163585362299488578311068842002571891718764319834825730036484383081273549236661473286892739224906812137330941622699836239606393084030874487072527724286268715004074797344316619876830720445250395986443767703356842297999006344406006724963545062388183647988548800359369190326996261</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>求<span class="math inline">\(m\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = [pow(3, i) for i in range(64)]</span><br><span class="line">w = pubkey[0]</span><br><span class="line">m_len = len(bin(sum(list))) - 1</span><br><span class="line">k_m = []</span><br><span class="line">for i in range(63,50,-1):</span><br><span class="line">    k_m.append(pubkey[i]-w*list[i])</span><br><span class="line">m = k_m[0]</span><br><span class="line">for num in k_m[1:]:</span><br><span class="line">    m = gmpy2.gcd(m,num)</span><br><span class="line">    if isPrime(m) and m.bit_length() == m_len:</span><br><span class="line">        print(&quot;m =&quot;,m)</span><br><span class="line">        break</span><br><span class="line">        </span><br><span class="line"># m = 4522492601441914729446821257037</span><br></pre></td></tr></table></figure><p>贪心算法求解<span class="math inline">\(e\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S = en_e * gmpy2.invert(w,m)</span><br><span class="line">M = list</span><br><span class="line">e = &#x27;&#x27;</span><br><span class="line">for i in range(len(M)-1,-1,-1):</span><br><span class="line">    if S &gt;= M[i]:</span><br><span class="line">        e += &#x27;1&#x27;</span><br><span class="line">        S -= M[i]</span><br><span class="line">    else:</span><br><span class="line">        e += &#x27;0&#x27;</span><br><span class="line">e = int(e[::-1],2)</span><br><span class="line">print(&quot;e =&quot;,e)</span><br><span class="line"></span><br><span class="line"># e = 15960663600754919507</span><br></pre></td></tr></table></figure><p>最后解<span class="math inline">\(RSA\)</span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">p = 139540788452365306201344680691061363403552933527922544113532931871057569249632300961012384092481349965600565669315386312075890938848151802133991344036696488204791984307057923179677630589032444985150800881889090713797496239571291907818169058929859395965304623825442220206712660451198754072531986630133689525911</span><br><span class="line">q = 162585259972480477964240855936099163585362299488578311068842002571891718764319834825730036484383081273549236661473286892739224906812137330941622699836239606393084030874487072527724286268715004074797344316619876830720445250395986443767703356842297999006344406006724963545062388183647988548800359369190326996261</span><br><span class="line">c = 156879727064293983713540449709354153986555741467040286464656817265584766312996642691830194777204718013294370729900795379967954637233360644687807499775502507899321601376211142933572536311131955278039722631021587570212889988642265055045777870448827343999745781892044969377246509539272350727171791700388478710290244365826497917791913803035343900620641430005143841479362493138179077146820182826098057144121231954895739989984846588790277051812053349488382941698352320246217038444944941841831556417341663611407424355426767987304941762716818718024107781873815837487744195004393262412593608463400216124753724777502286239464</span><br><span class="line"></span><br><span class="line">e = 15960663600754919507</span><br><span class="line">d = gmpy2.invert(e,(p-1)*(q-1))</span><br><span class="line">real_m = gmpy2.powmod(c,d,p*q)</span><br><span class="line">print(long_to_bytes(real_m))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DASCTF&#123;T81I_tPPS_6r7g_xlPi_OO3M_6vyV_Rkba&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格密码</title>
      <link href="/2023/08/25/%E6%A0%BC%E5%AF%86%E7%A0%81/"/>
      <url>/2023/08/25/%E6%A0%BC%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>解格问题的关键其实就是<strong>用已知的信息去构造矩阵，求出未知的信息。</strong></p><p>​</p><h1 id="先看-nssctf-上的一些题">先看 NSSCTF 上的一些题</h1><h2 id="p3用格解决rsa">P3（用格解决RSA)</h2><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">a = getPrime(1024)</span><br><span class="line">b = getPrime(1536)</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">r = random.randint(2**14, 2**15)</span><br><span class="line">assert ((p-r) * a + q) % b &lt; 50</span><br><span class="line"></span><br><span class="line">c = pow( m, 65537, p*q )</span><br><span class="line"></span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line">print(f&#x27;a = &#123;a&#125;&#x27;)</span><br><span class="line">print(f&#x27;b = &#123;b&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">c = 78168998533427639204842155877581577797354503479929547596593341570371249960925614073689003464816147666662937166442652068942931518685068382940712171137636333670133426565340852055387100597883633466292241406019919037053324433086548680586265243208526469135810446004349904985765547633536396188822210185259239807712</span><br><span class="line">a = 134812492661960841508904741709490501744478747431860442812349873283670029478557996515894514952323891966807395438595833662645026902457124893765483848187664404810892289353889878515048084718565523356944401254704006179297186883488636493997227870769852726117603572452948662628907410024781493099700499334357552050587</span><br><span class="line">b = 1522865915656883867403482317171460381324798227298365523650851184567802496240011768078593938858595296724393891397782658816647243489780661999411811900439319821784266117539188498407648397194849631941074737391852399318951669593881907935220986282638388656503090963153968254244131928887025800088609341714974103921219202972691321661198135553928411002184780139571149772037283749086504201758438589417378336940732926352806256093865255824803202598635567105242590697162972609</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>加密过程：</p><p><span class="math display">\[((p-r)*a+q)\textit{ }mod\textit{ }b&lt;50\]</span> 解密：</p><p>​ <span class="math inline">\(已知，r=14\textit{ }bits\)</span></p><p>​ <span class="math inline">\(我们不防设x=((p-r)*a+q)\textit{}mod\textit{ }b\)</span></p><p>​ <span class="math inline">\(则x-q=k*b+(p-r)*a\)</span></p><p>题目已知<span class="math inline">\(c,a,b\)</span>的值，要求<span class="math inline">\(m\)</span>,我们必须要求出<span class="math inline">\(p,q\)</span>,那么我们就可以用<span class="math inline">\(a,b\)</span>来构造矩阵，求解<span class="math inline">\(p,q或者跟p,q有关的信息\)</span></p><p>不防构造格<span class="math inline">\(L\)</span> <span class="math display">\[(k,p-r)\begin{pmatrix}b,0\\a,1\end{pmatrix}=(x-q,p-r)\]</span> 这样我们就能求出<span class="math inline">\(与p,q有关的信息，也就是x-q,p-r\)</span>了。根据<span class="math inline">\(Hermite\)</span>定理我们来计算一下，这样构造格是否可行呢?</p><p>​<br><span class="math display">\[\lambda(L)\leqslant\sqrt{1024*2+512*2}=\sqrt{3072}=\sqrt{2}*\sqrt[2]{b}=\sqrt{2b}\]</span> 所以是满足用<span class="math inline">\(LLL算法\)</span>求解<span class="math inline">\(SVP\)</span>问题的。</p><p>求解出<span class="math inline">\(x-q,p-r\)</span>后，<span class="math inline">\(x和r\)</span>的范围是已知的，我们就可以用循环来爆破出<span class="math inline">\(q和p\)</span></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from tqdm import *</span><br><span class="line"></span><br><span class="line">c = 78168998533427639204842155877581577797354503479929547596593341570371249960925614073689003464816147666662937166442652068942931518685068382940712171137636333670133426565340852055387100597883633466292241406019919037053324433086548680586265243208526469135810446004349904985765547633536396188822210185259239807712</span><br><span class="line">a = 134812492661960841508904741709490501744478747431860442812349873283670029478557996515894514952323891966807395438595833662645026902457124893765483848187664404810892289353889878515048084718565523356944401254704006179297186883488636493997227870769852726117603572452948662628907410024781493099700499334357552050587</span><br><span class="line">b = 1522865915656883867403482317171460381324798227298365523650851184567802496240011768078593938858595296724393891397782658816647243489780661999411811900439319821784266117539188498407648397194849631941074737391852399318951669593881907935220986282638388656503090963153968254244131928887025800088609341714974103921219202972691321661198135553928411002184780139571149772037283749086504201758438589417378336940732926352806256093865255824803202598635567105242590697162972609</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line"># ((p-r) * a + q) % b &lt; 50</span><br><span class="line"></span><br><span class="line">mat = [[b,0],[a,1]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">hh = M.LLL()</span><br><span class="line"># print(hh)</span><br><span class="line"></span><br><span class="line">p = abs(hh[0][1])  # p-r</span><br><span class="line">q = abs(hh[0][0])  # q-x</span><br><span class="line"></span><br><span class="line">for i in tqdm(range(2**14, 2**15)):</span><br><span class="line">    for j in range(50):</span><br><span class="line">        pp = p + i</span><br><span class="line">        qq = q + j</span><br><span class="line">        phi = (pp-1)*(qq-1)</span><br><span class="line">        if gcd(phi, 65537) != 1:</span><br><span class="line">            continue</span><br><span class="line">        d = inverse(e,phi)</span><br><span class="line">        n = pp*qq</span><br><span class="line">        m = pow(c,d,n)</span><br><span class="line">        flag = long_to_bytes(int(m))</span><br><span class="line">        if b&#x27;NSSCTF&#x27; in flag :</span><br><span class="line">            print(flag)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><p>这里解释一下：</p><p><span class="math inline">\(mat\)</span>是一个<span class="math inline">\(2*2\)</span>的矩阵；</p><p><span class="math inline">\(M\)</span>是将这个矩阵转化为整数域<span class="math inline">\(ZZ\)</span> 上的矩阵。</p><h2 id="p4">P4</h2><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">p = getPrime(1024)</span><br><span class="line">r = getPrime(175)</span><br><span class="line">a = inverse(r, p)</span><br><span class="line">a = (a*flag) % p</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;a&#125;&#x27;)</span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247</span><br><span class="line">p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>加密过程： <span class="math display">\[a=(flag*r^{-1})\textit{ }mod\textit{ }p\]</span> 解密： <span class="math display">\[a*r=flag\textit{ }mod\textit{ }p\Rightarrow flag=k*p+a*r\]</span> <span class="math inline">\(a,p\)</span>我们是已知的，我们就可以利用<span class="math inline">\(a,p\)</span>去构造格<span class="math inline">\(L\)</span>, <span class="math display">\[(k,a)\begin{pmatrix}p,0\\r,1\end{pmatrix}=(flag,a)\]</span> exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247</span><br><span class="line">p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591</span><br><span class="line"></span><br><span class="line"># a * r = flag mod p</span><br><span class="line"># r 175 bits </span><br><span class="line"></span><br><span class="line"># k*p  + a* r  = flag </span><br><span class="line">mat = [[p,0],[a,1]] </span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">hh = M.LLL()</span><br><span class="line">m = hh[0][0]</span><br><span class="line">flag = long_to_bytes(m)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h2 id="p5">P5</h2><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">assert m.bit_length() == 351</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">b = getPrime(1024)</span><br><span class="line">c = getPrime(400)</span><br><span class="line"></span><br><span class="line">a = (b*m + c) % p</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;a&#125;&#x27;)</span><br><span class="line">print(f&#x27;b = &#123;b&#125;&#x27;)</span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 92716521851427599147343828266552451834533034815416003395170301819889384044273026852184291232938197215198124164263722270347104189412921224361134013717269051168246275213624264313794650441268405062046423740836145678559969020294978939553573428334198212792931759368218132978344815862506799287082760307048309578592</span><br><span class="line">b = 155530728639099361922541063573602659584927544589739208888076194504495146661257751801481540924821292656785953391450218803112838556107960071792826902126414012831375547340056667753587086997958522683688746248661290255381342148052513971774612583235459904652002495564523557637169529882928308821019659377248151898663</span><br><span class="line">p = 100910862834849216140965884888425432690937357792742349763319405418823395997406883138893618605587754336982681610768197845792843123785451070312818388494074168909379627989079148880913190854232917854414913847526564520719350308494462584771237445179797367179905414074344416047541423116739621805238556845903951985783</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>加密： <span class="math display">\[a=(b*m+c)\textit{ }mod\textit{ }p\]</span> 解密： <span class="math display">\[a=k*p+(b*m+c)\Rightarrow c=k*p-b*m+a\]</span> <span class="math inline">\(a,b,p\)</span>我们是已知的，不防这样构造格<span class="math inline">\(L\)</span>, <span class="math display">\[(k,-m,1)\begin{pmatrix}p,\textit{ }\textit{ }0,\textit{ }0\\b,\textit{}\textit{ }1,\textit{ }0\\\textit{ }\textit{ }\textit{ }\textit{ }a\textit{ },\textit{ }\textit{}0,\textit{ }2^{400}\end{pmatrix}=(c,m,2^{400})\]</span> <strong>这里我们需要解释一下，格<span class="math inline">\(L\)</span>最后一列为什么那样构造。（这里参考了DexterJie师傅的博客）</strong></p><p><strong>我们已经知道，<span class="math inline">\(LLL\)</span>是一种格基规约算法，是用来解决<span class="math inline">\(SVP\)</span>问题的。我们可以根据<span class="math inline">\(Hermite\)</span>定理知道最短向量的上限。即</strong><span class="math display">\[\lambda(L)\leqslant\sqrt{n}\sqrt[n]{det(\lambda)}\]</span> <strong>我们注意到<span class="math inline">\(c=400\textit{}bit,m=351\textit{ }bit\)</span>,所以向量<span class="math inline">\((c,m,?)\)</span>的长度应该在<span class="math inline">\(400\textit{ }bit\)</span>左右。</strong></p><p><strong>所以 <span class="math inline">\(400\leqslant\sqrt{3}\sqrt[3]{det(L)}\)</span>,所以<span class="math inline">\(?\)</span>应该大于等于<span class="math inline">\(180\textit{}bit\)</span>???</strong>(这里我还是比较有疑惑的），附上<span class="math inline">\(DexterJie\)</span>师傅的理解吧</p><p><img src="/2023/08/25/%E6%A0%BC%E5%AF%86%E7%A0%81/image-20230825154823222.png"></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = 92716521851427599147343828266552451834533034815416003395170301819889384044273026852184291232938197215198124164263722270347104189412921224361134013717269051168246275213624264313794650441268405062046423740836145678559969020294978939553573428334198212792931759368218132978344815862506799287082760307048309578592</span><br><span class="line">b = 155530728639099361922541063573602659584927544589739208888076194504495146661257751801481540924821292656785953391450218803112838556107960071792826902126414012831375547340056667753587086997958522683688746248661290255381342148052513971774612583235459904652002495564523557637169529882928308821019659377248151898663</span><br><span class="line">p = 100910862834849216140965884888425432690937357792742349763319405418823395997406883138893618605587754336982681610768197845792843123785451070312818388494074168909379627989079148880913190854232917854414913847526564520719350308494462584771237445179797367179905414074344416047541423116739621805238556845903951985783</span><br><span class="line"></span><br><span class="line"># a*r = flag + k*p</span><br><span class="line">M = Matrix(ZZ,[[p,0,0],[a,2^200,0],[-b,0,1]]) # Matrix()函数通常采用数值作为参数并返回一个矩阵对象</span><br><span class="line">c,k,m = M.LLL()[0]</span><br><span class="line">&#x27;&#x27;&#x27;LLL 算法是一种格约化算法，用于查找格的约简基。</span><br><span class="line">LLL 方法返回一个由两个元素组成的元组：</span><br><span class="line">简化基和将原始基转换为简化基的矩阵&#x27;&#x27;&#x27;</span><br><span class="line">print(m)</span><br><span class="line">flag = long_to_bytes(abs(m))   # abs()返回数字的绝对值</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h2 id="p6-多组enc"><strong>P6 (多组e,n,c)</strong></h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line">d = getPrime(400)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(4):</span><br><span class="line">    p = getPrime(512)</span><br><span class="line">    q = getPrime(512)</span><br><span class="line">    n = p * q</span><br><span class="line">    e = inverse(d, (p-1)*(q-1))</span><br><span class="line">    c = pow(flag, e, n)</span><br><span class="line">    print(f&#x27;e&#123;i&#125; =&#x27;, e)</span><br><span class="line">    print(f&#x27;n&#123;i&#125; =&#x27;, n)</span><br><span class="line">    print(f&#x27;c&#123;i&#125; =&#x27;, c)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">e0 = 14663634286442041092028764808273515750847961898014201055608982250846018719684424125895815390624536073501623753618354026800118456911536861815261996929625814961086913500837475340797921236556312296934664701095834187857404704711288771338418177336783911864595983563560080719582434186801068157426993026446515265411</span><br><span class="line">n0 = 104543450623548393448505960506840545298706691237630183178416927557780858213264769135818447427794932329909731890957245926915280713988801182894888947956846369966245947852409172099018409057129584780443712258590591272371802134906914886744538889099861890573943377480028655951935894660286388060056770675084677768397</span><br><span class="line">c0 = 66400441793466385558399002350812383744096354576421495899465166492721568297592616443643465864544107914461044325088868615645524260480104397769130582397209585192620565774001015221725536884170662700337565613181799442382460047295553807602785067421981837709831158111951991854109179278733629950271657405211417740374</span><br><span class="line">e1 = 62005504700456859456675572895620453845623573672275890584145949847469951381521709553504593023003977393014834639251022203398533914340078480147377747715528821418445514563871411209895815634752533151145061594791024551625615960423026244560340983481137777162236719939420428613005457949228517914830194749293637917667</span><br><span class="line">n1 = 89410873947410184231222334229470195622685051370058935269198780539059522679122059486414591834635266301335656798768270022060656655274640699951736588085471509424575027153387518893978494158981314217195561629375189515702124478687925014362857206223379284909134299260355456357407022417434961226383007916607728238843</span><br><span class="line">c1 = 75133250536426006056029454024900058936095761927174304108454764308417889983571094946046507426319589437822458959089546795698076608690695326741772662156830944126301658579142020817338297043884836598263468494533324693019866746045910394812656639124276516075062088756043949581789436307373276242558429450971458945061</span><br><span class="line">e2 = 5365316217065391632204029784515519544882379449147835081003675696051077792179684123668298103660153980837519314114793091112163153158510344440829742753002176560016265852613076363394396640641504813912550948776926622696268531691467015580417575287779607009068332802842890478748171958455354463809356050553832863427</span><br><span class="line">n2 = 53325942266099921615667538877103327425435396909592382386684073177331528393295928518724880712900970020425481561110366696624090824641115147978830715508666547064446891727446073538022824237798568413003419382767587742032676311751819789672319289920011033523044026418650515529084031754775286163358926609712626506433</span><br><span class="line">c2 = 22289960513520782629306709529908652726794465066357062923684089176607114605563538085483920152508469429311012652149406853144200001391310165612163442404181970125704785325670969551080086517236489885046039799676581310781945432599048686184762485374030278657826206433571162451649808912276118945302558580745346371321</span><br><span class="line">e3 = 57257245945110486431680573908783487217316546039634811903637650579658516537372808464426294780698320301497615457264001148504941375058983426920721566040576604013497311914160175024860226623138659970105781812246471618831032554729317463745699993647224910498474869868186318188994237457335796911524629938029123055027</span><br><span class="line">n3 = 97233843381238063550322854422952777734101562842513647224354265328843953949189054347560960321126304504554067163501318212533606313039536188796999575130115659250566231010092273206623114900781284076452654791214088764465615154940874231056251107863895697778665275804663487113266180838319536762473697586368100928379</span><br><span class="line">c3 = 56606672064789484727896188434430896229911224588055894584797861263107870392831242138537980507537270618683458635389444257040355313948352917061971042629958646854593628522401074068536976581232979947149230764268377747754284783531803366391759725774562719884482404532619163798580872386794273190532863916038929461465</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf</p><p><span class="math display">\[c_{0} = m^{e_{0}} \pmod{n_{0}}\]</span></p><p><span class="math display">\[c_{1} = m^{e_{1}} \pmod{n_{1}}\]</span></p><p><span class="math display">\[c_{2} = m^{e_{2}} \pmod{n_{2}}\]</span></p><p><span class="math display">\[c_{3} = m^{e_{3}} \pmod{n_{3}}\]</span></p><p>分割 <span class="math display">\[M = \sqrt{n_{0}}\]</span></p><p><span class="math display">\[\left[ \begin{matrix} M &amp; e_{0} &amp; e_{1} &amp; e_{2} &amp; e_{3}\\ 0 &amp; -n_{0}&amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -n_{1} &amp;0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -n_{2} &amp; 0 \\ 0 &amp; 0 &amp; 0&amp; 0 &amp; -n_{3} \end{matrix} \right]\]</span></p><p><span class="math display">\[hh = L.LLL()\]</span></p><p><span class="math display">\[d = hh // M\]</span></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">e0 = 14663634286442041092028764808273515750847961898014201055608982250846018719684424125895815390624536073501623753618354026800118456911536861815261996929625814961086913500837475340797921236556312296934664701095834187857404704711288771338418177336783911864595983563560080719582434186801068157426993026446515265411</span><br><span class="line">n0 = 104543450623548393448505960506840545298706691237630183178416927557780858213264769135818447427794932329909731890957245926915280713988801182894888947956846369966245947852409172099018409057129584780443712258590591272371802134906914886744538889099861890573943377480028655951935894660286388060056770675084677768397</span><br><span class="line">c0 = 66400441793466385558399002350812383744096354576421495899465166492721568297592616443643465864544107914461044325088868615645524260480104397769130582397209585192620565774001015221725536884170662700337565613181799442382460047295553807602785067421981837709831158111951991854109179278733629950271657405211417740374</span><br><span class="line">e1 = 62005504700456859456675572895620453845623573672275890584145949847469951381521709553504593023003977393014834639251022203398533914340078480147377747715528821418445514563871411209895815634752533151145061594791024551625615960423026244560340983481137777162236719939420428613005457949228517914830194749293637917667</span><br><span class="line">n1 = 89410873947410184231222334229470195622685051370058935269198780539059522679122059486414591834635266301335656798768270022060656655274640699951736588085471509424575027153387518893978494158981314217195561629375189515702124478687925014362857206223379284909134299260355456357407022417434961226383007916607728238843</span><br><span class="line">c1 = 75133250536426006056029454024900058936095761927174304108454764308417889983571094946046507426319589437822458959089546795698076608690695326741772662156830944126301658579142020817338297043884836598263468494533324693019866746045910394812656639124276516075062088756043949581789436307373276242558429450971458945061</span><br><span class="line">e2 = 5365316217065391632204029784515519544882379449147835081003675696051077792179684123668298103660153980837519314114793091112163153158510344440829742753002176560016265852613076363394396640641504813912550948776926622696268531691467015580417575287779607009068332802842890478748171958455354463809356050553832863427</span><br><span class="line">n2 = 53325942266099921615667538877103327425435396909592382386684073177331528393295928518724880712900970020425481561110366696624090824641115147978830715508666547064446891727446073538022824237798568413003419382767587742032676311751819789672319289920011033523044026418650515529084031754775286163358926609712626506433</span><br><span class="line">c2 = 22289960513520782629306709529908652726794465066357062923684089176607114605563538085483920152508469429311012652149406853144200001391310165612163442404181970125704785325670969551080086517236489885046039799676581310781945432599048686184762485374030278657826206433571162451649808912276118945302558580745346371321</span><br><span class="line">e3 = 57257245945110486431680573908783487217316546039634811903637650579658516537372808464426294780698320301497615457264001148504941375058983426920721566040576604013497311914160175024860226623138659970105781812246471618831032554729317463745699993647224910498474869868186318188994237457335796911524629938029123055027</span><br><span class="line">n3 = 97233843381238063550322854422952777734101562842513647224354265328843953949189054347560960321126304504554067163501318212533606313039536188796999575130115659250566231010092273206623114900781284076452654791214088764465615154940874231056251107863895697778665275804663487113266180838319536762473697586368100928379</span><br><span class="line">c3 = 56606672064789484727896188434430896229911224588055894584797861263107870392831242138537980507537270618683458635389444257040355313948352917061971042629958646854593628522401074068536976581232979947149230764268377747754284783531803366391759725774562719884482404532619163798580872386794273190532863916038929461465</span><br><span class="line"></span><br><span class="line">M = gmpy2.iroot(n0,2)[0]</span><br><span class="line">mat = [[M, e0, e1, e2,e3],</span><br><span class="line">       [0,-n0,  0,  0, 0],</span><br><span class="line">       [0,  0,-n1,  0, 0],</span><br><span class="line">       [0,  0,  0,-n2, 0],</span><br><span class="line">       [0,  0,  0,  0,-n3]]</span><br><span class="line">L = Matrix(ZZ,mat)</span><br><span class="line">hh = L.LLL()[0]</span><br><span class="line">d = hh[0] // M</span><br><span class="line">m = gmpy2.powmod(c0,d,n0)</span><br><span class="line">flag = long_to_bytes(m)</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line"># NSSCTF&#123;12514adb-2c14-4777-96ff-90e95bc2b5cb&#125;</span><br></pre></td></tr></table></figure><h2 id="p7-扩展维纳攻击-两个小解密指数的情况">P7 (扩展维纳攻击两个小解密指数的情况)</h2><p>https://ctf-wiki.org/crypto/asymmetric/rsa/d_attacks/rsa_extending_wiener/</p><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p * q</span><br><span class="line">c = pow(flag, 65537, n)</span><br><span class="line">print(f&#x27;n =&#x27;, n)</span><br><span class="line">print(f&#x27;c =&#x27;, c)</span><br><span class="line">for i in range(2):</span><br><span class="line">    d = getPrime(350)</span><br><span class="line">    e = inverse(d, (p-1)*(q-1))</span><br><span class="line">    print(f&#x27;e&#123;i&#125; =&#x27;, e)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 110697784133988071803253124431092603234028687101567047811203431433689306543322837414808117411806181193598553341878079973980865551938790090419082150555675782822484149943421418447579383449269148197087985041351210982545320569973241390962326458234562044133505940521052500278777242988196544039226173227204865907343</span><br><span class="line">c = 3281096209929505523196793672137624804022934270452947405454462490250571524417033484978613243658208567511735641542935158434165363547355697159503378251318054879687577130170122911449101189974762808655638497967674004219512386442280269940950792767174561412932638740423542930763914255112354969122157915514816022159</span><br><span class="line">e0 = 28562806554366667733480283991307446762365777397933141571728113235368201162305126722188842319240464207580134816039095093401651171977877327756351539588974913736802534970867173212883308325913939353140276201705478124488858328502643345172188729914731042179091733244225184522680724392375975935305371163502863968963</span><br><span class="line">e1 = 28572469216883232254074869113744730984165641173439644880182528671699871929340616919028955398474678696802739685594548793470261306125219888911330937557582939811068530294470712859439149735950996866732508004061234613146407591546995439312326450834903885979660916965052092661398640105827442036234500556755520316031</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>使用 <span class="math display">\[W_1,G_{1,2},W_1*W_2\]</span> 来构造格子</p><p>考虑先构造一个对角矩阵<span class="math inline">\(D\)</span>, <span class="math display">\[D=\begin{pmatrix} N &amp; &amp; &amp; \\ &amp; N^{1/2} &amp; &amp; \\&amp; &amp; N^{1+\alpha 2} &amp; \\ &amp; &amp; &amp; 1 \end{pmatrix}\]</span> 最终我们构造的矩阵为 <span class="math display">\[L=\begin{pmatrix} 1 &amp; -N&amp;0 &amp;N^{2} \\ &amp;e_{1} &amp;-e_{1}&amp;-e_{1}N \\ &amp; &amp; e^{_{2}} &amp;-e_{2}N \\ &amp; &amp; &amp;e_{1}e_{2} \end{pmatrix}*D\]</span> exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line">N = 110697784133988071803253124431092603234028687101567047811203431433689306543322837414808117411806181193598553341878079973980865551938790090419082150555675782822484149943421418447579383449269148197087985041351210982545320569973241390962326458234562044133505940521052500278777242988196544039226173227204865907343</span><br><span class="line">c = 3281096209929505523196793672137624804022934270452947405454462490250571524417033484978613243658208567511735641542935158434165363547355697159503378251318054879687577130170122911449101189974762808655638497967674004219512386442280269940950792767174561412932638740423542930763914255112354969122157915514816022159</span><br><span class="line">e1 = 28562806554366667733480283991307446762365777397933141571728113235368201162305126722188842319240464207580134816039095093401651171977877327756351539588974913736802534970867173212883308325913939353140276201705478124488858328502643345172188729914731042179091733244225184522680724392375975935305371163502863968963</span><br><span class="line">e2 = 28572469216883232254074869113744730984165641173439644880182528671699871929340616919028955398474678696802739685594548793470261306125219888911330937557582939811068530294470712859439149735950996866732508004061234613146407591546995439312326450834903885979660916965052092661398640105827442036234500556755520316031</span><br><span class="line">e=65537</span><br><span class="line">a = 5/14</span><br><span class="line">D = diagonal_matrix(ZZ, [N, int(N^(1/2)), int(N^(1+a)), 1]) #创建对角矩阵</span><br><span class="line">M = matrix(ZZ, [[1, -N, 0, N^2], [0, e1, -e1, -e1*N], [0, 0, e2, -e2*N], [0, 0, 0, e1*e2]])*D</span><br><span class="line">L = M.LLL()</span><br><span class="line">t = vector(ZZ, L[0])  #创建一个管理，管理是一维数组或列表</span><br><span class="line"></span><br><span class="line">x = t * M^(-1)</span><br><span class="line">phi = int(x[1]/x[0]*e1)</span><br><span class="line">          </span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = gmpy2.powmod(c,d,N)</span><br><span class="line">flag = long_to_bytes(int(m))</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line">#  NSSCTF&#123;00121664-7e76-4f6f-a2f7-4813e21ff4aa&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明一下<span class="math inline">\(diagonal_matrix(zz,)\)</span>是在整数域上创建一个对角矩阵。</p>]]></content>
      
      
      <categories>
          
          <category> 格密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔二</title>
      <link href="/2023/08/22/%E9%9A%8F%E7%AC%94%E4%BA%8C/"/>
      <url>/2023/08/22/%E9%9A%8F%E7%AC%94%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="化简s-powp-q-n-powq-p-ntextbf-modtextbf-npq都是素数且npq">化简<span class="math inline">\(s = (pow(p, q, n) + pow(q, p, n))\textbf{ }mod\textbf{ } n,p,q都是素数且n=p*q\)</span></h2><p><span class="math display">\[s = (pow(p, q, n) + pow(q, p, n))\textbf{ } mod\textbf{ } n\]</span></p><p><span class="math display">\[=p^{q}\textbf{ }mod\textbf{ }n+q^{p}\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[=p^{q}\textbf{ }mod\textbf{ }(p*q)+q^{p}\textbf{ }mod\textbf{ }(p*q)\]</span></p><p><span class="math display">\[=(p^{q}\textbf{ }mod\textbf{ }p+p^{q}\textbf{ }mod\textbf{}q)+(q^{p}\textbf{ }mod\textbf{ }p+q^{p}\textbf{ }mod\textbf{ }q)\]</span></p><p><span class="math display">\[=p^{q}\textbf{ }mod\textup{ }q+q^{p}\textup{ }mod\textbf{ }p\]</span></p><p>由费马小定理可知，<span class="math inline">\(a^{p-1}=1\textbf{}mod\textbf{ }p,p是素数\)</span></p><p>所以<span class="math inline">\(p^{q}\textbf{ }mod\textbf{}q=(p^{q-1})*p\textbf{ }mod\textbf{ }q=p\textbf{ }mod\textbf{}q\)</span></p><p>同理可得<span class="math inline">\(q^{p}\textbf{ }mod\textbf{}p=q\textbf{ }mod\textbf{ }p\)</span></p><p>综上，<span class="math inline">\(s = (pow(p, q, n) + pow(q, p,n))\textbf{ } mod\textbf{ } n=p+q\)</span></p><h2 id="爆破4位md5值脚本">爆破4位md5值脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from hashlib import md5</span><br><span class="line">from itertools import product</span><br><span class="line">table=&quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&quot;</span><br><span class="line">tail=&quot;gcwJ&quot;</span><br><span class="line">_hash=&quot;f383dc8fd2157374dc2aec9df83df320&quot;</span><br><span class="line">for i in product(table, repeat=4):</span><br><span class="line">    head = &#x27;&#x27;.join(i)</span><br><span class="line">    t = md5((head + tail).encode()).hexdigest()</span><br><span class="line">    if t == _hash:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure><p>十秒内出结果。</p><h2 id="python的排列组合函数">Python的排列组合函数</h2><p><strong>itertools模块</strong>下提供了一些用于生成排列组合的工具函数。</p><ul><li>product(p, q, …[repeat=1])：用序列p、q、...序列中的元素进行排列（<strong>元素会重复</strong>）。就相当于使用嵌套循环组合。</li><li>permutations(p[,r])：从序列p中取出r个元素的组成<strong>全排列</strong>，组合得到元组作为新迭代器的元素。</li><li>combinations(p,r)：从序列p中取出r个元素组成全组合，<strong>元素不允许重复</strong>，组合得到元组作为新迭代器的元素。</li><li>combinations_with_replacement(p,r)，从序列p中取出r个元素组成全组合，<strong>元素允许重复</strong>，组合得到元组作为新迭代器的元素。</li></ul><p>如下程序示范了上面4个函数的用法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import itertools as it</span><br><span class="line"></span><br><span class="line"># 使用两个序列进行排列组合</span><br><span class="line">for e in it.product(&#x27;AB&#x27;, &#x27;CD&#x27;):</span><br><span class="line">    print(&#x27;&#x27;.join(e), end=&#x27;, &#x27;) # AC, AD, BC, BD,</span><br><span class="line">print(&#x27;\n---------&#x27;)</span><br><span class="line"># 使用一个序列、重复2次进行全排列</span><br><span class="line">for e in it.product(&#x27;AB&#x27;, repeat=2):</span><br><span class="line">    print(&#x27;&#x27;.join(e), end=&#x27;, &#x27;) # AA, AB, BA, BB,</span><br><span class="line">print(&#x27;\n---------&#x27;)</span><br><span class="line"># 从序列中取2个元素进行排列</span><br><span class="line">for e in it.permutations(&#x27;ABCD&#x27;, 2):</span><br><span class="line">    print(&#x27;&#x27;.join(e), end=&#x27;, &#x27;) # AB, AC, AD, BA, BC, BD, CA, CB, CD, DA, DB, DC,</span><br><span class="line">print(&#x27;\n---------&#x27;)</span><br><span class="line"># 从序列中取2个元素进行组合、元素不允许重复</span><br><span class="line">for e in it.combinations(&#x27;ABCD&#x27;, 2):</span><br><span class="line">    print(&#x27;&#x27;.join(e), end=&#x27;, &#x27;) # AB, AC, AD, BC, BD, CD,</span><br><span class="line">print(&#x27;\n---------&#x27;)</span><br><span class="line"># 从序列中取2个元素进行组合、元素允许重复</span><br><span class="line">for e in it.combinations_with_replacement(&#x27;ABCD&#x27;, 2):</span><br><span class="line">    print(&#x27;&#x27;.join(e), end=&#x27;, &#x27;) # AA, AB, AC, AD, BB, BC, BD, CC, CD, DD,</span><br></pre></td></tr></table></figure><p>上面程序用到了一个字符串的join()方法，该方法用于将元组的所有元素都连接成一个字符串。</p><h2 id="rsa中已知phi和n分解n">RSA中已知phi和n分解n</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from math import gcd</span><br><span class="line">from math import isqrt</span><br><span class="line">from random import randrange</span><br><span class="line">from gmpy2 import is_prime</span><br><span class="line"># from sage.all import is_prime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def factorize(N, phi):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    如果欧拉系数已知，则从模中恢复素因数。</span><br><span class="line">    此方法仅适用于由 2 个素数组成的模！</span><br><span class="line">    :param N: 模数</span><br><span class="line">    :param phi: 欧拉 totient，乘法群模 N 的阶数</span><br><span class="line">    :return: 包含素因数的元组，如果未找到因数则返回 None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    s = N + 1 - phi       # p+q</span><br><span class="line">    d = s ** 2 - 4 * N    # （p-q)^2</span><br><span class="line">    p = int(s - isqrt(d)) // 2</span><br><span class="line">    q = int(s + isqrt(d)) // 2</span><br><span class="line">    return p, q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def factorize_multi_prime(N, phi):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Recovers the prime factors from a modulus if Euler&#x27;s totient is known.</span><br><span class="line">    This method works for a modulus consisting of any number of primes, but is considerably be slower than factorize.</span><br><span class="line">    More information: Hinek M. J., Low M. K., Teske E., &quot;On Some Attacks on Multi-prime RSA&quot; (Section 3)</span><br><span class="line">    :param N: the modulus</span><br><span class="line">    :param phi: Euler&#x27;s totient, the order of the multiplicative group modulo N</span><br><span class="line">    :return: a tuple containing the prime factors</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    prime_factors = set()</span><br><span class="line">    factors = [N]</span><br><span class="line">    while len(factors) &gt; 0:</span><br><span class="line">        # Element to factorize.</span><br><span class="line">        N = factors[0]</span><br><span class="line"></span><br><span class="line">        w = randrange(2, N - 1)</span><br><span class="line">        i = 1</span><br><span class="line">        while phi % (2 ** i) == 0:</span><br><span class="line">            sqrt_1 = pow(w, phi // (2 ** i), N)  </span><br><span class="line">            if sqrt_1 &gt; 1 and sqrt_1 != N - 1:      # 计算非平凡平方根</span><br><span class="line">                # We can remove the element to factorize now, because we have a factorization.</span><br><span class="line">                factors = factors[1:]</span><br><span class="line"></span><br><span class="line">                p = gcd(N, sqrt_1 + 1)</span><br><span class="line">                q = N // p</span><br><span class="line"></span><br><span class="line">                if is_prime(p):</span><br><span class="line">                    prime_factors.add(p)</span><br><span class="line">                elif p &gt; 1:</span><br><span class="line">                    factors.append(p)</span><br><span class="line"></span><br><span class="line">                if is_prime(q):</span><br><span class="line">                    prime_factors.add(q)</span><br><span class="line">                elif q &gt; 1:</span><br><span class="line">                    factors.append(q)</span><br><span class="line"></span><br><span class="line">                # Continue in the outer loop</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            i += 1</span><br><span class="line"></span><br><span class="line">    return tuple(prime_factors)</span><br><span class="line">    </span><br><span class="line">N = </span><br><span class="line">phi = </span><br><span class="line">prime = factorize_multi_prime(N,phi)</span><br><span class="line">print(prime)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格的初探</title>
      <link href="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/"/>
      <url>/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="格的定义">格的定义</h2><p>任何一组<strong>线性无关</strong>的向量所生成的<strong>系数为整数</strong>的<strong>向量集合</strong>称为格。</p><p>即<br><span class="math display">\[L=\begin{Bmatrix} a_{1}\nu _{1}+a_{2}\nu  _{2}+...+a_{n}\nu_{n},&amp;a_{1},a_{2},...,a_{n}\in Z \end{Bmatrix}\]</span> 这一组线性无关的向量<span class="math inline">\(v_{1},v_{2},...,v_{n}\)</span>就是格<span class="math inline">\(L\)</span>的基。格<span class="math inline">\(L\)</span>的元素是<span class="math inline">\(v_{1},v_{2},...,v_{n}\)</span>的整系数线性组合。某种程度上，格可以理解为<strong>系数为整数的向量空间。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Harry0597/Imag@master/uPic/image-20221115221257017.png"></p><h2 id="格基变换">格基变换</h2><p>格的基是一组<strong>线性无关的向量</strong>，由这一组向量可以生成完整的格。也就是可以由它们线性组合构成所有的格点。基所包含的<strong>向量个数</strong>成为格的<strong>维度</strong>。通常，<strong>一个格可以有多组基</strong>，也就是说，不同的基可能生成同一个格。</p><p><img src="https://cdn.jsdelivr.net/gh/Harry0597/Imag@master/uPic/image-20221130231915760.png"></p><p>那么如何判断两组格基可以生成同一个格？</p><p>如果把格基用矩阵表示（列向量为每一个基），则对格基做以下操作，对应的格不变：</p><p>1.列向量交换：<span class="math inline">\(v_{i}\leftrightarrowv_{j}\)</span></p><p>2.向量取负：<span class="math inline">\(v_{i}\leftrightarrow-v_{i}\)</span></p><p>3.给一个向量加上k乘另一个向量：<span class="math inline">\(v_{i}\leftrightarrow v_{i}+k*v_{j}\)</span></p><p>更加有趣的是，上述操作均对应为<strong>给格基矩阵右乘一个幺模矩阵</strong>，幺模矩阵是一种特殊矩阵，其为<strong>整数矩阵</strong>，其行列式的值为<strong>正负1</strong>，且这种矩阵的乘法具有封闭性，幺模矩阵的乘积仍为幺模矩阵。</p><p><strong>定理：两个格基等价，当且仅当可以把两格基写成以下格式：</strong><span class="math display">\[B_{2}=B_{1}U\]</span> 其中，<span class="math inline">\(U\)</span>是一个幺模矩阵。</p><p>假定<span class="math inline">\(v_{1},v_{2},...,v_{n}\)</span>是格的一组基，<span class="math inline">\(w_{1},w_{2},...,w{n}\inL\)</span>，则必然存在整系数<span class="math inline">\(a_{ij}\)</span>使得 <span class="math display">\[\left\{\begin{matrix}w_{1} =a_{11}v_{1}+a_{12}v_{2}+...+a_{1n}v_{n}\\w_{2}=a_{21}v_{1}+a_{22}v_{2}+...+a_{2n}v_{n}\\...\\w_{n}=a_{n1}v_{1}+a_{n2}v_{2}+...+a_{nn}v_{n}\end{matrix}\right.\]</span>这样，格的问题，我们就可以<strong>转化为矩阵运算</strong>了。</p><h2 id="格的基本域">格的基本域</h2><h3 id="什么是基本域">什么是基本域</h3><p><img src="https://www.ruanx.net/content/images/2021/01/image.png"></p><p>几何上，基本域就是<strong>这组基围出的区域</strong>，如上图中的阴影部分。</p><h3 id="基本域的性质">基本域的性质</h3><p>一个 lattice会有不同的基，也就会有不同的基本域，但<strong>每个基本域的体积(无论什么形状的)都一样</strong>。</p><h3 id="基本域的应用">基本域的应用</h3><p>另外，我们还可以将空间中的点映射到基本域上，判断<strong>点是否在格上</strong>。</p><p>基本域的表示方法：</p><p>​<br><span class="math display">\[P(B)=a_{1}v_{1}+a_{2}v_{2}+...+a_{n}v_{n},a_{i}\in [0,1)\]</span></p><p>现在假设空间中有一个点，表示为</p><p>​<br><span class="math display">\[x=a_{1}v_{1}+a_{2}v_{2}+...+a_{n}v_{n}\]</span> 那么当对这个点在基本域范围内做模运算时，只需把每个系数<span class="math inline">\(a_{i}\)</span>模1乘上基向量即可。</p><p>​<br><span class="math display">\[x\textbf{ }mod\textbf{ }P(B)=(a_{1}\textbf{ }mod\textbf{}1)*v_{1}+(a_{2}\textbf{ }mod\textbf{ }1)*v_{2}+...+(a_{n}\textbf{}mod\textbf{ }1)*v_{n}\]</span> 这样就把这个点映射到基本域上了。</p><h2 id="行列式协体积">行列式（协体积）</h2><p>格的行列式是<strong>基向量构成的多面体的体积</strong>（标量），也就是基本域的体积。前面说过格的每个基本域的体积是相等的，所以<strong>行列式是格的固有属性</strong>，同一个格选取的不同组基，行列式是相等的。</p><p>前面也讲过格基变换，两组基要生成同一个格，当且仅当两者可以乘一个幺模矩阵进行相互转化，即</p><p>​<br><span class="math display">\[|det(BU)|=|det(B)det(U)|=|det(B)|\]</span>需要注意的是，<strong>行列式可以用来衡量格密度的大小，若行列式越大，格密度越小</strong>。</p><p>再来看一下<strong>协体积的上限</strong>。 若构成 lattice的基向量长度固定，要想得到<strong>最大的协体积</strong>，必然各个基向量都要是<strong>正交</strong>的（类比，长度相同的四条线段要围成平行四边形，当且仅当是正方形是面积最大），于是我们就得到了协体积的上限:</p><p>​<br><span class="math display">\[设L是一个格，F是L的一个基本域，任取一组基向量V_{1},v_{2},..,v_{n}，\\那                             么|det(L)|=Vol(F)\leqslant||v_{1}||*||v_{2}||*...*||v_{n}||\]</span><strong>基向量的各个向量越趋近于正交，行列式越接近上限，当是正交时，上面不等式取到等号</strong>。</p><h2 id="格的困难问题">格的困难问题</h2><h3 id="svpthe-shortest-vector-problem">SVP(The shortest vectorproblem)</h3><p>最短向量问题:找到格中的最短向量，也就是在格中找到一个非零向量<span class="math inline">\(v\in L\)</span>使得<span class="math inline">\(||v||\)</span>最小。</p><h4 id="svp的上限">SVP的上限</h4><p>一个格的最短非零向量到底有多短呢？这其实是<strong>和格的维度以及行列式有关</strong>。</p><p>根据Hermite定理， 有</p><p>​<br><span class="math display">\[\lambda (\Lambda )\leqslant \sqrt{n}*\sqrt[n]{det(\Lambda )}\]</span> ​</p><p>其中，<span class="math inline">\(\Lambda\)</span>是格基矩阵，<span class="math inline">\(\lambda (\Lambda )\)</span>是格中最短向量，<span class="math inline">\(det()\)</span>是行列式</p><h3 id="cvpthe-closest-vector-problem">CVP(<strong>The Closest VectorProblem</strong>)</h3><p>最近向量问题：给定格外的一个点，找到格中离它最近或近似最近的格点。CVP一般要比SVP困难的多，<strong>SVP可以规约到CVP</strong>。</p><h2 id="lll算法格基规约">LLL算法(格基规约)</h2><p>在1982年，A.K.Lenstra，H.W.Lenstra,Jr 和 L.lovasz 提出一种解决 SVP问题的算法，通常称之为<span class="math inline">\(LLL\)</span>算法，它是一种<strong>格基规约算法</strong>。</p><p>在求解 SVI的问题时，最先想到的是对格基进行多种线性组合的尝试，其中最难的问题是如何<strong>基向量变小</strong>，<strong>使基向量最大程度的趋于正交化。</strong></p><p><img src="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img1.png"></p><p>需要 Gram-Schmidt(施密特) 正交化知识的铺垫。</p><h3 id="gram-schmidt施密特-正交化">Gram-Schmidt(施密特) 正交化</h3><p><span class="math display">\[如果x_{1},x_{2},...,x_{n}是某向量空间中的基，那么可通过下列做法找到该向量空间中的n个两两正交的向量\\v_{1},v_{2},...,v_{n},称为施密特正交化。v_{1},v_{2},...,v_{n}就是该向量空间中的一组正交基。\]</span></p><figure><img src="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>现在我们对探讨如何寻找二维空间的正交基。</p><p>下图是二维空间<span class="math inline">\(R^{n}\)</span>的一组基</p><p><img src="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img3.png"></p><p>只要将其中一个向量对另外一个向量进行投影，就可以得到<span class="math inline">\(R^{n}\)</span> 的一组正交基：</p><p><img src="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img4.gif"></p><p>下面我们来进行代数推导，假设基为<span class="math inline">\(x_{1},x_{2}\)</span>，选择<span class="math inline">\(x_{1}\)</span>作为<span class="math inline">\(v_{1}\)</span>,作出<span class="math inline">\(x_{2}\)</span>在<span class="math inline">\(v_{1}\)</span>所在直线上的投影<span class="math inline">\(\vec{x_{2}}\)</span>,连接<span class="math inline">\(x_{2},\vec{x_{2}}\)</span>所得到垂线就是<span class="math inline">\(v_{2}\)</span></p><p><img src="/2023/08/21/%E6%A0%BC%E7%9A%84%E5%88%9D%E6%8E%A2/img4.png"> <span class="math display">\[\left\{\begin{matrix}v_{1} =x_{2}\\v_{2}=x_{2}-\vec{x_{2}}\end{matrix}\right.\Rightarrow \left\{\begin{matrix}v_{1} =x_{2}\\v_{2}=v_{1}-\vec{kv_{1}}\end{matrix}\right.\]</span></p><p><span class="math display">\[由v_{1}v_{2}=0得v_{1}*(v_{1}-kv_{2})=0\Rightarrowk=\frac{v_{2}v_{1}}{v_{1}v_{1}}\]</span></p><p><span class="math display">\[\therefore该向量空间的一组正交基为 \left\{\begin{matrix}v_{1}=x_{1}\\v_{2}=v_{1}-\frac{v_{2}v_{1}}{v_{1}v_{1}}\end{matrix}\right.\]</span></p><p>这样就可以推广到<span class="math inline">\(n\)</span>维向量空间施密特正交化了。</p><h3 id="格基规约的条件">格基规约的条件</h3><p><span class="math inline">\(LLL\)</span>格基规约需要满足以下两个条件： <span class="math display">\[{\forall}1\leq i\leqslant n,j&lt; i,|u_{i,j}|\leq \frac{1}{2}\]</span></p><p><span class="math display">\[{\forall}1\leq i&lt; n,\delta ||b_{i}||^{2}\leqslant||u_{i+1,i}b_{i}+b_{i+1}||^2\]</span></p><p><span class="math inline">\(LLL\)</span>算法最终输出的基称为<span class="math inline">\(LLL\)</span>约化基。</p><h3 id="格基约化的性质">格基约化的性质</h3><p>1、<span class="math inline">\(\delta=\frac{3}{4}\)</span>是该算法的一个特例，<span class="math inline">\(LLL\)</span>算法成立的前提是<span class="math inline">\(\frac{1}{4}&lt; \delta&lt; 1\)</span>.</p><p>2、根据格约化基的定义得， <span class="math display">\[\delta ||b_{i}||^{2}\leqslant||u_{i+1,i}b_{i}+b_{i+1}||^2=u_{i+1,i}^2||b_{i}||^2+||b_{i+1}||^2\]</span></p><p><span class="math display">\[\therefore ||b_{i+1}||^2\geq (\delta -u_{i+1,i}^2)||b_{i}||^2=(\delta-\frac{1}{4})||b_{i}||^2\]</span></p><p>所以<span class="math inline">\(b_{i+1}\)</span>不会比<span class="math inline">\(b_{i}\)</span>短太多。</p><h2 id="例题">例题</h2><p>例题来自 NSSCTF 平台。之前看了格密码理论和做题联系不起来，看了DexterJie 师傅的博客后受益匪浅。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p = getPrime(1024)</span><br><span class="line"></span><br><span class="line">f = getPrime(400)</span><br><span class="line">g = getPrime(512)</span><br><span class="line">r = getPrime(400)</span><br><span class="line"></span><br><span class="line">h = inverse(f, p) * g % p</span><br><span class="line"></span><br><span class="line">m = b&#x27;******&#x27;</span><br><span class="line">m = bytes_to_long(m)</span><br><span class="line"></span><br><span class="line">c = (r*h + m) % p</span><br><span class="line"></span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line">print(f&#x27;h = &#123;h&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p = 170990541130074930801165526479429022133700799973347532191727614846803741888876816210632483231997413973919037199883422312436314365293577997262903161076615619596783971730864586404602951191341733308807254112018161897113881363794353050758324742415299277578203838160939521046655099610387485947145087271531951477031</span><br><span class="line">h = 19027613518333504891337723135627869008620752060390603647368919831595397216728378486716291001290575802095059192000315493444659485043387076261350378464749849058547797538347059869865169867814094180939070464336693973680444770599657132264558273692580535803622882040948521678860110391309880528478220088107038861065</span><br><span class="line">c = 75639016590286995205676932417759002029770539425113355588948888258962338419567264292295302442895077764630601149285564849867773180066274580635377957966186472159256462169691456995594496690536094824570820527164224000505303071962872595619159691416247971024761571538057932032549611221598273371855762399417419551483</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>先根据题目进行一下公式推导，已知：</p>加密： <span class="math display">\[h=f^{-1}*g\textbf{ }mod \textbf{ }p\Rightarrowg=k*p+h*f\\c=(rh+m)\textbf{ }mod\textbf{ }p\Rightarrow(r*f^{-1}*g+m)\textbf{ }mod\textbf{ }p\]</span> 解密： <span class="math display">\[f*c=(r*g+m*f)\textbf{ }mod\textbf{ }p\\\Rightarrow m*f=(f*c-r*g)\textbf{}mod \textbf{ }p\\\Rightarrow m*f=((f*c)\textbf{ }mod\textbf{}p)mod\textbf{ }g\\\Rightarrow m=((f*c\textbf{ }mod\textbf{}p)*f^{-1})mod\textbf{ }g\]</span> 所以要求 <span class="math inline">\(m\)</span>,我们必须得先求出 <span class="math inline">\(f\)</span>。<span class="math inline">\(p,h,c\)</span>是已知的，我们根据$g=k<em>p+h</em>f$构造出格： $$<span class="math display">\[\begin{bmatrix}k,f\end{bmatrix}\begin{bmatrix}p,0\\h,1\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}g,f\end{bmatrix}\]</span><p>$$ 在这里，我们相当于用<span class="math inline">\(LLL\)</span>算法对<span class="math inline">\((p,0),(h,1)\)</span>这一组基进行格基约化，使这组基变成施密特正交化程度最大的一组基，这样我们就可以求解<span class="math inline">\(SVP\)</span>问题了。也就是说，向量<span class="math inline">\((g,f)\)</span>是最短向量。我们来证明一下：</p><p>我们知道最短向量的上限与格的维度和行列式有关： <span class="math display">\[\lambda (\Lambda )\leqslant \sqrt{n}*\sqrt[n]{det(\Lambda )}\]</span> 所以，对于格<span class="math inline">\(L\)</span><span class="math inline">\(\bigl(\begin{smallmatrix} p,0 \\ h,1\end{smallmatrix}\bigr)\)</span>,<span class="math inline">\(\lambda(L)\leqslant\sqrt{2p}\)</span></p><p>我们来计算一下，<span class="math inline">\(p\)</span> 是 <span class="math inline">\(1024 bit\)</span>,<span class="math inline">\(g\)</span>是 <span class="math inline">\(512bit\)</span>,<span class="math inline">\(f\)</span>是 <span class="math inline">\(400bit\)</span>, <span class="math display">\[||(g,f)||=\sqrt{1024+800}=\sqrt{1824})\leqslant\sqrt{2048}\]</span> 是满足的，所以说<span class="math inline">\((g,f)\)</span>是最短向量是正确的。</p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p = 170990541130074930801165526479429022133700799973347532191727614846803741888876816210632483231997413973919037199883422312436314365293577997262903161076615619596783971730864586404602951191341733308807254112018161897113881363794353050758324742415299277578203838160939521046655099610387485947145087271531951477031</span><br><span class="line">h = 19027613518333504891337723135627869008620752060390603647368919831595397216728378486716291001290575802095059192000315493444659485043387076261350378464749849058547797538347059869865169867814094180939070464336693973680444770599657132264558273692580535803622882040948521678860110391309880528478220088107038861065</span><br><span class="line">c = 75639016590286995205676932417759002029770539425113355588948888258962338419567264292295302442895077764630601149285564849867773180066274580635377957966186472159256462169691456995594496690536094824570820527164224000505303071962872595619159691416247971024761571538057932032549611221598273371855762399417419551483</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mat = [[h,1],[p,0]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">g,f = M.LLL()[0]</span><br><span class="line"></span><br><span class="line">m = (f * c %p* invert(f,g)) %g</span><br><span class="line">flag = long_to_bytes(int(m))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>最后附上参考文章：</p><p><a href="https://www.ruanx.net/lattice-2/">格密码笔记（二）(ruanx.net)</a></p><p><a href="https://www.zimablue.life/2022/05/04/Lattice-Lesson0/">Lattice-Lesson0| ZimaBlue's Blog</a></p><p><a href="%5B初识格%20%7C%20DexterJie&#39;Blog%5D(https://dexterjie.github.io/2023/07/28/初识格/#LLL算法)">初识格-LLL算法(DexterJie'Blog)</a></p><p><a href="https://blog.csdn.net/forest_LL/article/details/123733641">格密码LLL算法：如何解决最短向量SVP问题（1）</a></p><p><a href="https://blog.csdn.net/ccnt_2012/article/details/124866094">如何通俗地理解施密特正交化</a></p>]]></content>
      
      
      <categories>
          
          <category> 格密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔一</title>
      <link href="/2023/08/13/%E9%9A%8F%E7%AC%94%E4%B8%80/"/>
      <url>/2023/08/13/%E9%9A%8F%E7%AC%94%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一同余式求模数">一、同余式求模数</h2><p>已知 a % flag = (a%p)，且 a 、(a%p)以及 flag 的格式已知，a是一个素数，求 flag.</p><p>令 t = (a%p),有 <span class="math display">\[a \equiv t \textbf{ }mod\textbf{ }flag\Rightarrow a= k*flag+t\]</span></p><p><span class="math display">\[\Rightarrow k*flag=a-t\]</span> 所以 k*flag 我们是知道的，问题是我们如何才能求出 flag 呢？</p><p>这里我们可以将 k*flag 分解成多个素因子的乘积，而flag必定是其中几个素因子的乘积。可以将分解出来的各个素因子进行排列组合，求出每一种可能的乘积，找出符合flag 格式的那一种可能就行。</p><h2 id="二rsa中已知-kphi">二、RSA中已知 k*phi</h2><p>已知 <span class="math display">\[n = p*q*r,hint = p*s*q - p*s -q*s+s,且r也已知\]</span></p><p>可以得到， <span class="math display">\[n_{1}=n/(p*q),hint=s*(p*q-p-q+1)=s*phi\]</span> 这个 phi 是 n1 的欧拉函数，就可以用 s*phi 代替 phi进行求解。</p><p>推导一下， <span class="math display">\[m\equiv c^{d}\textbf{ }mod \textbf{ }n\Rightarrow m\equiv(m^{e})^{d}\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[\because e*d\equiv 1\textbf{ }mod\textbf{ }k*phi\Rightarrowe*d=k_{1}*k*phi+1\]</span></p><p><span class="math display">\[\therefore m\equiv m^{k_{1}*k*phi+1}\textbf{ }mod\textbf{ }n\Rightarrowm\equiv m^{k_{1}*k*phi}*m\textbf{ }mod\textbf{ }n\]</span></p><p>又由费马小定理可知， <span class="math display">\[m^{\varphi (n)}\equiv 1\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[\therefore m\equiv 1*m\textbf{ }mod\textbf{ }n\]</span></p><p>综上，用 k*phi 代替 phi 进行求解是可行的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCG入门</title>
      <link href="/2023/08/10/LCG%E5%85%A5%E9%97%A8/"/>
      <url>/2023/08/10/LCG%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="lcg线性同余生成器">LCG(线性同余生成器)</h2><p>LCG属于PRNG(伪随机数生成器)和streamcipher(流密码)的一种，是一种产生伪随机数的方法。 <span class="math display">\[X_{n+1}=(a*X_{n}+b)\textbf{ }mod\textbf{ }m\]</span>其中，Xn代表第n个生成的随机数，X0被称为种子值。这里还定义了三个整数：a乘数、b增量、m模数，是产生器设定的常数。</p><h2 id="参数选择">参数选择</h2><p>LCG的性质与参数的选择密切相关，不同的参数可能导致不同的随机序列。一般按照如下要求选择参数：</p><p>1、m是随机序列的模数，必须一个大于0的正整数。一般是一个比较大的素数或者是2的幂，以便提供较长的周期长度。</p><p>2、a是乘数，必须是一个与m互素的正整数。</p><p>3、b是增量，也必须是一个与m互素的正整数。</p><h2 id="常用公式">常用公式</h2><h3 id="公式一由xn1反推xn">公式一：由Xn+1反推Xn</h3><p><span class="math display">\[X_{n}=((X_{n+1}-b)*a^{-1})\textbf{ }mod\textbf{ }m，这里a^{-1}是模逆元\]</span></p><h3 id="公式二求a">公式二：求a</h3><p><span class="math display">\[\left\{\begin{matrix}X_{n+1} &amp; = &amp;(a*X_{n}+b)  &amp;mod  &amp;m \\X_{n} &amp; = &amp;(a*X_{n-1})  &amp; mod &amp;m\end{matrix}\right.\Rightarrowa=((X_{n+1}-X_{n})*(X_{n}-X_{n-1})^{-1}\textup{ })mod\textbf{ }m\]</span></p><h3 id="公式三求b">公式三：求b</h3><p><span class="math display">\[b=(X_{n+1}-a*X_{n})\textbf{ }mod\textbf{ }m\]</span></p><h3 id="公式四求m">公式四：求m</h3><p><span class="math display">\[t_{n}=X_{n+1}-X_{n},t_{n}=(a*X_{n}+b)-(a*X_{n-1}+b)=a(X_{n}-X_{n-1})=a*t_{n-1}\textbf{} mod\textbf{ }m.\]</span></p><p><span class="math display">\[\thereforet_{n+1}t_{n-1}-t_{n}t_{n}=a*a*t_{n-1}*t_{n-1}-a*t_{n-1}*a*t_{n-1}=0\textup{}mod\textup{ }m\]</span></p><p><span class="math display">\[即T_{n}=t_{n+1}t_{n-1}-t_{n}t_{n}是m的倍数，故T_{n}和T_{n-1}的最大公因数即为m\]</span></p><h2 id="常见六种题型">常见六种题型</h2><p><strong><em>LCG_1:a、b、m都知道，此类题相当于由Xn+1反推Xn.</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;lcg.a&#125;&#x27;)</span><br><span class="line">print(f&#x27;b = &#123;lcg.b&#125;&#x27;)</span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 113439939100914101419354202285461590291215238896870692949311811932229780896397</span><br><span class="line">b = 72690056717043801599061138120661051737492950240498432137862769084012701248181</span><br><span class="line">m = 72097313349570386649549374079845053721904511050364850556329251464748004927777</span><br><span class="line">9772191239287471628073298955242262680551177666345371468122081567252276480156</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>有一个问题就是，我们需要反推多少项呢？我们并不知道，因为迭代的次数(getPrime(16))是一个随机数。但是这并不妨碍我们求解flag。因为flag的格式(b'NSSFCT{')我们已经知道，只需要不断反推，直至找到符合格式的flag为止。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">a = 113439939100914101419354202285461590291215238896870692949311811932229780896397</span><br><span class="line">b = 72690056717043801599061138120661051737492950240498432137862769084012701248181</span><br><span class="line">m = 72097313349570386649549374079845053721904511050364850556329251464748004927777</span><br><span class="line">c=9772191239287471628073298955242262680551177666345371468122081567252276480156</span><br><span class="line"></span><br><span class="line"># c=(a*c0+b)%m</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c - b) * a_1 % m</span><br><span class="line">    #print(c)</span><br><span class="line">    flag=libnum.n2s(int(c))</span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_2:不知道b,要先求出b,之后操作就和LCG_1没什么区别了</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;lcg.a&#125;&#x27;)</span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 83968440254358975953360088805517488739689448515913931281582194839594954862517</span><br><span class="line">m = 77161425490597512806099499399561161959645895427463118872087051902811605680317</span><br><span class="line">43959768681328408257423567932475057408934775157371406900460140947365416240650</span><br><span class="line">8052043336238864355872102889254781281466728072798160448260752595038552944808</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">from Crypto.Util.number import isPrime</span><br><span class="line"></span><br><span class="line">a = 83968440254358975953360088805517488739689448515913931281582194839594954862517</span><br><span class="line">m = 77161425490597512806099499399561161959645895427463118872087051902811605680317</span><br><span class="line">c1=43959768681328408257423567932475057408934775157371406900460140947365416240650</span><br><span class="line">c2=8052043336238864355872102889254781281466728072798160448260752595038552944808</span><br><span class="line"></span><br><span class="line">b=(c2-a*c1) % m</span><br><span class="line">#print(b)</span><br><span class="line">#print(gmpy2.gcd(b,m))</span><br><span class="line">a_1 = gmpy2.invert(a,m)</span><br><span class="line">c = c1</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c-b) * a_1 % m</span><br><span class="line">    flag = libnum.n2s(int(c))</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_3:a、b都不知道，先求出a,之后操作同LCG_2</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">m = 96343920769213509183566159649645883498232615147408833719260458991750774595569</span><br><span class="line">10252710164251491500439276567353270040858009893278574805365710282130751735178</span><br><span class="line">45921408119394697679791444870712342819994277665465694974769614615154688489325</span><br><span class="line">27580830484789044454303424960338587428190874764114011948712258959481449527087</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">m = 96343920769213509183566159649645883498232615147408833719260458991750774595569</span><br><span class="line">c1 = 10252710164251491500439276567353270040858009893278574805365710282130751735178</span><br><span class="line">c2 = 45921408119394697679791444870712342819994277665465694974769614615154688489325</span><br><span class="line">c3 = 27580830484789044454303424960338587428190874764114011948712258959481449527087</span><br><span class="line"></span><br><span class="line">a = (c3-c2) * gmpy2.invert(c2-c1,m) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line">a_1 = gmpy2.invert(a,m)</span><br><span class="line">b = (c2-a*c1) % m</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">c = c1</span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c-b) * a_1 % m</span><br><span class="line">    flag = libnum.n2s(int(c))</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_4：a、b、m都不知道，给出多组输出，让我们恢复初始种子。</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">47513456973995038401745402734715062697203139056061145149400619356555247755807</span><br><span class="line">57250853157569177664354712595458385047274531304709190064872568447414717938749</span><br><span class="line">30083421760501477670128918578491346192479634327952674530130693136467154794135</span><br><span class="line">38739029019071698539301566649413274114468266283936163804522278316663267625091</span><br><span class="line">42506270962409723585330663340839465445484970240895653869393419413017237427900</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>首先，我们要先求出m，才能LCG_3的操作。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c=[47513456973995038401745402734715062697203139056061145149400619356555247755807,</span><br><span class="line">   57250853157569177664354712595458385047274531304709190064872568447414717938749,</span><br><span class="line">   30083421760501477670128918578491346192479634327952674530130693136467154794135,</span><br><span class="line">   38739029019071698539301566649413274114468266283936163804522278316663267625091,</span><br><span class="line">   42506270962409723585330663340839465445484970240895653869393419413017237427900]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line"># print(isPrime(m))       False</span><br><span class="line"></span><br><span class="line">m//=2</span><br><span class="line"># print(isPrime(m))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>这里需要解释一下代码中为什么要进行 m//=2这样的操作？</em></strong></p><p><strong><em>我们虽然得到了m的倍数，通过求解 GCD 也确实能得到m。但是在数据不够多的情况下，我们可能得到的是 k</em>m(不信的话，你可以输出一下 isPrime(m) 发现 m 确实不是素数),这时就需要我们遍历一些小数，手动去除 k 。</strong>*</p><p><strong><em>LCG_5:本题给出信息和LCG_4一样需要我们恢复参数。</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = self.a * (self.seed - self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">57648351648792284446777383544515312078150027665462203747924668509833442797796</span><br><span class="line">90378879763416486117626477831653213918315023665514305359005153448529276829825</span><br><span class="line">21826576702665114807208181233864324586557058567478767825970403161758214940301</span><br><span class="line">47594460970742467761038407996122637655856234121180714918606854365482948918701</span><br><span class="line">11871076497267630136796123094001159466754095580273018347962555675375123133730</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>需要注意的是，这里所给的LCG递归式是</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.seed = self.a * (self.seed - self.b) % self.m</span><br></pre></td></tr></table></figure><p><strong><em>我们只需要把 -ab 看成一个整体，这样我们就可以转化为标准式ax+b 的形式。因为这里我们只需要恢复初始种子m，所以代码和LCG_4没什么区别。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c=[57648351648792284446777383544515312078150027665462203747924668509833442797796,</span><br><span class="line">   90378879763416486117626477831653213918315023665514305359005153448529276829825,</span><br><span class="line">   21826576702665114807208181233864324586557058567478767825970403161758214940301,</span><br><span class="line">   47594460970742467761038407996122637655856234121180714918606854365482948918701,</span><br><span class="line">   11871076497267630136796123094001159466754095580273018347962555675375123133730]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line">print(isPrime(m))   # False m的倍数</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">for i in range(1,100):</span><br><span class="line">    if isPrime(m//i):</span><br><span class="line">        print(i)   # i是4</span><br><span class="line">        m//=i</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_6:同样需要恢复参数</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(255), getPrime(255), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br></pre></td></tr></table></figure><p><strong><em>这里进行了两次加密，我们得到的并不是连续的输出，而是隔位输出，比如是X2,X4,X6,X8,X10</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">self.seed = (self.a * self.seed + self.b) % self.m</span><br></pre></td></tr></table></figure><p>首先要恢复模数 m， <span class="math display">\[\left\{\begin{matrix}X_{2} &amp;=  &amp;(a*X_{1}+b) &amp;mod  &amp;m \\X_{4}&amp; = &amp; (aX_{3}+b) &amp;mod  &amp;m\end{matrix}\right.\Rightarrow (X_{4}-X_{2})=a(X_{3}-X_{1})\textbf{}mod\textbf{ }m\]</span> 依然可以构造消去增量 b构造等比数列，所以我们依然可以用之前的方法求 m 。</p><p>接下来就是求 a， <span class="math display">\[(X_{4}-X_{2})=a(X_{3}-X_{1})\textbf{ }mod\textbf{}m=a((aX_{2}+b)-(aX_{0}+b))\textbf{ }mod\textbf{}m=a^{2}(X_{2}-X_{0})\textbf{ }mod\textbf{ }m\]</span> 那么，这个平方我们该如何处理呢？我们看Xenny师傅 怎么解决。</p><figure><img src="/2023/08/10/LCG%E5%85%A5%E9%97%A8/P6.png" alt="P6"><figcaption aria-hidden="true">P6</figcaption></figure><p>这个方法我也还是一知半解(AMM算法也不是很明白)。这里，讲一下我的做法。前面已经说过，本题进行了两轮加密，所给输出是间隔的。<span class="math display">\[X_{n+1}=(aX_{n}+b)\textbf{ }mod\textbf{ }m=(a(aX_{n-1}+b)+b)\textbf{}mod\textbf{ }m\]</span> 可以把 a**2 看作 a,把 (a+1)b 看成b，这样就相当于重新构造了一个LCG。</p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c = [25445927935559969212648839062255651208014967526951331344342413906051118248013,</span><br><span class="line">81572970970116732975667604095930675262596098540738447440566868976253289440293,</span><br><span class="line">6956793925625110803779114150160476498676179542815207353218944386232051429289,</span><br><span class="line">88042506866508011592456777776490262927213783361334741921985316105965255450508,</span><br><span class="line">5652832125321707726481846809536180176877263519327268361130605456255558285092]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line"># print(isPrime(m))   # true</span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m             # 把(a+1)*b当成b就可以了</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>最后附上我参考的文章：</p><p><a href="https://blog.csdn.net/superprintf/article/details/108964563">ctf之lcg算法</a></p><p><a href="https://blog.csdn.net/weixin_45883223/article/details/115299389">LCG(线性同余生成器)</a></p>]]></content>
      
      
      <categories>
          
          <category> 流密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023DASCTF七月挑战赛复现</title>
      <link href="/2023/08/03/2023DASCTF%E4%B8%83%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/08/03/2023DASCTF%E4%B8%83%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="ezdhke">EzDHKE</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from hashlib import sha256</span><br><span class="line">from random import randbytes, getrandbits</span><br><span class="line">from flag import flag</span><br><span class="line">def diffie_hellman(g, p, flag):</span><br><span class="line">    alice = getrandbits(1024)</span><br><span class="line">    bob = getrandbits(1024)</span><br><span class="line">    alice_c = pow(g, alice, p)</span><br><span class="line">    bob_c = pow(g, bob, p)</span><br><span class="line">    print(alice_c , bob_c)</span><br><span class="line">    key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br><span class="line"></span><br><span class="line">    iv = b&quot;dasctfdasctfdasc&quot;</span><br><span class="line"></span><br><span class="line">    aes = AES.new(key, AES.MODE_CBC, iv)  </span><br><span class="line">    </span><br><span class="line">    enc = aes.encrypt(flag)</span><br><span class="line">    print(enc)</span><br><span class="line"></span><br><span class="line">def getp():</span><br><span class="line">    p = int(input(&quot;P = &quot;))</span><br><span class="line">    assert isPrime(p)</span><br><span class="line">    assert p.bit_length() &gt;= 1024 and p.bit_length() &lt;= 2048</span><br><span class="line">    g = 2</span><br><span class="line">    diffie_hellman(g, p, flag)</span><br><span class="line"></span><br><span class="line">getp()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br></pre></td></tr></table></figure><p>获取 Bob 发送的值( bob_c)，将其提高到 Alice 私钥的幂，然后取模p。</p><p>然后将生成的长整数转换为字节并使用 SHA-256进行哈希处理，哈希运算的结果作为字节字符串返回。</p><p>最终结果作为 Alice 和 Bob 的共享密钥。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iv = b&quot;dasctfdasctfdasc&quot;</span><br></pre></td></tr></table></figure><p>AES的CBC模式（分组密码链接模式）设置初始化向量(IV)。</p><p>IV 是一个随机数，用作密文的第一个块。这是必要的，因为 AES是分组密码，而分组密码需要初始化向量来启动加密过程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)  #创建一个新的 AES 对象</span><br></pre></td></tr></table></figure><p>密钥、IV 和明文必须都是类似字节的对象。密钥的长度必须为 16、24 或 32字节(128bit,192bit,256bit)， IV 的长度必须为 16 字节（因为 AES 在 16字节的块上运行），明文的长度必须是 16 字节的倍数。 如果明文不是 16字节的倍数，则必须对其进行填充以达到 16 的倍数的大小。</p><p><strong><em>flag被CBC(分组密码链接模式)进行加密，我们已知初始化向量(IV),目的是求key。</em></strong></p><p><strong><em>而key是被DH加密了的，要求key,还需求出alice。</em></strong></p><p><strong><em>get()函数要求我们传入一个1024bit-2048bit的素数p,我们不防传入一个光滑素数，能很快求解</em></strong> <span class="math display">\[Alice_c\equiv g^{alice}\textbf{ }mod\textbf{ }p\]</span> wp:</p><p>生成光滑素数p</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from random import choice</span><br><span class="line">from Crypto.Util.number import isPrime</span><br><span class="line">def myPrime(bits):</span><br><span class="line">    while True:</span><br><span class="line">        n = 2</span><br><span class="line">        while n.bit_length() &lt; bits:</span><br><span class="line">            n *= choice(primes)</span><br><span class="line">        if isPrime(n + 1):</span><br><span class="line">            return n + 1</span><br><span class="line">p = myPrime(1024)</span><br><span class="line">print(p)</span><br><span class="line">#189748605665158082111275872557704333522039726199999895031706315085902660337411854647983122666062556936534670800160523701824801162274106958140146326402455411620555437280926462736018015567166363230091558715628717720419196163767507352475201252315824517036725244214039625995753473481520129898146252693266565762094927</span><br></pre></td></tr></table></figure><p>求解alice</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 环境：sage</span><br><span class="line"># Baby-step Giant-step法</span><br><span class="line">def babystep_giantstep(g, y, p, q=None):</span><br><span class="line">    if q is None:</span><br><span class="line">        q = p - 1</span><br><span class="line">    m = int(q**0.5 + 0.5)</span><br><span class="line">    # Baby step</span><br><span class="line">    table = &#123;&#125;</span><br><span class="line">    gr = 1  # g^r</span><br><span class="line">    for r in range(m):</span><br><span class="line">        table[gr] = r</span><br><span class="line">        gr = (gr * g) % p</span><br><span class="line">    # Giant step</span><br><span class="line">    try:</span><br><span class="line">        gm = pow(g, -m, p)  # gm = g^&#123;-m&#125;</span><br><span class="line">    except:</span><br><span class="line">        return None</span><br><span class="line">    ygqm = y                # ygqm = y * g^&#123;-qm&#125;</span><br><span class="line">    for q in range(m):</span><br><span class="line">        if ygqm in table:</span><br><span class="line">            return q * m + table[ygqm]</span><br><span class="line">        ygqm = (ygqm * gm) % p</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"># Pohlig–Hellman法</span><br><span class="line">def pohlig_hellman_DLP(g, y, p):</span><br><span class="line">    crt_moduli = []</span><br><span class="line">    crt_remain = []</span><br><span class="line">    for q, _ in factor(p-1):</span><br><span class="line">        x = babystep_giantstep(pow(g,(p-1)//q,p), pow(y,(p-1)//q,p), p, q)</span><br><span class="line">        if (x is None) or (x &lt;= 1):</span><br><span class="line">            continue</span><br><span class="line">        crt_moduli.append(q)</span><br><span class="line">        crt_remain.append(x)</span><br><span class="line">    x = crt(crt_remain, crt_moduli)</span><br><span class="line">    return x</span><br><span class="line">    </span><br><span class="line">p = 189748605665158082111275872557704333522039726199999895031706315085902660337411854647983122666062556936534670800160523701824801162274106958140146326402455411620555437280926462736018015567166363230091558715628717720419196163767507352475201252315824517036725244214039625995753473481520129898146252693266565762094927</span><br><span class="line">g=2</span><br><span class="line">y=126335148728121839165214578712616714896068088431242768032099119311672927960066757778886759581732563397664623281291468786455806669506289945000832687256947547715890013891156717873951970575686566623998313033814629227260784874473674493141956695555624444324423123550043331270766000934442345084521173496612684244521817 </span><br><span class="line"></span><br><span class="line">x = pohlig_hellman_DLP(g, y, p)</span><br><span class="line">print(x)</span><br><span class="line">print(pow(g, x, p) == y)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;19725268140486219931273670184627509421886594371218668473170713602614775174554822553913723749247515418643589204928857895458812995617382397101146613792597234401181086237828962337082170640415285598027205377319087246590523359362089919920879645846905409986181936892939004568920963678760604527317649686645891069878</span><br><span class="line">True&#x27;&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后求key,解flag</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alice=19725268140486219931273670184627509421886594371218668473170713602614775174554822553913723749247515418643589204928857895458812995617382397101146613792597234401181086237828962337082170640415285598027205377319087246590523359362089919920879645846905409986181936892939004568920963678760604527317649686645891069878</span><br><span class="line">bob_c=82024715586746697978530132111368994011716076980502454618150572158919032873444387902613386183552926303651710370065737129756192440674145837908673206529875835887003844314561287987895409315122184287323905278866402929779666428512421254584747210553034542812693842282458559568445136236463734031158504503149333460169444</span><br><span class="line"></span><br><span class="line">enc=b&quot;Ky\x91\xf5\n\xe4\x03&#x27;\xa8\xf2c\xd6\x95m\xa7\x8bj\xfb\x03nU\x0e\x95\xd7(\xb9\xa4\xcf\xcbg\xd6gR\xe1m\xef7Q\x151h\x0c\xc6x\xb1\xfcZ^&quot;</span><br><span class="line"></span><br><span class="line">key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br><span class="line">iv = b&quot;dasctfdasctfdasc&quot;</span><br><span class="line"></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">flag = aes.decrypt(enc)</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line"># b&#x27;DASCTF&#123;1c65a8d9-ca95-4217-a98c-b119c6f313b1&#125;</span><br></pre></td></tr></table></figure><h2 id="ezrsa">ezRSA</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import secret, flag</span><br><span class="line">def encrypt(m):</span><br><span class="line">    return pow(m, e, n)</span><br><span class="line">assert flag == b&quot;dasctf&#123;&quot; + secret + b&quot;&#125;&quot;</span><br><span class="line">e = 11</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p * q</span><br><span class="line">P = getPrime(512)</span><br><span class="line">Q = getPrime(512)</span><br><span class="line">N = P * Q</span><br><span class="line">gift = P ^ (Q &gt;&gt; 16)</span><br><span class="line">print(N, gift, pow(n, e, N))</span><br><span class="line">print(encrypt(bytes_to_long(secret)),</span><br><span class="line">    encrypt(bytes_to_long(flag)))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line">a=1418376318449536765352288414795105463017701595274559335835409895217396556048810421351756309867602851654191c1=5855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009 </span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>已知P高16位，可以根据P=gift^Q恢复P,所以要先根据Q=N//P恢复Q。</p><p>wp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line"></span><br><span class="line">pp=bin(gift)[2:18]  # 截取p的高16位</span><br><span class="line">#print(pp)</span><br><span class="line"></span><br><span class="line">gift=bin(gift)[2:][16:]  # 截取gift的剩余位</span><br><span class="line">#print(gift)</span><br><span class="line">k = 512-16</span><br><span class="line"></span><br><span class="line"># 恢复p</span><br><span class="line">x=4</span><br><span class="line">for i in range(k//x):</span><br><span class="line">    PP = int(pp + &#x27;0&#x27;*k,2)  # 已知高位</span><br><span class="line">    #print(PP)</span><br><span class="line">    QQ=bin(N//PP)[2:][i*x:(i+1)*x] # 计算Q高位</span><br><span class="line">    #print(QQ)</span><br><span class="line">    gg = gift[i*x:(i+1)*x]</span><br><span class="line">    #print(gg)</span><br><span class="line">    pb = bin(int(QQ, 2) ^ int(gg, 2))[2:].zfill(x)</span><br><span class="line">    #print(pb)</span><br><span class="line">    pp+=pb</span><br><span class="line">    k-=x</span><br><span class="line">px=int(pp,2)</span><br><span class="line">if N//px:</span><br><span class="line">    p=N//px</span><br><span class="line">    print(p)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line"></span><br><span class="line">#pp=bin(gift)[2:][:16]  # 截取gift的前16位</span><br><span class="line">pp=bin(gift)[2:18]</span><br><span class="line"># print(bin(gift))</span><br><span class="line"># print(pp)</span><br><span class="line">b=512-16</span><br><span class="line"></span><br><span class="line">gift=bin(gift)[2:][16:] # 截取gift剩余的位数</span><br><span class="line">#print(gift)</span><br><span class="line"></span><br><span class="line">x=5</span><br><span class="line">for i in range((512-16)//x):</span><br><span class="line">    PP=int(pp+&#x27;0&#x27;*b,2)  #已知高位</span><br><span class="line">    #print(PP)</span><br><span class="line">    Qb=bin(N//PP)[2:][i*x:x*i+x]  #算出Q的高位,取5</span><br><span class="line">    #print(Qb)</span><br><span class="line">    gb=gift[i*x:i*x+x]</span><br><span class="line">    #print(gb)</span><br><span class="line">    pb=bin(int(gb,2)^int(Qb,2))[2:].zfill(x)</span><br><span class="line">    #print(pb)</span><br><span class="line">    pp+=pb</span><br><span class="line">    #print(pp)</span><br><span class="line">    b-=x</span><br><span class="line">for i in range(3): #还差1位</span><br><span class="line">    px = int(pp+bin(i)[2:],2)</span><br><span class="line">    if N//px:</span><br><span class="line">        p=N//px</span><br><span class="line">        print(p)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>这里解释一下，为什么一小段一小段的恢复。</em></strong></p><p><strong><em>因为我们是知道P的一部分高位，Q=N//P也只能求出Q的一部分高位。为了精准，我们可以把间隔选短一点儿。</em></strong></p><p><strong><em>上面脚本中我所选的间隔分别是4和5</em></strong></p><p>求解n</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">p = 9366986529377069783394625848920106951220134111548343265311677163992169555436421569730703291128771472885865288798344038000984911921843088200997725324682297</span><br><span class="line">q=N//p</span><br><span class="line"></span><br><span class="line">e=11</span><br><span class="line">phi=(p-1)*(q-1)</span><br><span class="line">d=invert(e,phi)</span><br><span class="line">c1=14183763184495367653522884147951054630177015952745593358354098952173965560488104213517563098676028516541915855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span><br><span class="line"></span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line"></span><br><span class="line">n=pow(c1,d,N)  # n可能比N大</span><br><span class="line"># print(n.bit_length()) 1020bit</span><br><span class="line">n = n + N</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><p><strong><em>因为n=pow(c1,d,N)求出来的n只有1020bit,而理论上n应该有1024bit,所以手动加上N.</em></strong></p><p>求解secret</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c2 = x ^ 11 </span><br><span class="line">c3 = (bytes_to_long(b&#x27;dasctf&#123;&#x27; + b&#x27;\00&#x27; * i + b&#x27;&#125;&#x27; ) * 256 ** (i + 1) + 256 * x) ^ 11</span><br><span class="line">(其中x = secret , i = len(secret))</span><br></pre></td></tr></table></figure><p><strong><em>典型的相关信息攻击</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 83410392685813224685786027640778560521035854332627839979281105731457044069408118952629284089869335506983096270269822559619624906180108256504440296527471536363057103101146262613593336072556587341466840510200003498265457285439149541137127199088938421905041387224795918868443175561632999479925818053898100117419</span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line">def GCD(a,b):      # 求解多项式的最大公因子</span><br><span class="line">    if b == 0:</span><br><span class="line">        return a.monic()</span><br><span class="line">    else:</span><br><span class="line">        return GCD(b,a % b)</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">for i in range(50):</span><br><span class="line">    f1 = x ^ 11 - c2</span><br><span class="line">    f2 = (bytes_to_long(b&#x27;dasctf&#123;&#x27; + b&#x27;\x00&#x27; * i + b&#x27;&#125;&#x27;) + 256 * x) ^ 11 - c3</span><br><span class="line">    if GCD(f1,f2)[0] != 1:</span><br><span class="line">        print(b&#x27;dasctf&#123;&#x27; + long_to_bytes(int(n - GCD(f1,f2)[0])) + b&#x27;&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># dasctf&#123;C0pper_Sm1th_Mak3s_T1ng5_Bet4er&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def GCD(a,b):      # 求解多项式的最大公因子</span><br><span class="line">    if b == 0:</span><br><span class="line">        return a.monic()</span><br><span class="line">    else:</span><br><span class="line">        return GCD(b,a % b)</span><br></pre></td></tr></table></figure><p><strong><em>使用辗转相除法求多项式的最大公因子</em></strong><strong><em>在代数中，一个多项式的首项系数通常被称为该多项式的引导系数（leadingcoefficient），而将多项式变成首项系数为1的形式被称为将多项式化为首一形式（monicform）</em></strong><strong><em>调用函数g1.monic()将g1转换为首一多项式（monicpolynomial），并返回该多项式。</em></strong><strong><em>使用g.monic()[0]，则会返回g(x)除以引导系数后得到的多项式的常数项</em></strong><strong><em>比如：g.monic() = x + 32412345</em></strong><strong><em>那么：g.monic()[0] = 32412345</em></strong></p><h2 id="ezalgebra">ezAlgebra</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import getPrime, bytes_to_long</span><br><span class="line"></span><br><span class="line">def YiJiuJiuQiNian(Wo, Xue, Hui, Le, Kai):</span><br><span class="line">    Qi = 1997</span><br><span class="line">    Che = Wo+Hui if Le==1 else Wo*Hui</span><br><span class="line">    while(Xue):</span><br><span class="line">        Qi += (pow(Che, Xue, Kai)) % Kai</span><br><span class="line">        Xue -= 1</span><br><span class="line">    return Qi</span><br><span class="line">l = 512</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(l)</span><br><span class="line">q = getPrime(l//2)</span><br><span class="line">r = getPrime(l//2)</span><br><span class="line">n = p * q * r</span><br><span class="line">t = getrandbits(32)</span><br><span class="line">c1 = YiJiuJiuQiNian(t, 4, p, 1, n)</span><br><span class="line">c2 = YiJiuJiuQiNian(m, 19, t, 0, q)</span><br><span class="line">c3 = YiJiuJiuQiNian(m, 19, t, 1, q)</span><br><span class="line">print(f&quot;n = &#123;n&#125;&quot;)</span><br><span class="line">print(f&quot;c1 = &#123;c1&#125;&quot;)</span><br><span class="line">print(f&quot;c2 = &#123;c2&#125;&quot;)</span><br><span class="line">print(f&quot;c3 = &#123;c3&#125;&quot;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 119156144845956004769507478085325079414190248780654060840257869477965140304727088685316579445017214576182010373548273474121727778923582544853293534996805340795355149795694121455249972628980952137874014208209750135683003125079012121116063371902985706907482988687895813788980275896804461285403779036508897592103</span><br><span class="line">c1 = 185012145382155564763088060801282407144264652101028110644849089283749320447842262397065972319766119386744305208284231153853897076876529326779092899879401876069911627013491974285327376378421323298147156687497709488102574369005495618201253946225697404932436143348932178069698091761601958275626264379615139864425</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>简单化简一下题目信息： <span class="math display">\[n = p*q*r\]</span></p><p><span class="math display">\[c1 -1997= che^{4}+che^{3}+che^{2}+che\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[c_{2}-1997=(t*m)^{19}+(t*m)^{18}+...+(t*m)^{2}+(t*m)\textbf{}mod\textbf{ }q\]</span></p><p><span class="math display">\[c_{3}-1997=(t+m)^{19}+(t+m)^{18}+...+(t+m)^{2}+(t+m)\textbf{}mod\textbf{ }q\]</span></p><p>根据模腐蚀性质， <span class="math display">\[c1-1997=t^{4}+t^{3}+t^{2}+t\textbf{ }mod\textbf{ }p\Rightarrowk*p=c_{1}-(t^{4}+t^{3}+t^{2}+t+1997)\]</span> 就相当于已知p高位，运用copper求解t</p><p>之后用gcd(k*p,n)求p</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import isPrime, long_to_bytes</span><br><span class="line">n = 119156144845956004769507478085325079414190248780654060840257869477965140304727088685316579445017214576182010373548273474121727778923582544853293534996805340795355149795694121455249972628980952137874014208209750135683003125079012121116063371902985706907482988687895813788980275896804461285403779036508897592103</span><br><span class="line">c1 = 185012145382155564763088060801282407144264652101028110644849089283749320447842262397065972319766119386744305208284231153853897076876529326779092899879401876069911627013491974285327376378421323298147156687497709488102574369005495618201253946225697404932436143348932178069698091761601958275626264379615139864425</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">#xue1=4 ,che1=t+p,kai=n</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x^4+x^3+x^2+x-c1+1997</span><br><span class="line">t = f.small_roots(X=2^32, beta=0.4)[0]</span><br><span class="line"># print(t)</span><br><span class="line"></span><br><span class="line">t=2915836867</span><br><span class="line">kp=t**4+t**3+t**2+t-c1+1997</span><br><span class="line">p = gmpy2.gcd(kp,n)</span><br><span class="line"># print(p)</span><br><span class="line"># print(p.bit_length())</span><br><span class="line">#print(isPrime(p))</span><br><span class="line">N=n//p</span><br></pre></td></tr></table></figure><p>两个模q下的19次同解多项式，利用groebner_basis求出q</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xue2=19 che=m*t kai=q</span><br><span class="line">Qi-1997=che^19+che^18 +....+che</span><br><span class="line"></span><br><span class="line">xue3=19 che=(m+t) kai=q</span><br><span class="line">Qi-1997=che^19+che^18+....+che</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">P.&lt;x,y&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f1=1997-c2</span><br><span class="line">f2=1997-c3</span><br><span class="line">for i in range(1,20):</span><br><span class="line">    f1+=(x*t)^i</span><br><span class="line">    f2+=(x+t)^i</span><br><span class="line">G=[f1,f2]</span><br><span class="line">B=Ideal(G).groebner_basis() #Gröbner 基是多项式环中理想的一种特殊生成集，用于许多运算，例如求解多项式方程组。</span><br><span class="line"># print(B)</span><br><span class="line"></span><br><span class="line">q=87038069032840052005520908272237788908169043580221040711149494083975743478969</span><br><span class="line">r = n//(p*q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q=87038069032840052005520908272237788908169043580221040711149494083975743478969</span><br><span class="line">x=56985796272753226120469211992443340429346162287195965942430959147227534853120</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">for i in range(2**25):</span><br><span class="line">    flag=long_to_bytes(x+i*q)</span><br><span class="line">    if b&#x27;dasctf&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
