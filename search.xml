<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LCG入门</title>
      <link href="/2023/08/10/LCG%E5%85%A5%E9%97%A8/"/>
      <url>/2023/08/10/LCG%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="lcg线性同余生成器">LCG(线性同余生成器)</h2><p>LCG属于PRNG(伪随机数生成器)和streamcipher(流密码)的一种，是一种产生伪随机数的方法。 <span class="math display">\[X_{n+1}=(a*X_{n}+b)\textbf{ }mod\textbf{ }m\]</span>其中，Xn代表第n个生成的随机数，X0被称为种子值。这里还定义了三个整数：a乘数、b增量、m模数，是产生器设定的常数。</p><h2 id="参数选择">参数选择</h2><p>LCG的性质与参数的选择密切相关，不同的参数可能导致不同的随机序列。一般按照如下要求选择参数：</p><p>1、m是随机序列的模数，必须一个大于0的正整数。一般是一个比较大的素数或者是2的幂，以便提供较长的周期长度。</p><p>2、a是乘数，必须是一个与m互素的正整数。</p><p>3、b是增量，也必须是一个与m互素的正整数。</p><h2 id="常用公式">常用公式</h2><h3 id="公式一由xn1反推xn">公式一：由Xn+1反推Xn</h3><p><span class="math display">\[X_{n}=((X_{n+1}-b)*a^{-1})\textbf{ }mod\textbf{ }m，这里a^{-1}是模逆元\]</span></p><h3 id="公式二求a">公式二：求a</h3><p><span class="math display">\[\left\{\begin{matrix}X_{n+1} &amp; = &amp;(a*X_{n}+b)  &amp;mod  &amp;m \\X_{n} &amp; = &amp;(a*X_{n-1})  &amp; mod &amp;m\end{matrix}\right.\Rightarrowa=((X_{n+1}-X_{n})*(X_{n}-X_{n-1})^{-1}\textup{ })mod\textbf{ }m\]</span></p><h3 id="公式三求b">公式三：求b</h3><p><span class="math display">\[b=(X_{n+1}-a*X_{n})\textbf{ }mod\textbf{ }m\]</span></p><h3 id="公式四求m">公式四：求m</h3><p><span class="math display">\[t_{n}=X_{n+1}-X_{n},t_{n}=(a*X_{n}+b)-(a*X_{n-1}+b)=a(X_{n}-X_{n-1})=a*t_{n-1}\textbf{} mod\textbf{ }m.\]</span></p><p><span class="math display">\[\thereforet_{n+1}t_{n-1}-t_{n}t_{n}=a*a*t_{n-1}*t_{n-1}-a*t_{n-1}*a*t_{n-1}=0\textup{}mod\textup{ }m\]</span></p><p><span class="math display">\[即T_{n}=t_{n+1}t_{n-1}-t_{n}t_{n}是m的倍数，故T_{n}和T_{n-1}的最大公因数即为m\]</span></p><h2 id="常见六种题型">常见六种题型</h2><p><strong><em>LCG_1:a、b、m都知道，此类题相当于由Xn+1反推Xn.</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;lcg.a&#125;&#x27;)</span><br><span class="line">print(f&#x27;b = &#123;lcg.b&#125;&#x27;)</span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 113439939100914101419354202285461590291215238896870692949311811932229780896397</span><br><span class="line">b = 72690056717043801599061138120661051737492950240498432137862769084012701248181</span><br><span class="line">m = 72097313349570386649549374079845053721904511050364850556329251464748004927777</span><br><span class="line">9772191239287471628073298955242262680551177666345371468122081567252276480156</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>有一个问题就是，我们需要反推多少项呢？我们并不知道，因为迭代的次数(getPrime(16))是一个随机数。但是这并不妨碍我们求解flag。因为flag的格式(b'NSSFCT{')我们已经知道，只需要不断反推，直至找到符合格式的flag为止。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">a = 113439939100914101419354202285461590291215238896870692949311811932229780896397</span><br><span class="line">b = 72690056717043801599061138120661051737492950240498432137862769084012701248181</span><br><span class="line">m = 72097313349570386649549374079845053721904511050364850556329251464748004927777</span><br><span class="line">c=9772191239287471628073298955242262680551177666345371468122081567252276480156</span><br><span class="line"></span><br><span class="line"># c=(a*c0+b)%m</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c - b) * a_1 % m</span><br><span class="line">    #print(c)</span><br><span class="line">    flag=libnum.n2s(int(c))</span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_2:不知道b,要先求出b,之后操作就和LCG_1没什么区别了</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;a = &#123;lcg.a&#125;&#x27;)</span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 83968440254358975953360088805517488739689448515913931281582194839594954862517</span><br><span class="line">m = 77161425490597512806099499399561161959645895427463118872087051902811605680317</span><br><span class="line">43959768681328408257423567932475057408934775157371406900460140947365416240650</span><br><span class="line">8052043336238864355872102889254781281466728072798160448260752595038552944808</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">from Crypto.Util.number import isPrime</span><br><span class="line"></span><br><span class="line">a = 83968440254358975953360088805517488739689448515913931281582194839594954862517</span><br><span class="line">m = 77161425490597512806099499399561161959645895427463118872087051902811605680317</span><br><span class="line">c1=43959768681328408257423567932475057408934775157371406900460140947365416240650</span><br><span class="line">c2=8052043336238864355872102889254781281466728072798160448260752595038552944808</span><br><span class="line"></span><br><span class="line">b=(c2-a*c1) % m</span><br><span class="line">#print(b)</span><br><span class="line">#print(gmpy2.gcd(b,m))</span><br><span class="line">a_1 = gmpy2.invert(a,m)</span><br><span class="line">c = c1</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c-b) * a_1 % m</span><br><span class="line">    flag = libnum.n2s(int(c))</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_3:a、b都不知道，先求出a,之后操作同LCG_2</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(f&#x27;m = &#123;lcg.m&#125;&#x27;)</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">m = 96343920769213509183566159649645883498232615147408833719260458991750774595569</span><br><span class="line">10252710164251491500439276567353270040858009893278574805365710282130751735178</span><br><span class="line">45921408119394697679791444870712342819994277665465694974769614615154688489325</span><br><span class="line">27580830484789044454303424960338587428190874764114011948712258959481449527087</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">m = 96343920769213509183566159649645883498232615147408833719260458991750774595569</span><br><span class="line">c1 = 10252710164251491500439276567353270040858009893278574805365710282130751735178</span><br><span class="line">c2 = 45921408119394697679791444870712342819994277665465694974769614615154688489325</span><br><span class="line">c3 = 27580830484789044454303424960338587428190874764114011948712258959481449527087</span><br><span class="line"></span><br><span class="line">a = (c3-c2) * gmpy2.invert(c2-c1,m) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line">a_1 = gmpy2.invert(a,m)</span><br><span class="line">b = (c2-a*c1) % m</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">c = c1</span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c = (c-b) * a_1 % m</span><br><span class="line">    flag = libnum.n2s(int(c))</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_4：a、b、m都不知道，给出多组输出，让我们恢复初始种子。</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">47513456973995038401745402734715062697203139056061145149400619356555247755807</span><br><span class="line">57250853157569177664354712595458385047274531304709190064872568447414717938749</span><br><span class="line">30083421760501477670128918578491346192479634327952674530130693136467154794135</span><br><span class="line">38739029019071698539301566649413274114468266283936163804522278316663267625091</span><br><span class="line">42506270962409723585330663340839465445484970240895653869393419413017237427900</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>首先，我们要先求出m，才能LCG_3的操作。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c=[47513456973995038401745402734715062697203139056061145149400619356555247755807,</span><br><span class="line">   57250853157569177664354712595458385047274531304709190064872568447414717938749,</span><br><span class="line">   30083421760501477670128918578491346192479634327952674530130693136467154794135,</span><br><span class="line">   38739029019071698539301566649413274114468266283936163804522278316663267625091,</span><br><span class="line">   42506270962409723585330663340839465445484970240895653869393419413017237427900]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line"># print(isPrime(m))       False</span><br><span class="line"></span><br><span class="line">m//=2</span><br><span class="line"># print(isPrime(m))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>这里需要解释一下代码中为什么要进行 m//=2这样的操作？</em></strong></p><p><strong><em>我们虽然得到了m的倍数，通过求解 GCD 也确实能得到m。但是在数据不够多的情况下，我们可能得到的是 k</em>m(不信的话，你可以输出一下 isPrime(m) 发现 m 确实不是素数),这时就需要我们遍历一些小数，手动去除 k 。</strong>*</p><p><strong><em>LCG_5:本题给出信息和LCG_4一样需要我们恢复参数。</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = self.a * (self.seed - self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">57648351648792284446777383544515312078150027665462203747924668509833442797796</span><br><span class="line">90378879763416486117626477831653213918315023665514305359005153448529276829825</span><br><span class="line">21826576702665114807208181233864324586557058567478767825970403161758214940301</span><br><span class="line">47594460970742467761038407996122637655856234121180714918606854365482948918701</span><br><span class="line">11871076497267630136796123094001159466754095580273018347962555675375123133730</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><strong><em>需要注意的是，这里所给的LCG递归式是</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.seed = self.a * (self.seed - self.b) % self.m</span><br></pre></td></tr></table></figure><p><strong><em>我们只需要把 -ab 看成一个整体，这样我们就可以转化为标准式ax+b 的形式。因为这里我们只需要恢复初始种子m，所以代码和LCG_4没什么区别。</em></strong></p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c=[57648351648792284446777383544515312078150027665462203747924668509833442797796,</span><br><span class="line">   90378879763416486117626477831653213918315023665514305359005153448529276829825,</span><br><span class="line">   21826576702665114807208181233864324586557058567478767825970403161758214940301,</span><br><span class="line">   47594460970742467761038407996122637655856234121180714918606854365482948918701,</span><br><span class="line">   11871076497267630136796123094001159466754095580273018347962555675375123133730]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line">print(isPrime(m))   # False m的倍数</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">for i in range(1,100):</span><br><span class="line">    if isPrime(m//i):</span><br><span class="line">        print(i)   # i是4</span><br><span class="line">        m//=i</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>LCG_6:同样需要恢复参数</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><span class="line"></span><br><span class="line">class LCG:</span><br><span class="line">    def __init__(self, seed, a, b, m):</span><br><span class="line">        self.seed = seed  # 初始种子</span><br><span class="line">        self.a = a  # 乘数</span><br><span class="line">        self.b = b  # 增量</span><br><span class="line">        self.m = m  # 模数</span><br><span class="line"></span><br><span class="line">    def generate(self):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        return self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(255), getPrime(255), getPrime(256))</span><br><span class="line"></span><br><span class="line">for i in range(getPrime(16)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br><span class="line">print(lcg.generate())</span><br></pre></td></tr></table></figure><p><strong><em>这里进行了两次加密，我们得到的并不是连续的输出，而是隔位输出，比如是X2,X4,X6,X8,X10</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">self.seed = (self.a * self.seed + self.b) % self.m</span><br></pre></td></tr></table></figure><p>首先要恢复模数 m， <span class="math display">\[\left\{\begin{matrix}X_{2} &amp;=  &amp;(a*X_{1}+b) &amp;mod  &amp;m \\X_{4}&amp; = &amp; (aX_{3}+b) &amp;mod  &amp;m\end{matrix}\right.\Rightarrow (X_{4}-X_{2})=a(X_{3}-X_{1})\textbf{}mod\textbf{ }m\]</span> 依然可以构造消去增量 b构造等比数列，所以我们依然可以用之前的方法求 m 。</p><p>接下来就是求 a， <span class="math display">\[(X_{4}-X_{2})=a(X_{3}-X_{1})\textbf{ }mod\textbf{}m=a((aX_{2}+b)-(aX_{0}+b))\textbf{ }mod\textbf{}m=a^{2}(X_{2}-X_{0})\textbf{ }mod\textbf{ }m\]</span> 那么，这个平方我们该如何处理呢？我们看Xenny师傅 怎么解决。</p><p><img src="/github.io/2023/08/10/LCG%E5%85%A5%E9%97%A8/P6.jpg"></p><p>这个方法我也还是一知半解(AMM算法也不是很明白)。这里，讲一下我的做法。前面已经说过，本题进行了两轮加密，所给输出是间隔的。<span class="math display">\[X_{n+1}=(aX_{n}+b)\textbf{ }mod\textbf{ }m=(a(aX_{n-1}+b)+b)\textbf{}mod\textbf{ }m\]</span> 可以把 a**2 看作 a,把 (a+1)b 看成b，这样就相当于重新构造了一个LCG。</p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import GCD, isPrime, long_to_bytes</span><br><span class="line"></span><br><span class="line">c = [25445927935559969212648839062255651208014967526951331344342413906051118248013,</span><br><span class="line">81572970970116732975667604095930675262596098540738447440566868976253289440293,</span><br><span class="line">6956793925625110803779114150160476498676179542815207353218944386232051429289,</span><br><span class="line">88042506866508011592456777776490262927213783361334741921985316105965255450508,</span><br><span class="line">5652832125321707726481846809536180176877263519327268361130605456255558285092]</span><br><span class="line"></span><br><span class="line">t=[]</span><br><span class="line">for i in range(1,len(c)):</span><br><span class="line">    t.append(c[i]-c[i-1])</span><br><span class="line"></span><br><span class="line">m = 0</span><br><span class="line">for i in range(1,len(t)-1):</span><br><span class="line">    m = GCD(t[i+1]*t[i-1]-t[i]**2, m)</span><br><span class="line"># print(isPrime(m))   # true</span><br><span class="line"></span><br><span class="line">a = (c[3]-c[2])*gmpy2.invert(c[2]-c[1],m) % m</span><br><span class="line">b = (c[2]-a*c[1]) % m             # 把(a+1)*b当成b就可以了</span><br><span class="line"># print(gmpy2.gcd(a,m))</span><br><span class="line"># print(gmpy2.gcd(b,m))</span><br><span class="line">a_1=gmpy2.invert(a,m)</span><br><span class="line"></span><br><span class="line">for i in range(2**16):</span><br><span class="line">    c[1] = (c[1]-b) * a_1 % m</span><br><span class="line">    flag = long_to_bytes(c[1])</span><br><span class="line"></span><br><span class="line">    if b&#x27;NSSCTF&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>最后附上我参考的文章：</p>]]></content>
      
      
      <categories>
          
          <category> 流密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023DASCTF七月挑战赛复现</title>
      <link href="/2023/08/03/2023DASCTF%E4%B8%83%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/08/03/2023DASCTF%E4%B8%83%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="ezdhke">EzDHKE</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from hashlib import sha256</span><br><span class="line">from random import randbytes, getrandbits</span><br><span class="line">from flag import flag</span><br><span class="line">def diffie_hellman(g, p, flag):</span><br><span class="line">    alice = getrandbits(1024)</span><br><span class="line">    bob = getrandbits(1024)</span><br><span class="line">    alice_c = pow(g, alice, p)</span><br><span class="line">    bob_c = pow(g, bob, p)</span><br><span class="line">    print(alice_c , bob_c)</span><br><span class="line">    key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br><span class="line"></span><br><span class="line">    iv = b&quot;dasctfdasctfdasc&quot;</span><br><span class="line"></span><br><span class="line">    aes = AES.new(key, AES.MODE_CBC, iv)  </span><br><span class="line">    </span><br><span class="line">    enc = aes.encrypt(flag)</span><br><span class="line">    print(enc)</span><br><span class="line"></span><br><span class="line">def getp():</span><br><span class="line">    p = int(input(&quot;P = &quot;))</span><br><span class="line">    assert isPrime(p)</span><br><span class="line">    assert p.bit_length() &gt;= 1024 and p.bit_length() &lt;= 2048</span><br><span class="line">    g = 2</span><br><span class="line">    diffie_hellman(g, p, flag)</span><br><span class="line"></span><br><span class="line">getp()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br></pre></td></tr></table></figure><p>获取 Bob 发送的值( bob_c)，将其提高到 Alice 私钥的幂，然后取模p。</p><p>然后将生成的长整数转换为字节并使用 SHA-256进行哈希处理，哈希运算的结果作为字节字符串返回。</p><p>最终结果作为 Alice 和 Bob 的共享密钥。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iv = b&quot;dasctfdasctfdasc&quot;</span><br></pre></td></tr></table></figure><p>AES的CBC模式（分组密码链接模式）设置初始化向量(IV)。</p><p>IV 是一个随机数，用作密文的第一个块。这是必要的，因为 AES是分组密码，而分组密码需要初始化向量来启动加密过程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)  #创建一个新的 AES 对象</span><br></pre></td></tr></table></figure><p>密钥、IV 和明文必须都是类似字节的对象。密钥的长度必须为 16、24 或 32字节(128bit,192bit,256bit)， IV 的长度必须为 16 字节（因为 AES 在 16字节的块上运行），明文的长度必须是 16 字节的倍数。 如果明文不是 16字节的倍数，则必须对其进行填充以达到 16 的倍数的大小。</p><p><strong><em>flag被CBC(分组密码链接模式)进行加密，我们已知初始化向量(IV),目的是求key。</em></strong></p><p><strong><em>而key是被DH加密了的，要求key,还需求出alice。</em></strong></p><p><strong><em>get()函数要求我们传入一个1024bit-2048bit的素数p,我们不防传入一个光滑素数，能很快求解</em></strong> <span class="math display">\[Alice_c\equiv g^{alice}\textbf{ }mod\textbf{ }p\]</span> wp:</p><p>生成光滑素数p</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from random import choice</span><br><span class="line">from Crypto.Util.number import isPrime</span><br><span class="line">def myPrime(bits):</span><br><span class="line">    while True:</span><br><span class="line">        n = 2</span><br><span class="line">        while n.bit_length() &lt; bits:</span><br><span class="line">            n *= choice(primes)</span><br><span class="line">        if isPrime(n + 1):</span><br><span class="line">            return n + 1</span><br><span class="line">p = myPrime(1024)</span><br><span class="line">print(p)</span><br><span class="line">#189748605665158082111275872557704333522039726199999895031706315085902660337411854647983122666062556936534670800160523701824801162274106958140146326402455411620555437280926462736018015567166363230091558715628717720419196163767507352475201252315824517036725244214039625995753473481520129898146252693266565762094927</span><br></pre></td></tr></table></figure><p>求解alice</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 环境：sage</span><br><span class="line"># Baby-step Giant-step法</span><br><span class="line">def babystep_giantstep(g, y, p, q=None):</span><br><span class="line">    if q is None:</span><br><span class="line">        q = p - 1</span><br><span class="line">    m = int(q**0.5 + 0.5)</span><br><span class="line">    # Baby step</span><br><span class="line">    table = &#123;&#125;</span><br><span class="line">    gr = 1  # g^r</span><br><span class="line">    for r in range(m):</span><br><span class="line">        table[gr] = r</span><br><span class="line">        gr = (gr * g) % p</span><br><span class="line">    # Giant step</span><br><span class="line">    try:</span><br><span class="line">        gm = pow(g, -m, p)  # gm = g^&#123;-m&#125;</span><br><span class="line">    except:</span><br><span class="line">        return None</span><br><span class="line">    ygqm = y                # ygqm = y * g^&#123;-qm&#125;</span><br><span class="line">    for q in range(m):</span><br><span class="line">        if ygqm in table:</span><br><span class="line">            return q * m + table[ygqm]</span><br><span class="line">        ygqm = (ygqm * gm) % p</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"># Pohlig–Hellman法</span><br><span class="line">def pohlig_hellman_DLP(g, y, p):</span><br><span class="line">    crt_moduli = []</span><br><span class="line">    crt_remain = []</span><br><span class="line">    for q, _ in factor(p-1):</span><br><span class="line">        x = babystep_giantstep(pow(g,(p-1)//q,p), pow(y,(p-1)//q,p), p, q)</span><br><span class="line">        if (x is None) or (x &lt;= 1):</span><br><span class="line">            continue</span><br><span class="line">        crt_moduli.append(q)</span><br><span class="line">        crt_remain.append(x)</span><br><span class="line">    x = crt(crt_remain, crt_moduli)</span><br><span class="line">    return x</span><br><span class="line">    </span><br><span class="line">p = 189748605665158082111275872557704333522039726199999895031706315085902660337411854647983122666062556936534670800160523701824801162274106958140146326402455411620555437280926462736018015567166363230091558715628717720419196163767507352475201252315824517036725244214039625995753473481520129898146252693266565762094927</span><br><span class="line">g=2</span><br><span class="line">y=126335148728121839165214578712616714896068088431242768032099119311672927960066757778886759581732563397664623281291468786455806669506289945000832687256947547715890013891156717873951970575686566623998313033814629227260784874473674493141956695555624444324423123550043331270766000934442345084521173496612684244521817 </span><br><span class="line"></span><br><span class="line">x = pohlig_hellman_DLP(g, y, p)</span><br><span class="line">print(x)</span><br><span class="line">print(pow(g, x, p) == y)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;19725268140486219931273670184627509421886594371218668473170713602614775174554822553913723749247515418643589204928857895458812995617382397101146613792597234401181086237828962337082170640415285598027205377319087246590523359362089919920879645846905409986181936892939004568920963678760604527317649686645891069878</span><br><span class="line">True&#x27;&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后求key,解flag</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alice=19725268140486219931273670184627509421886594371218668473170713602614775174554822553913723749247515418643589204928857895458812995617382397101146613792597234401181086237828962337082170640415285598027205377319087246590523359362089919920879645846905409986181936892939004568920963678760604527317649686645891069878</span><br><span class="line">bob_c=82024715586746697978530132111368994011716076980502454618150572158919032873444387902613386183552926303651710370065737129756192440674145837908673206529875835887003844314561287987895409315122184287323905278866402929779666428512421254584747210553034542812693842282458559568445136236463734031158504503149333460169444</span><br><span class="line"></span><br><span class="line">enc=b&quot;Ky\x91\xf5\n\xe4\x03&#x27;\xa8\xf2c\xd6\x95m\xa7\x8bj\xfb\x03nU\x0e\x95\xd7(\xb9\xa4\xcf\xcbg\xd6gR\xe1m\xef7Q\x151h\x0c\xc6x\xb1\xfcZ^&quot;</span><br><span class="line"></span><br><span class="line">key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br><span class="line">iv = b&quot;dasctfdasctfdasc&quot;</span><br><span class="line"></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">flag = aes.decrypt(enc)</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line"># b&#x27;DASCTF&#123;1c65a8d9-ca95-4217-a98c-b119c6f313b1&#125;</span><br></pre></td></tr></table></figure><h2 id="ezrsa">ezRSA</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import secret, flag</span><br><span class="line">def encrypt(m):</span><br><span class="line">    return pow(m, e, n)</span><br><span class="line">assert flag == b&quot;dasctf&#123;&quot; + secret + b&quot;&#125;&quot;</span><br><span class="line">e = 11</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p * q</span><br><span class="line">P = getPrime(512)</span><br><span class="line">Q = getPrime(512)</span><br><span class="line">N = P * Q</span><br><span class="line">gift = P ^ (Q &gt;&gt; 16)</span><br><span class="line">print(N, gift, pow(n, e, N))</span><br><span class="line">print(encrypt(bytes_to_long(secret)),</span><br><span class="line">    encrypt(bytes_to_long(flag)))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line">a=1418376318449536765352288414795105463017701595274559335835409895217396556048810421351756309867602851654191c1=5855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009 </span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>已知P高16位，可以根据P=gift^Q恢复P,所以要先根据Q=N//P恢复Q。</p><p>wp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line"></span><br><span class="line">pp=bin(gift)[2:18]  # 截取p的高16位</span><br><span class="line">#print(pp)</span><br><span class="line"></span><br><span class="line">gift=bin(gift)[2:][16:]  # 截取gift的剩余位</span><br><span class="line">#print(gift)</span><br><span class="line">k = 512-16</span><br><span class="line"></span><br><span class="line"># 恢复p</span><br><span class="line">x=4</span><br><span class="line">for i in range(k//x):</span><br><span class="line">    PP = int(pp + &#x27;0&#x27;*k,2)  # 已知高位</span><br><span class="line">    #print(PP)</span><br><span class="line">    QQ=bin(N//PP)[2:][i*x:(i+1)*x] # 计算Q高位</span><br><span class="line">    #print(QQ)</span><br><span class="line">    gg = gift[i*x:(i+1)*x]</span><br><span class="line">    #print(gg)</span><br><span class="line">    pb = bin(int(QQ, 2) ^ int(gg, 2))[2:].zfill(x)</span><br><span class="line">    #print(pb)</span><br><span class="line">    pp+=pb</span><br><span class="line">    k-=x</span><br><span class="line">px=int(pp,2)</span><br><span class="line">if N//px:</span><br><span class="line">    p=N//px</span><br><span class="line">    print(p)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N=75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift=8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line"></span><br><span class="line">#pp=bin(gift)[2:][:16]  # 截取gift的前16位</span><br><span class="line">pp=bin(gift)[2:18]</span><br><span class="line"># print(bin(gift))</span><br><span class="line"># print(pp)</span><br><span class="line">b=512-16</span><br><span class="line"></span><br><span class="line">gift=bin(gift)[2:][16:] # 截取gift剩余的位数</span><br><span class="line">#print(gift)</span><br><span class="line"></span><br><span class="line">x=5</span><br><span class="line">for i in range((512-16)//x):</span><br><span class="line">    PP=int(pp+&#x27;0&#x27;*b,2)  #已知高位</span><br><span class="line">    #print(PP)</span><br><span class="line">    Qb=bin(N//PP)[2:][i*x:x*i+x]  #算出Q的高位,取5</span><br><span class="line">    #print(Qb)</span><br><span class="line">    gb=gift[i*x:i*x+x]</span><br><span class="line">    #print(gb)</span><br><span class="line">    pb=bin(int(gb,2)^int(Qb,2))[2:].zfill(x)</span><br><span class="line">    #print(pb)</span><br><span class="line">    pp+=pb</span><br><span class="line">    #print(pp)</span><br><span class="line">    b-=x</span><br><span class="line">for i in range(3): #还差1位</span><br><span class="line">    px = int(pp+bin(i)[2:],2)</span><br><span class="line">    if N//px:</span><br><span class="line">        p=N//px</span><br><span class="line">        print(p)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong><em>这里解释一下，为什么一小段一小段的恢复。</em></strong></p><p><strong><em>因为我们是知道P的一部分高位，Q=N//P也只能求出Q的一部分高位。为了精准，我们可以把间隔选短一点儿。</em></strong></p><p><strong><em>上面脚本中我所选的间隔分别是4和5</em></strong></p><p>求解n</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">p = 9366986529377069783394625848920106951220134111548343265311677163992169555436421569730703291128771472885865288798344038000984911921843088200997725324682297</span><br><span class="line">q=N//p</span><br><span class="line"></span><br><span class="line">e=11</span><br><span class="line">phi=(p-1)*(q-1)</span><br><span class="line">d=invert(e,phi)</span><br><span class="line">c1=14183763184495367653522884147951054630177015952745593358354098952173965560488104213517563098676028516541915855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span><br><span class="line"></span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line"></span><br><span class="line">n=pow(c1,d,N)  # n可能比N大</span><br><span class="line"># print(n.bit_length()) 1020bit</span><br><span class="line">n = n + N</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><p><strong><em>因为n=pow(c1,d,N)求出来的n只有1020bit,而理论上n应该有1024bit,所以手动加上N.</em></strong></p><p>求解secret</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c2 = x ^ 11 </span><br><span class="line">c3 = (bytes_to_long(b&#x27;dasctf&#123;&#x27; + b&#x27;\00&#x27; * i + b&#x27;&#125;&#x27; ) * 256 ** (i + 1) + 256 * x) ^ 11</span><br><span class="line">(其中x = secret , i = len(secret))</span><br></pre></td></tr></table></figure><p><strong><em>典型的相关信息攻击</em></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 83410392685813224685786027640778560521035854332627839979281105731457044069408118952629284089869335506983096270269822559619624906180108256504440296527471536363057103101146262613593336072556587341466840510200003498265457285439149541137127199088938421905041387224795918868443175561632999479925818053898100117419</span><br><span class="line">c2=69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span><br><span class="line">c3=46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line">def GCD(a,b):      # 求解多项式的最大公因子</span><br><span class="line">    if b == 0:</span><br><span class="line">        return a.monic()</span><br><span class="line">    else:</span><br><span class="line">        return GCD(b,a % b)</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">for i in range(50):</span><br><span class="line">    f1 = x ^ 11 - c2</span><br><span class="line">    f2 = (bytes_to_long(b&#x27;dasctf&#123;&#x27; + b&#x27;\x00&#x27; * i + b&#x27;&#125;&#x27;) + 256 * x) ^ 11 - c3</span><br><span class="line">    if GCD(f1,f2)[0] != 1:</span><br><span class="line">        print(b&#x27;dasctf&#123;&#x27; + long_to_bytes(int(n - GCD(f1,f2)[0])) + b&#x27;&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># dasctf&#123;C0pper_Sm1th_Mak3s_T1ng5_Bet4er&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def GCD(a,b):      # 求解多项式的最大公因子</span><br><span class="line">    if b == 0:</span><br><span class="line">        return a.monic()</span><br><span class="line">    else:</span><br><span class="line">        return GCD(b,a % b)</span><br></pre></td></tr></table></figure><p><strong><em>使用辗转相除法求多项式的最大公因子</em></strong><strong><em>在代数中，一个多项式的首项系数通常被称为该多项式的引导系数（leadingcoefficient），而将多项式变成首项系数为1的形式被称为将多项式化为首一形式（monicform）</em></strong><strong><em>调用函数g1.monic()将g1转换为首一多项式（monicpolynomial），并返回该多项式。</em></strong><strong><em>使用g.monic()[0]，则会返回g(x)除以引导系数后得到的多项式的常数项</em></strong><strong><em>比如：g.monic() = x + 32412345</em></strong><strong><em>那么：g.monic()[0] = 32412345</em></strong></p><h2 id="ezalgebra">ezAlgebra</h2><p>题目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import getPrime, bytes_to_long</span><br><span class="line"></span><br><span class="line">def YiJiuJiuQiNian(Wo, Xue, Hui, Le, Kai):</span><br><span class="line">    Qi = 1997</span><br><span class="line">    Che = Wo+Hui if Le==1 else Wo*Hui</span><br><span class="line">    while(Xue):</span><br><span class="line">        Qi += (pow(Che, Xue, Kai)) % Kai</span><br><span class="line">        Xue -= 1</span><br><span class="line">    return Qi</span><br><span class="line">l = 512</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(l)</span><br><span class="line">q = getPrime(l//2)</span><br><span class="line">r = getPrime(l//2)</span><br><span class="line">n = p * q * r</span><br><span class="line">t = getrandbits(32)</span><br><span class="line">c1 = YiJiuJiuQiNian(t, 4, p, 1, n)</span><br><span class="line">c2 = YiJiuJiuQiNian(m, 19, t, 0, q)</span><br><span class="line">c3 = YiJiuJiuQiNian(m, 19, t, 1, q)</span><br><span class="line">print(f&quot;n = &#123;n&#125;&quot;)</span><br><span class="line">print(f&quot;c1 = &#123;c1&#125;&quot;)</span><br><span class="line">print(f&quot;c2 = &#123;c2&#125;&quot;)</span><br><span class="line">print(f&quot;c3 = &#123;c3&#125;&quot;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 119156144845956004769507478085325079414190248780654060840257869477965140304727088685316579445017214576182010373548273474121727778923582544853293534996805340795355149795694121455249972628980952137874014208209750135683003125079012121116063371902985706907482988687895813788980275896804461285403779036508897592103</span><br><span class="line">c1 = 185012145382155564763088060801282407144264652101028110644849089283749320447842262397065972319766119386744305208284231153853897076876529326779092899879401876069911627013491974285327376378421323298147156687497709488102574369005495618201253946225697404932436143348932178069698091761601958275626264379615139864425</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>简单化简一下题目信息： <span class="math display">\[n = p*q*r\]</span></p><p><span class="math display">\[c1 -1997= che^{4}+che^{3}+che^{2}+che\textbf{ }mod\textbf{ }n\]</span></p><p><span class="math display">\[c_{2}-1997=(t*m)^{19}+(t*m)^{18}+...+(t*m)^{2}+(t*m)\textbf{}mod\textbf{ }q\]</span></p><p><span class="math display">\[c_{3}-1997=(t+m)^{19}+(t+m)^{18}+...+(t+m)^{2}+(t+m)\textbf{}mod\textbf{ }q\]</span></p><p>根据模腐蚀性质， <span class="math display">\[c1-1997=t^{4}+t^{3}+t^{2}+t\textbf{ }mod\textbf{ }p\Rightarrowk*p=c_{1}-(t^{4}+t^{3}+t^{2}+t+1997)\]</span> 就相当于已知p高位，运用copper求解t</p><p>之后用gcd(k*p,n)求p</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import isPrime, long_to_bytes</span><br><span class="line">n = 119156144845956004769507478085325079414190248780654060840257869477965140304727088685316579445017214576182010373548273474121727778923582544853293534996805340795355149795694121455249972628980952137874014208209750135683003125079012121116063371902985706907482988687895813788980275896804461285403779036508897592103</span><br><span class="line">c1 = 185012145382155564763088060801282407144264652101028110644849089283749320447842262397065972319766119386744305208284231153853897076876529326779092899879401876069911627013491974285327376378421323298147156687497709488102574369005495618201253946225697404932436143348932178069698091761601958275626264379615139864425</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">#xue1=4 ,che1=t+p,kai=n</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x^4+x^3+x^2+x-c1+1997</span><br><span class="line">t = f.small_roots(X=2^32, beta=0.4)[0]</span><br><span class="line"># print(t)</span><br><span class="line"></span><br><span class="line">t=2915836867</span><br><span class="line">kp=t**4+t**3+t**2+t-c1+1997</span><br><span class="line">p = gmpy2.gcd(kp,n)</span><br><span class="line"># print(p)</span><br><span class="line"># print(p.bit_length())</span><br><span class="line">#print(isPrime(p))</span><br><span class="line">N=n//p</span><br></pre></td></tr></table></figure><p>两个模q下的19次同解多项式，利用groebner_basis求出q</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xue2=19 che=m*t kai=q</span><br><span class="line">Qi-1997=che^19+che^18 +....+che</span><br><span class="line"></span><br><span class="line">xue3=19 che=(m+t) kai=q</span><br><span class="line">Qi-1997=che^19+che^18+....+che</span><br><span class="line">c2 = 722022978284031841958768129010024257235769706227005483829360633993196299360813</span><br><span class="line">c3 = 999691052172645326792013409327337026208773437618455136594949462410165608463231</span><br><span class="line">P.&lt;x,y&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f1=1997-c2</span><br><span class="line">f2=1997-c3</span><br><span class="line">for i in range(1,20):</span><br><span class="line">    f1+=(x*t)^i</span><br><span class="line">    f2+=(x+t)^i</span><br><span class="line">G=[f1,f2]</span><br><span class="line">B=Ideal(G).groebner_basis() #Gröbner 基是多项式环中理想的一种特殊生成集，用于许多运算，例如求解多项式方程组。</span><br><span class="line"># print(B)</span><br><span class="line"></span><br><span class="line">q=87038069032840052005520908272237788908169043580221040711149494083975743478969</span><br><span class="line">r = n//(p*q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q=87038069032840052005520908272237788908169043580221040711149494083975743478969</span><br><span class="line">x=56985796272753226120469211992443340429346162287195965942430959147227534853120</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">for i in range(2**25):</span><br><span class="line">    flag=long_to_bytes(x+i*q)</span><br><span class="line">    if b&#x27;dasctf&#123;&#x27; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
